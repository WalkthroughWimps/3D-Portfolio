===== Combined file generated on Tue 12/23/2025 at 14:46:21.36 =====


===== START FILE: music.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="template.css">
    <link rel="stylesheet" href="music.css">
  <script src="music.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.0/gsap.min.js" defer></script>
  <!-- three.js + loaders for GLB -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
      }
    }
  </script>
  <!-- Demo-only: no MIDI for now; load our viewer module -->
  <!-- Swap to isolated debug script to diagnose invisibility -->
  <script type="module" src="global-sync.js"></script>
  <!-- SoundFont player for sampled instruments: try multiple CDNs if one fails -->
  <script>
    (function tryLoadSoundfont(){
      const urls = [
        'https://cdn.jsdelivr.net/npm/soundfont-player@0.15.0/dist/soundfont-player.js',
        'https://unpkg.com/soundfont-player@0.15.0/dist/soundfont-player.js',
        'https://ga.jspm.io/npm:soundfont-player@0.15.0/dist/soundfont-player.js',
        'https://cdn.skypack.dev/soundfont-player@0.15.0',
        'https://esm.sh/soundfont-player@0.15.0',
        '/assets/vendor/soundfont-player.js' // local fallback - place file here if CDNs are blocked
      ];
      window.SOUNDFONT_LOADED = null;
      let i = 0;
      function tryOne(){
        if(i >= urls.length){ window.SOUNDFONT_LOADED = false; console.error('soundfont-player: all CDN attempts failed'); return; }
        const src = urls[i++];
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = function(){ window.SOUNDFONT_LOADED = true; console.log('soundfont-player loaded from', src); };
        s.onerror = function(){ console.warn('soundfont-player failed to load from', src); // try next
          // remove element and try next
          s.remove(); setTimeout(tryOne, 100);
        };
        document.head.appendChild(s);
      }
      tryOne();
    })();
  </script>
  <script type="module" src="music-piano-debug.js"></script>

    <!--<img src="assets/svg/Note1.svg" id="Note1" class="note">
    <img src="assets/svg/Note2.svg" id="Note2" class="note">
    <img src="assets/svg/Note3.svg" id="Note3" class="note">
    <img src="assets/svg/Note4.svg" id="Note4" class="note">
    <img src="assets/svg/Note5.svg" id="Note5" class="note">
    <img src="assets/svg/Note6.svg" id="Note6" class="note">
    <img src="assets/svg/Note7.svg" id="Note7" class="note">
    <img src="assets/svg/Note8.svg" id="Note8" class="note">
    <img src="assets/svg/Note9.svg" id="Note9" class="note">-->
</head>

<body>
    <div class="header" id="patterned-background">
        <div class="background-shape" id="patterned-background-shape">
            <div class="head-pic-container">
                <?xml version="1.0" encoding="UTF-8"?>
                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100">
                  <defs>
                    <clipPath id="clippath" clipPathUnits="userSpaceOnUse">
                      <!-- Align clip circle with head-inner for symmetric clipping -->
                      <circle cx="45.7" cy="35.5" r="23.1" style="fill: none;"/>
                    </clipPath>
                    <radialGradient id="radial-gradient" cx="45.7" cy="-6221.6" fx="45.7" fy="-6221.6" r="23.1" gradientTransform="translate(0 -6186.1) scale(1 -1)" gradientUnits="userSpaceOnUse">
                      <stop offset=".7" stop-color="#ccc" stop-opacity="0"/>
                      <stop offset="1" stop-color="#53272d"/>
                    </radialGradient>
                  </defs>
                  <g style="isolation: isolate;">
                    <g id="Layer_1">
                      <path class="head-bg"id="head-bg" d="M2.2,59.86C-3.29,33.02,14.1,7.49,40.14,2.2c19.02-3.86,38.95,3.76,50.34,20.54,17.19,25.42,6.81,60.3-21.56,72.2-28.47,12.1-60.81-5.29-66.81-35.19h0l.1.1Z" style="fill: var(panel-color);"/>
                      <path class="head-fill" id="head-fill" d="M50,0C22.4,0,0,22.4,0,50s22.4,50,50,50,50-22.4,50-50S77.6,0,50,0ZM76.8,89.8c-6.9,4.7-14.5,7.2-22.1,8-.1.01-.2.01-.31.02-.86-1.4-1.89-2.35-3.27-3.27-.24-.58-.74-1.3-.92-2.11-.3-1.7,1.4-2.1,2.5-4.9,0-.3.3-.9.4-1.1l.4-.5c0-.2.2-.2.3-.2.2,0,.5-.5.8-1,.3-.5.5-1.1.5-1.6.2-1.7,0-2.4.2-3.9.4-2.7,2.6-5.3,5-6.5h.6c.8.3,1.7.6,2.5.9,1.1.4,2.2.7,3.4.7,2.7,0,5.7-2.4,6.1-5.9v-1.5c0-.9-.6-1.6.2-2.4.8-.8.8,0,1.2-.4.4-.4.3-1,.3-1.6v-.4c0-.2-.2-.5-.4-.7,3.2-1.5.5-3.6.5-4.1,0,0,.3-.5.3-1,1.5,0,3.3-.8,4.1-2,.2-.3.4-.6.4-.9.3-1.6-.4-2.3-2.7-4.5,0,0-2.4-2.2-3.6-4.3-.5-.9-.7-1.6-.7-2.6v-1c.3-.9,1-1.5,1-2.4s-1.2-5.8-1.2-6.6c-.2-.9-.4-1.7-.5-2.1-.2-.6-.6-1.4-1.1-2.1.8.2,2,.5,2.6,1,.8.6,1.3,1.4,1.6,2.3.4,1.1.5,2.3.5,3.2s0,.2.2.2.3,0,.3-.2c0,0,.4-1.4.2-3.4,0-2.1-.8-3.7-1.6-4.8,1.8-.3,3.4-1.3,4.5-2.6,1.1-1.4,1.5-4,1.3-4.8-.3-.9-1-1.9-1.9-2.3-.5-3.3-3.2-6.6-7.3-7.7-8.1-2-12,3.3-18,1.8s-22.3-1.4-28.2,7c-.9,1.3-1.6,3-1,4.4-1.2.8-2.2,1.9-2.9,3.1-5.1,8.2-3.4,18.9.9,27.5,1.5,2.9,2.9,4.3,2.5,7.9-.2,2.2-1.2,4.6,1.6,5.6.6.2,1.5.5,1.7.5h1.2c0,2.6.8,6.4-1.6,10.6-1.4,2.3-3.6,4.5-4.2,6.1h-.3c-1.7.28-3.58,1.19-5.22,2.22-.06-.06-.12-.11-.18-.16-4.9-4.5-8.9-10.1-11.7-16.6C-6.1,40.6,10.9,9,40.3,3c3.2-.6,6.4-1,9.7-1,13.1,0,25.2,5.3,33.9,14.1,21.4,21.4,17.9,56.8-7.1,73.7Z" style="fill: var(--primary-color);"/>
                      <circle class="head-inner" id="head-inner" cx="45.7" cy="35.5" r="23.1" style="fill: var(--secondary-color); isolation: isolate;"/>
                      <g id="Notes">
                        <g style="clip-path: url(#clippath);">
                          <path class="note" id="Note9" d="M47.81,74c-.59-1.61-2.01-2.41-6.05-5.27-.01-.83-1-.71-.99-.09l.15,14.84c-2.12-1.27-5.55.21-5.24,2.29.18,1.25,1.73,2.06,3.45,1.81,1.72-.25,2.98-1.46,2.8-2.71l-.11-10.97c2.99-.06,4.64,1.36,3.99,5.93.73-.8,1.42-1.66,1.83-2.66.42-1,.55-2.15.18-3.17Z"/>
                          <path class="note" id="Note8" d="M49.26,83.12l-.02-14.43c0-.38-.38-.64-.73-.52-9.91,3.56-9.63,3.3-9.8,3.9-.06.13-.03.02-.01,12.2-1.71-1.05-4.5.13-4.27,1.82.14,1.01,1.39,1.68,2.79,1.49,1.4-.19,2.43-1.17,2.29-2.18v-8.43s8.95-3.22,8.95-3.22v8.22c-1.7-1.05-4.49.13-4.26,1.82.14,1.01,1.39,1.68,2.79,1.49,1.4-.19,2.43-1.17,2.29-2.18ZM39.49,75.82v-1.59s8.96-3.22,8.96-3.22v1.59s-8.96,3.22-8.96,3.22Z"/>
                          <path class="note" id="Note7" d="M41.78,75.04c-2.09.05-3.77,1.36-3.73,2.93s1.76,2.81,3.85,2.76,3.77-1.36,3.73-2.93-1.76-2.81-3.86-2.76ZM41.9,80.24c-1.05.02-1.92-1.01-1.95-2.31-.03-1.3.8-2.37,1.85-2.39,1.05-.02,1.92,1.01,1.95,2.31.03,1.3-.8,2.37-1.85,2.39Z" style="fill: #3ca2a6;"/>
                          <g class="note" id="Note6">
                            <path d="M37.73,68.35s-.05,0-.03,0c-2.92.85-4.15,3.36-4.13,4.43.03,1.1.93,1.96,2.03,1.94,1.1-.03,1.96-.93,1.94-2.03-.03-1.13-.99-2-2.09-1.94,3.63-1.99,8.09.11,8.06,5.75,0,.36-.04.84-.02.64-.48,4.9-2.7,7.84-6.1,10.49,5.52-1.2,9.47-6.94,8.78-12.73-.72-5.21-4.99-7.53-8.45-6.55Z"/>
                            <path d="M50.03,75.66c-.04-1.61-2.47-1.56-2.44.06s2.47,1.56,2.44-.06Z"/>
                            <path d="M47.68,79.59c.04,1.61,2.47,1.56,2.44-.06-.04-1.61-2.47-1.56-2.44.06Z"/>
                          </g>
                          <path class="note" id="Note5" d="M43.37,75.8c-.14-1.44-.25-2.91-.29-4.4.99-.93,2.94-2.88,3.75-4.01,1.96-2.12,1.88-7.72-.97-8.19.02,0-.1-.01-.1-.01-3.55-.2-4.36,8.58-4.33,12.25-3.51,2.56-7.15,5.3-6.57,9.88.63,3.6,4.5,6.03,8.04,5.77.12,2.41.29,6.66-1.36,8.02-1.66,1.37-3.97.39-3.79-1.67,0,.02,0,0,0,0,.16-.76.61-1.11.83-1.26-.42.71.08,1.61.91,1.61,1.18,0,1.48-1.65.38-2.06h0c-2.52-.58-3.9,3.06-1.13,4.55,0,0,.04.02.03.02,1.17.5,2.35.32,3.38-.43-.08.07,2.33-.75,2.16-9.04,7.08-2.08,5.23-11.78-.96-11.03ZM45.56,60.5c1.6.04,3.36,4.96-2.49,9.7,0-2.35.57-8.8,2.49-9.7ZM41.48,72.92c.05,1.2.15,2.3.25,3.36-3.26,1.55-3.38,5.86-.7,7.89l.1-.12c-3.13-3.15.03-6.55-.54-5.78.28-.31.6-.67,1.25-.99.29,2.6.75,5.58.98,8.46-.72.08-8.49-6.65-1.34-12.82ZM47.42,82.15c-.54,1.58-1.67,2.65-3.14,3.23-.14-2.92-.44-5.1-.8-8.53,1.61-.1,2.6.75,2.5.68.93.74,1.42,1.66,1.57,2.76.1.73-.2,1.99-.13,1.86Z"/>
                          <path class="note" id="Note4" d="M49.2,83.71l.87-14.97c.02-.39-.35-.69-.73-.58-10.59,3.1-10.4,2.82-10.45,3.69l-.72,12.41c-1.71-1.19-4.68-.14-4.54,1.63.08,1.06,1.33,1.83,2.8,1.72,1.47-.11,2.59-1.06,2.51-2.12l.67-11.6,9.49-2.78-.66,11.38c-1.71-1.19-4.68-.14-4.54,1.63.08,1.06,1.33,1.83,2.8,1.72,1.46-.11,2.59-1.06,2.51-2.12Z"/>
                          <path class="note" id="Note3" d="M44.97,84.86l-.16-16.23c0-.65-.99-.64-.99,0l.15,14.84c-2.12-1.28-5.54.21-5.24,2.29.18,1.25,1.73,2.06,3.45,1.81,1.73-.25,2.98-1.46,2.8-2.71Z"/>
                          <path class="note" id="Note2" d="M40.06,79.92l.03-10.21c0-.66-1-.67-1,0-.06,16.86-.32,16.84.44,16.85.28,0,.5-.22.5-.5v-.21c1.51-.43,2.87-1.37,3.8-2.63,2.83-3.84-2.23-6.32-3.78-3.29ZM40.04,85.06l.02-4.58c.72-.73,1.89-1.26,2.59-.52.66.7,1.52,3.24-2.6,5.1Z"/>
                          <path class="note" id="Note1" d="M44.99,84.87l-.16-16.23c0-.66-1-.64-.99,0l.15,14.84c-2.41-1.44-5.91.67-5.22,2.41.43,1.25,2.08,1.89,3.43,1.69,1.73-.25,2.98-1.46,2.8-2.71ZM41.94,87.21c-.88.04-1.63-.81-1.68-1.9-.05-1.09.62-2,1.5-2.05.88-.04,1.63.81,1.68,1.9.05,1.09-.62,2.01-1.5,2.05Z"/>
                        </g>
                      </g>
                      <circle id="gradient-circle" cx="45.7" cy="35.5" r="23.1" style="fill: url(#radial-gradient); isolation: isolate; mix-blend-mode: multiply;"/>
                    </g>
                  </g>
                </svg>

            </div>
        </div>

        <div class="title">
            <h1>Matt Hall</h1>
            <h2>Composer</h2>
        </div>

    <div id="header-placeholder"></div> <!-- Placeholder for header -->
  </div>

  <!-- Controls moved into separate fixed overlay (see bottom of file) -->

  
    <section aria-label="3D Toy Piano" class="piano-stage">
        <div class="piano-canvas-wrap">
        <canvas id="pianoCanvas" aria-label="3D toy piano"></canvas>
        <button id="playPerformance" class="piano-play">Play / Pause</button>
      </div>
      <div class="piano-notes" aria-live="polite" aria-atomic="true"></div>
    </section>
  
    <!-- Fixed overlay for music UI: controls + play button -->
    <div class="music-ui-overlay" aria-hidden="false">
      <div class="piano-controls">
        <div class="track-select">
          <button id="trackBaby" data-track="baby" title="Play Baby track">Baby</button>
          <button id="trackRaisins" data-track="raisins" title="Play Raisins track">Raisins</button>
        </div>
        <div class="track-select" style="margin-left:8px;">
          <button id="trackForests" data-track="forests" title="Play Forests track">Forests</button>
        </div>
        <button id="restartPlayback" title="Restart from beginning">Restart</button>
        <label for="playbackRate" style="display:flex; align-items:center; gap:6px; color:#e8fff4; font:12px monospace; margin-left:8px;">
          Speed
          <select id="playbackRate" aria-label="Playback speed">
            <option value="0.75">0.75×</option>
            <option value="0.85">0.85×</option>
            <option value="1" selected>1×</option>
            <option value="1.2">1.2×</option>
            <option value="1.6">1.6×</option>
            <option value="2">2×</option>
          </select>
        </label>
        <!-- UV map controls: toggle/cycle or set directly to U/V -->
        <div class="uv-map-controls" style="display:inline-flex; gap:6px; margin-left:12px; align-items:center;">
          <button id="uvToggleBtn" title="Toggle UV map (none → U → V)">UV: Off</button>
          <button id="uvUBtn" title="Show U color map">UV U</button>
          <button id="uvVBtn" title="Show V color map">UV V</button>
          <button id="uvCheckerBtn" title="Show checkerboard UV map">UV Checker</button>
        </div>
      </div>
      <div class="sync-offset-wrap">
        <label for="syncOffset" class="sync-label">Audio Sync Offset:
          <input id="syncOffset" type="range" min="-3000" max="3000" step="10" value="0" aria-label="Audio sync offset slider (-3000ms to +3000ms)">
          <span id="syncOffsetValue" class="sync-value">0 ms</span>
        </label>
        <small class="sync-hint">(-3s leads MIDI → +3s lags)</small>
      </div>
      <button id="playPerformance" class="piano-play">Play / Pause</button>
    </div>
    <!-- Left-side backend picker (choose library) -->
    <div class="instrument-backend-picker" id="instrumentBackendPicker" aria-hidden="false" role="toolbar" aria-label="Instrument backend picker"></div>
    <!-- Left-side instrument picker -->
    <div class="instrument-picker" id="instrumentPicker" aria-hidden="false" role="toolbar" aria-label="Instrument picker"></div>

    <script>
      // Build backend picker UI and expose preference on window.PREFERRED_INSTRUMENT_BACKEND
      (function(){
        const backends = [
          ['auto','Auto (SoundFont → WebAudioFont)'],
          ['soundfont','soundfont-player'],
          ['webaudiofont','WebAudioFont (CDN)'],
          ['webaudiofont-local','WebAudioFont (local)']
        ];
        const wrap = document.getElementById('instrumentBackendPicker');
        if(!wrap) return;
        const status = document.createElement('div');
        status.style.cssText = 'color:#cfe8d8;font:12px/1.2 "Source Sans 3", system-ui; margin-bottom:6px;';
        status.textContent = 'backend: auto';
        wrap.appendChild(status);
        backends.forEach(([key,label])=>{
          const b = document.createElement('button');
          b.textContent = label;
          b.dataset.backend = key;
          b.addEventListener('click', ()=>{
            window.PREFERRED_INSTRUMENT_BACKEND = key;
            document.querySelectorAll('#instrumentBackendPicker button').forEach(x=>x.classList.remove('active'));
            b.classList.add('active');
            status.textContent = 'backend: ' + label;
            console.log('Instrument backend set to', key);
          });
          wrap.appendChild(b);
        });
        // default to auto
        setTimeout(()=>{ const btn = wrap.querySelector('button[data-backend="auto"]'); if(btn) btn.click(); }, 60);
      })();
    </script>
  

  <script>
        // Build instrument picker buttons and hook to sampler
        (function(){
          const list = [
            ['acoustic_grand_piano','Acoustic Piano'],
            ['bright_acoustic_piano','Bright Piano'],
            ['electric_piano_1','Electric Piano 1'],
            ['electric_piano_2','Electric Piano 2'],
            ['honkytonk','Honky-Tonk'],
            ['harpsichord','Harpsichord'],
            ['vibraphone','Vibraphone'],
            ['church_organ','Organ'],
            ['accordion','Accordion'],
            ['string_ensemble_1','Strings'],
            ['pad_1','Pad'],
            ['choir_aahs','Choir']
          ];
          const wrap = document.getElementById('instrumentPicker');
          if(!wrap) return;
          const status = document.createElement('div');
          status.style.cssText = 'color:#cfe8d8;font:12px/1.2 "Source Sans 3", system-ui; margin-bottom:6px;';
          status.textContent = 'No instrument loaded';
          wrap.appendChild(status);
          // Reflect soundfont loader state in the status text while attempting CDN loads
          if(window.SOUNDFONT_LOADED === null){ status.textContent = 'Loading soundfont-player...'; }
          if(window.SOUNDFONT_LOADED === false){ status.textContent = 'Soundfont script failed to load (check console)'; }
          const sfCheck = setInterval(()=>{
            if(window.SOUNDFONT_LOADED === true){
              status.textContent = 'No instrument loaded';
              clearInterval(sfCheck);
            } else if(window.SOUNDFONT_LOADED === false){
              status.textContent = 'Soundfont script failed to load (check console)';
              clearInterval(sfCheck);
            } else {
              status.textContent = 'Loading soundfont-player...';
            }
          }, 250);
          list.forEach(([name,label])=>{
            const b = document.createElement('button');
            b.textContent = label;
            b.dataset.instrument = name;
            b.addEventListener('click', async (ev)=>{
              const btn = ev.currentTarget;
              btn.disabled = true; btn.classList.add('loading');
              try{
                const inst = await window.loadInstrument(name);
                if(inst){
                  document.querySelectorAll('.instrument-picker button').forEach(x=>x.classList.remove('active'));
                  btn.classList.add('active');
                  status.textContent = 'Loaded: ' + label;
                } else {
                  status.textContent = 'Load failed';
                }
              }catch(e){ alert('Failed to load instrument: '+name); }
              btn.disabled = false; btn.classList.remove('loading');
            });
            // extra debug: log pointer events so we can see clicks in the console
            b.addEventListener('pointerenter', ()=>{ console.log('picker hover', name); });
            b.addEventListener('pointerdown', ()=>{ console.log('picker down', name); });
            b.addEventListener('click', ()=>{ console.log('picker click', name); });
            wrap.appendChild(b);
          });
          // Try to preload the first instrument
          setTimeout(()=>{ const first = wrap.querySelector('button'); if(first) first.click(); }, 600);
        })();
            // Load the header
            document.addEventListener('DOMContentLoaded', function () {
                fetch('header.html')
                    .then(response => response.text())
                    .then(data => {
                      document.getElementById('header-placeholder').innerHTML = data;
                      // After header content is inserted, compute its height and expose to CSS
                      const updateHeaderHeight = () => {
                        const hdr = document.querySelector('.header');
                        if(hdr){
                          const h = hdr.getBoundingClientRect().height || 0;
                          document.documentElement.style.setProperty('--header-height', Math.ceil(h) + 'px');
                          // Also reposition the instrument picker to avoid overlap with header/HUD
                          try{
                            const picker = document.getElementById('instrumentPicker');
                            if(picker){
                              const rect = hdr.getBoundingClientRect();
                              const top = Math.ceil(rect.bottom + 12); // 12px below header
                              picker.style.top = top + 'px';
                              picker.style.maxHeight = 'calc(100vh - ' + (top + 24) + 'px)';
                            }
                          }catch(e){ console.warn('picker reposition failed', e); }
                        }
                      };
                      // Initial set and on resize
                      updateHeaderHeight();
                      window.addEventListener('resize', updateHeaderHeight);
                      // also re-run after a short delay in case fonts/images changed layout
                      setTimeout(updateHeaderHeight, 250);
                    });
            });




        </script>
  <script>
    // Hook up UV map control buttons (calls functions exposed by music-piano-debug.js)
    (function(){
      const toggle = document.getElementById('uvToggleBtn');
      const ubtn = document.getElementById('uvUBtn');
      const vbtn = document.getElementById('uvVBtn');
      const checkerBtn = document.getElementById('uvCheckerBtn');
      const updateLabel = ()=>{
        const mode = (window.backboardUVMapMode || 'none');
        if(toggle) toggle.textContent = 'UV: ' + (mode === 'none' ? 'Off' : mode.toUpperCase());
      };
      if(toggle){ toggle.addEventListener('click', ()=>{ try{ window.toggleBackboardUVMap(); }catch(e){}; setTimeout(updateLabel, 120); }); }
      if(ubtn){ ubtn.addEventListener('click', ()=>{ try{ window.setBackboardUVMapMode('u'); }catch(e){}; setTimeout(updateLabel, 120); }); }
      if(vbtn){ vbtn.addEventListener('click', ()=>{ try{ window.setBackboardUVMapMode('v'); }catch(e){}; setTimeout(updateLabel, 120); }); }
      if(checkerBtn){ checkerBtn.addEventListener('click', ()=>{ try{ window.setBackboardUVMapMode('checker'); }catch(e){}; setTimeout(updateLabel, 120); }); }
      // reflect initial state after a brief delay to allow module to initialize
      setTimeout(updateLabel, 300);
    })();
  </script>
</body>

</html>


===== END FILE: music.html =====


===== START FILE: music.html =====

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="template.css">
    <link rel="stylesheet" href="music.css">
  <script src="music.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.0/gsap.min.js" defer></script>
  <!-- three.js + loaders for GLB -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
      }
    }
  </script>
  <!-- Demo-only: no MIDI for now; load our viewer module -->
  <!-- Swap to isolated debug script to diagnose invisibility -->
  <script type="module" src="global-sync.js"></script>
  <!-- SoundFont player for sampled instruments: try multiple CDNs if one fails -->
  <script>
    (function tryLoadSoundfont(){
      const urls = [
        'https://cdn.jsdelivr.net/npm/soundfont-player@0.15.0/dist/soundfont-player.js',
        'https://unpkg.com/soundfont-player@0.15.0/dist/soundfont-player.js',
        'https://ga.jspm.io/npm:soundfont-player@0.15.0/dist/soundfont-player.js',
        'https://cdn.skypack.dev/soundfont-player@0.15.0',
        'https://esm.sh/soundfont-player@0.15.0',
        '/assets/vendor/soundfont-player.js' // local fallback - place file here if CDNs are blocked
      ];
      window.SOUNDFONT_LOADED = null;
      let i = 0;
      function tryOne(){
        if(i >= urls.length){ window.SOUNDFONT_LOADED = false; console.error('soundfont-player: all CDN attempts failed'); return; }
        const src = urls[i++];
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = function(){ window.SOUNDFONT_LOADED = true; console.log('soundfont-player loaded from', src); };
        s.onerror = function(){ console.warn('soundfont-player failed to load from', src); // try next
          // remove element and try next
          s.remove(); setTimeout(tryOne, 100);
        };
        document.head.appendChild(s);
      }
      tryOne();
    })();
  </script>
  <script type="module" src="music-piano-debug.js"></script>

    <!--<img src="assets/svg/Note1.svg" id="Note1" class="note">
    <img src="assets/svg/Note2.svg" id="Note2" class="note">
    <img src="assets/svg/Note3.svg" id="Note3" class="note">
    <img src="assets/svg/Note4.svg" id="Note4" class="note">
    <img src="assets/svg/Note5.svg" id="Note5" class="note">
    <img src="assets/svg/Note6.svg" id="Note6" class="note">
    <img src="assets/svg/Note7.svg" id="Note7" class="note">
    <img src="assets/svg/Note8.svg" id="Note8" class="note">
    <img src="assets/svg/Note9.svg" id="Note9" class="note">-->
</head>

<body>
    <div class="header" id="patterned-background">
        <div class="background-shape" id="patterned-background-shape">
            <div class="head-pic-container">
                <?xml version="1.0" encoding="UTF-8"?>
                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100">
                  <defs>
                    <clipPath id="clippath" clipPathUnits="userSpaceOnUse">
                      <!-- Align clip circle with head-inner for symmetric clipping -->
                      <circle cx="45.7" cy="35.5" r="23.1" style="fill: none;"/>
                    </clipPath>
                    <radialGradient id="radial-gradient" cx="45.7" cy="-6221.6" fx="45.7" fy="-6221.6" r="23.1" gradientTransform="translate(0 -6186.1) scale(1 -1)" gradientUnits="userSpaceOnUse">
                      <stop offset=".7" stop-color="#ccc" stop-opacity="0"/>
                      <stop offset="1" stop-color="#53272d"/>
                    </radialGradient>
                  </defs>
                  <g style="isolation: isolate;">
                    <g id="Layer_1">
                      <path class="head-bg"id="head-bg" d="M2.2,59.86C-3.29,33.02,14.1,7.49,40.14,2.2c19.02-3.86,38.95,3.76,50.34,20.54,17.19,25.42,6.81,60.3-21.56,72.2-28.47,12.1-60.81-5.29-66.81-35.19h0l.1.1Z" style="fill: var(panel-color);"/>
                      <path class="head-fill" id="head-fill" d="M50,0C22.4,0,0,22.4,0,50s22.4,50,50,50,50-22.4,50-50S77.6,0,50,0ZM76.8,89.8c-6.9,4.7-14.5,7.2-22.1,8-.1.01-.2.01-.31.02-.86-1.4-1.89-2.35-3.27-3.27-.24-.58-.74-1.3-.92-2.11-.3-1.7,1.4-2.1,2.5-4.9,0-.3.3-.9.4-1.1l.4-.5c0-.2.2-.2.3-.2.2,0,.5-.5.8-1,.3-.5.5-1.1.5-1.6.2-1.7,0-2.4.2-3.9.4-2.7,2.6-5.3,5-6.5h.6c.8.3,1.7.6,2.5.9,1.1.4,2.2.7,3.4.7,2.7,0,5.7-2.4,6.1-5.9v-1.5c0-.9-.6-1.6.2-2.4.8-.8.8,0,1.2-.4.4-.4.3-1,.3-1.6v-.4c0-.2-.2-.5-.4-.7,3.2-1.5.5-3.6.5-4.1,0,0,.3-.5.3-1,1.5,0,3.3-.8,4.1-2,.2-.3.4-.6.4-.9.3-1.6-.4-2.3-2.7-4.5,0,0-2.4-2.2-3.6-4.3-.5-.9-.7-1.6-.7-2.6v-1c.3-.9,1-1.5,1-2.4s-1.2-5.8-1.2-6.6c-.2-.9-.4-1.7-.5-2.1-.2-.6-.6-1.4-1.1-2.1.8.2,2,.5,2.6,1,.8.6,1.3,1.4,1.6,2.3.4,1.1.5,2.3.5,3.2s0,.2.2.2.3,0,.3-.2c0,0,.4-1.4.2-3.4,0-2.1-.8-3.7-1.6-4.8,1.8-.3,3.4-1.3,4.5-2.6,1.1-1.4,1.5-4,1.3-4.8-.3-.9-1-1.9-1.9-2.3-.5-3.3-3.2-6.6-7.3-7.7-8.1-2-12,3.3-18,1.8s-22.3-1.4-28.2,7c-.9,1.3-1.6,3-1,4.4-1.2.8-2.2,1.9-2.9,3.1-5.1,8.2-3.4,18.9.9,27.5,1.5,2.9,2.9,4.3,2.5,7.9-.2,2.2-1.2,4.6,1.6,5.6.6.2,1.5.5,1.7.5h1.2c0,2.6.8,6.4-1.6,10.6-1.4,2.3-3.6,4.5-4.2,6.1h-.3c-1.7.28-3.58,1.19-5.22,2.22-.06-.06-.12-.11-.18-.16-4.9-4.5-8.9-10.1-11.7-16.6C-6.1,40.6,10.9,9,40.3,3c3.2-.6,6.4-1,9.7-1,13.1,0,25.2,5.3,33.9,14.1,21.4,21.4,17.9,56.8-7.1,73.7Z" style="fill: var(--primary-color);"/>
                      <circle class="head-inner" id="head-inner" cx="45.7" cy="35.5" r="23.1" style="fill: var(--secondary-color); isolation: isolate;"/>
                      <g id="Notes">
                        <g style="clip-path: url(#clippath);">
                          <path class="note" id="Note9" d="M47.81,74c-.59-1.61-2.01-2.41-6.05-5.27-.01-.83-1-.71-.99-.09l.15,14.84c-2.12-1.27-5.55.21-5.24,2.29.18,1.25,1.73,2.06,3.45,1.81,1.72-.25,2.98-1.46,2.8-2.71l-.11-10.97c2.99-.06,4.64,1.36,3.99,5.93.73-.8,1.42-1.66,1.83-2.66.42-1,.55-2.15.18-3.17Z"/>
                          <path class="note" id="Note8" d="M49.26,83.12l-.02-14.43c0-.38-.38-.64-.73-.52-9.91,3.56-9.63,3.3-9.8,3.9-.06.13-.03.02-.01,12.2-1.71-1.05-4.5.13-4.27,1.82.14,1.01,1.39,1.68,2.79,1.49,1.4-.19,2.43-1.17,2.29-2.18v-8.43s8.95-3.22,8.95-3.22v8.22c-1.7-1.05-4.49.13-4.26,1.82.14,1.01,1.39,1.68,2.79,1.49,1.4-.19,2.43-1.17,2.29-2.18ZM39.49,75.82v-1.59s8.96-3.22,8.96-3.22v1.59s-8.96,3.22-8.96,3.22Z"/>
                          <path class="note" id="Note7" d="M41.78,75.04c-2.09.05-3.77,1.36-3.73,2.93s1.76,2.81,3.85,2.76,3.77-1.36,3.73-2.93-1.76-2.81-3.86-2.76ZM41.9,80.24c-1.05.02-1.92-1.01-1.95-2.31-.03-1.3.8-2.37,1.85-2.39,1.05-.02,1.92,1.01,1.95,2.31.03,1.3-.8,2.37-1.85,2.39Z" style="fill: #3ca2a6;"/>
                          <g class="note" id="Note6">
                            <path d="M37.73,68.35s-.05,0-.03,0c-2.92.85-4.15,3.36-4.13,4.43.03,1.1.93,1.96,2.03,1.94,1.1-.03,1.96-.93,1.94-2.03-.03-1.13-.99-2-2.09-1.94,3.63-1.99,8.09.11,8.06,5.75,0,.36-.04.84-.02.64-.48,4.9-2.7,7.84-6.1,10.49,5.52-1.2,9.47-6.94,8.78-12.73-.72-5.21-4.99-7.53-8.45-6.55Z"/>
                            <path d="M50.03,75.66c-.04-1.61-2.47-1.56-2.44.06s2.47,1.56,2.44-.06Z"/>
                            <path d="M47.68,79.59c.04,1.61,2.47,1.56,2.44-.06-.04-1.61-2.47-1.56-2.44.06Z"/>
                          </g>
                          <path class="note" id="Note5" d="M43.37,75.8c-.14-1.44-.25-2.91-.29-4.4.99-.93,2.94-2.88,3.75-4.01,1.96-2.12,1.88-7.72-.97-8.19.02,0-.1-.01-.1-.01-3.55-.2-4.36,8.58-4.33,12.25-3.51,2.56-7.15,5.3-6.57,9.88.63,3.6,4.5,6.03,8.04,5.77.12,2.41.29,6.66-1.36,8.02-1.66,1.37-3.97.39-3.79-1.67,0,.02,0,0,0,0,.16-.76.61-1.11.83-1.26-.42.71.08,1.61.91,1.61,1.18,0,1.48-1.65.38-2.06h0c-2.52-.58-3.9,3.06-1.13,4.55,0,0,.04.02.03.02,1.17.5,2.35.32,3.38-.43-.08.07,2.33-.75,2.16-9.04,7.08-2.08,5.23-11.78-.96-11.03ZM45.56,60.5c1.6.04,3.36,4.96-2.49,9.7,0-2.35.57-8.8,2.49-9.7ZM41.48,72.92c.05,1.2.15,2.3.25,3.36-3.26,1.55-3.38,5.86-.7,7.89l.1-.12c-3.13-3.15.03-6.55-.54-5.78.28-.31.6-.67,1.25-.99.29,2.6.75,5.58.98,8.46-.72.08-8.49-6.65-1.34-12.82ZM47.42,82.15c-.54,1.58-1.67,2.65-3.14,3.23-.14-2.92-.44-5.1-.8-8.53,1.61-.1,2.6.75,2.5.68.93.74,1.42,1.66,1.57,2.76.1.73-.2,1.99-.13,1.86Z"/>
                          <path class="note" id="Note4" d="M49.2,83.71l.87-14.97c.02-.39-.35-.69-.73-.58-10.59,3.1-10.4,2.82-10.45,3.69l-.72,12.41c-1.71-1.19-4.68-.14-4.54,1.63.08,1.06,1.33,1.83,2.8,1.72,1.47-.11,2.59-1.06,2.51-2.12l.67-11.6,9.49-2.78-.66,11.38c-1.71-1.19-4.68-.14-4.54,1.63.08,1.06,1.33,1.83,2.8,1.72,1.46-.11,2.59-1.06,2.51-2.12Z"/>
                          <path class="note" id="Note3" d="M44.97,84.86l-.16-16.23c0-.65-.99-.64-.99,0l.15,14.84c-2.12-1.28-5.54.21-5.24,2.29.18,1.25,1.73,2.06,3.45,1.81,1.73-.25,2.98-1.46,2.8-2.71Z"/>
                          <path class="note" id="Note2" d="M40.06,79.92l.03-10.21c0-.66-1-.67-1,0-.06,16.86-.32,16.84.44,16.85.28,0,.5-.22.5-.5v-.21c1.51-.43,2.87-1.37,3.8-2.63,2.83-3.84-2.23-6.32-3.78-3.29ZM40.04,85.06l.02-4.58c.72-.73,1.89-1.26,2.59-.52.66.7,1.52,3.24-2.6,5.1Z"/>
                          <path class="note" id="Note1" d="M44.99,84.87l-.16-16.23c0-.66-1-.64-.99,0l.15,14.84c-2.41-1.44-5.91.67-5.22,2.41.43,1.25,2.08,1.89,3.43,1.69,1.73-.25,2.98-1.46,2.8-2.71ZM41.94,87.21c-.88.04-1.63-.81-1.68-1.9-.05-1.09.62-2,1.5-2.05.88-.04,1.63.81,1.68,1.9.05,1.09-.62,2.01-1.5,2.05Z"/>
                        </g>
                      </g>
                      <circle id="gradient-circle" cx="45.7" cy="35.5" r="23.1" style="fill: url(#radial-gradient); isolation: isolate; mix-blend-mode: multiply;"/>
                    </g>
                  </g>
                </svg>

            </div>
        </div>

        <div class="title">
            <h1>Matt Hall</h1>
            <h2>Composer</h2>
        </div>

    <div id="header-placeholder"></div> <!-- Placeholder for header -->
  </div>

  <!-- Controls moved into separate fixed overlay (see bottom of file) -->

  
    <section aria-label="3D Toy Piano" class="piano-stage">
        <div class="piano-canvas-wrap">
        <canvas id="pianoCanvas" aria-label="3D toy piano"></canvas>
        <button id="playPerformance" class="piano-play">Play / Pause</button>
      </div>
      <div class="piano-notes" aria-live="polite" aria-atomic="true"></div>
    </section>
  
    <!-- Fixed overlay for music UI: controls + play button -->
    <div class="music-ui-overlay" aria-hidden="false">
      <div class="piano-controls">
        <div class="track-select">
          <button id="trackBaby" data-track="baby" title="Play Baby track">Baby</button>
          <button id="trackRaisins" data-track="raisins" title="Play Raisins track">Raisins</button>
        </div>
        <div class="track-select" style="margin-left:8px;">
          <button id="trackForests" data-track="forests" title="Play Forests track">Forests</button>
        </div>
        <button id="restartPlayback" title="Restart from beginning">Restart</button>
        <label for="playbackRate" style="display:flex; align-items:center; gap:6px; color:#e8fff4; font:12px monospace; margin-left:8px;">
          Speed
          <select id="playbackRate" aria-label="Playback speed">
            <option value="0.75">0.75×</option>
            <option value="0.85">0.85×</option>
            <option value="1" selected>1×</option>
            <option value="1.2">1.2×</option>
            <option value="1.6">1.6×</option>
            <option value="2">2×</option>
          </select>
        </label>
        <!-- UV map controls: toggle/cycle or set directly to U/V -->
        <div class="uv-map-controls" style="display:inline-flex; gap:6px; margin-left:12px; align-items:center;">
          <button id="uvToggleBtn" title="Toggle UV map (none → U → V)">UV: Off</button>
          <button id="uvUBtn" title="Show U color map">UV U</button>
          <button id="uvVBtn" title="Show V color map">UV V</button>
          <button id="uvCheckerBtn" title="Show checkerboard UV map">UV Checker</button>
        </div>
      </div>
      <div class="sync-offset-wrap">
        <label for="syncOffset" class="sync-label">Audio Sync Offset:
          <input id="syncOffset" type="range" min="-3000" max="3000" step="10" value="0" aria-label="Audio sync offset slider (-3000ms to +3000ms)">
          <span id="syncOffsetValue" class="sync-value">0 ms</span>
        </label>
        <small class="sync-hint">(-3s leads MIDI → +3s lags)</small>
      </div>
      <button id="playPerformance" class="piano-play">Play / Pause</button>
    </div>
    <!-- Left-side backend picker (choose library) -->
    <div class="instrument-backend-picker" id="instrumentBackendPicker" aria-hidden="false" role="toolbar" aria-label="Instrument backend picker"></div>
    <!-- Left-side instrument picker -->
    <div class="instrument-picker" id="instrumentPicker" aria-hidden="false" role="toolbar" aria-label="Instrument picker"></div>

    <script>
      // Build backend picker UI and expose preference on window.PREFERRED_INSTRUMENT_BACKEND
      (function(){
        const backends = [
          ['auto','Auto (SoundFont → WebAudioFont)'],
          ['soundfont','soundfont-player'],
          ['webaudiofont','WebAudioFont (CDN)'],
          ['webaudiofont-local','WebAudioFont (local)']
        ];
        const wrap = document.getElementById('instrumentBackendPicker');
        if(!wrap) return;
        const status = document.createElement('div');
        status.style.cssText = 'color:#cfe8d8;font:12px/1.2 "Source Sans 3", system-ui; margin-bottom:6px;';
        status.textContent = 'backend: auto';
        wrap.appendChild(status);
        backends.forEach(([key,label])=>{
          const b = document.createElement('button');
          b.textContent = label;
          b.dataset.backend = key;
          b.addEventListener('click', ()=>{
            window.PREFERRED_INSTRUMENT_BACKEND = key;
            document.querySelectorAll('#instrumentBackendPicker button').forEach(x=>x.classList.remove('active'));
            b.classList.add('active');
            status.textContent = 'backend: ' + label;
            console.log('Instrument backend set to', key);
          });
          wrap.appendChild(b);
        });
        // default to auto
        setTimeout(()=>{ const btn = wrap.querySelector('button[data-backend="auto"]'); if(btn) btn.click(); }, 60);
      })();
    </script>
  

  <script>
        // Build instrument picker buttons and hook to sampler
        (function(){
          const list = [
            ['acoustic_grand_piano','Acoustic Piano'],
            ['bright_acoustic_piano','Bright Piano'],
            ['electric_piano_1','Electric Piano 1'],
            ['electric_piano_2','Electric Piano 2'],
            ['honkytonk','Honky-Tonk'],
            ['harpsichord','Harpsichord'],
            ['vibraphone','Vibraphone'],
            ['church_organ','Organ'],
            ['accordion','Accordion'],
            ['string_ensemble_1','Strings'],
            ['pad_1','Pad'],
            ['choir_aahs','Choir']
          ];
          const wrap = document.getElementById('instrumentPicker');
          if(!wrap) return;
          const status = document.createElement('div');
          status.style.cssText = 'color:#cfe8d8;font:12px/1.2 "Source Sans 3", system-ui; margin-bottom:6px;';
          status.textContent = 'No instrument loaded';
          wrap.appendChild(status);
          // Reflect soundfont loader state in the status text while attempting CDN loads
          if(window.SOUNDFONT_LOADED === null){ status.textContent = 'Loading soundfont-player...'; }
          if(window.SOUNDFONT_LOADED === false){ status.textContent = 'Soundfont script failed to load (check console)'; }
          const sfCheck = setInterval(()=>{
            if(window.SOUNDFONT_LOADED === true){
              status.textContent = 'No instrument loaded';
              clearInterval(sfCheck);
            } else if(window.SOUNDFONT_LOADED === false){
              status.textContent = 'Soundfont script failed to load (check console)';
              clearInterval(sfCheck);
            } else {
              status.textContent = 'Loading soundfont-player...';
            }
          }, 250);
          list.forEach(([name,label])=>{
            const b = document.createElement('button');
            b.textContent = label;
            b.dataset.instrument = name;
            b.addEventListener('click', async (ev)=>{
              const btn = ev.currentTarget;
              btn.disabled = true; btn.classList.add('loading');
              try{
                const inst = await window.loadInstrument(name);
                if(inst){
                  document.querySelectorAll('.instrument-picker button').forEach(x=>x.classList.remove('active'));
                  btn.classList.add('active');
                  status.textContent = 'Loaded: ' + label;
                } else {
                  status.textContent = 'Load failed';
                }
              }catch(e){ alert('Failed to load instrument: '+name); }
              btn.disabled = false; btn.classList.remove('loading');
            });
            // extra debug: log pointer events so we can see clicks in the console
            b.addEventListener('pointerenter', ()=>{ console.log('picker hover', name); });
            b.addEventListener('pointerdown', ()=>{ console.log('picker down', name); });
            b.addEventListener('click', ()=>{ console.log('picker click', name); });
            wrap.appendChild(b);
          });
          // Try to preload the first instrument
          setTimeout(()=>{ const first = wrap.querySelector('button'); if(first) first.click(); }, 600);
        })();
            // Load the header
            document.addEventListener('DOMContentLoaded', function () {
                fetch('header.html')
                    .then(response => response.text())
                    .then(data => {
                      document.getElementById('header-placeholder').innerHTML = data;
                      // After header content is inserted, compute its height and expose to CSS
                      const updateHeaderHeight = () => {
                        const hdr = document.querySelector('.header');
                        if(hdr){
                          const h = hdr.getBoundingClientRect().height || 0;
                          document.documentElement.style.setProperty('--header-height', Math.ceil(h) + 'px');
                          // Also reposition the instrument picker to avoid overlap with header/HUD
                          try{
                            const picker = document.getElementById('instrumentPicker');
                            if(picker){
                              const rect = hdr.getBoundingClientRect();
                              const top = Math.ceil(rect.bottom + 12); // 12px below header
                              picker.style.top = top + 'px';
                              picker.style.maxHeight = 'calc(100vh - ' + (top + 24) + 'px)';
                            }
                          }catch(e){ console.warn('picker reposition failed', e); }
                        }
                      };
                      // Initial set and on resize
                      updateHeaderHeight();
                      window.addEventListener('resize', updateHeaderHeight);
                      // also re-run after a short delay in case fonts/images changed layout
                      setTimeout(updateHeaderHeight, 250);
                    });
            });




        </script>
  <script>
    // Hook up UV map control buttons (calls functions exposed by music-piano-debug.js)
    (function(){
      const toggle = document.getElementById('uvToggleBtn');
      const ubtn = document.getElementById('uvUBtn');
      const vbtn = document.getElementById('uvVBtn');
      const checkerBtn = document.getElementById('uvCheckerBtn');
      const updateLabel = ()=>{
        const mode = (window.backboardUVMapMode || 'none');
        if(toggle) toggle.textContent = 'UV: ' + (mode === 'none' ? 'Off' : mode.toUpperCase());
      };
      if(toggle){ toggle.addEventListener('click', ()=>{ try{ window.toggleBackboardUVMap(); }catch(e){}; setTimeout(updateLabel, 120); }); }
      if(ubtn){ ubtn.addEventListener('click', ()=>{ try{ window.setBackboardUVMapMode('u'); }catch(e){}; setTimeout(updateLabel, 120); }); }
      if(vbtn){ vbtn.addEventListener('click', ()=>{ try{ window.setBackboardUVMapMode('v'); }catch(e){}; setTimeout(updateLabel, 120); }); }
      if(checkerBtn){ checkerBtn.addEventListener('click', ()=>{ try{ window.setBackboardUVMapMode('checker'); }catch(e){}; setTimeout(updateLabel, 120); }); }
      // reflect initial state after a brief delay to allow module to initialize
      setTimeout(updateLabel, 300);
    })();
  </script>
</body>

</html>


===== END FILE: music.html =====


===== START FILE: music.css =====

/* Body Styling */
body {
    --dark-color: var(--green-dark);
    --primary-color: var(--green-primary);
    --secondary-color: var(--green-secondary);
    --tertiary-color: var(--green-tertiary);
    --text-color: var(--green-text-color);
    --grey-color: var(--green-grey);
    --hl-primary-color: var(--red-primary);
    --hl-secondary-color: var(--red-secondary);
    --hl-tertiary-color: var(--red-tertiary);
    --hl-dark-color: var(--red-dark);
    --hl-text-color: var(--red-text-color);     
    background-image: url("assets/overlays/overlay-music-dark.png");
    background-repeat: repeat;    
    overflow-y: hidden;
}

/* Page background overlay (music page only; base pattern comes from template.css) */
.content {
    inline-size: 100vw;

    /* Start just below the fixed header */
    margin: calc(10rem + 1.5rem) 0 0;

    /* Take up the remaining viewport height */
    min-height: calc(100vh - (10rem + 1.5rem));

    padding: 0;

    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;

    background: none;
    box-shadow: none;
}



/* Keyframes for horizontal movement */
@keyframes moveRight {
    0% {
    transform: translateX(var(--xPos, 0px)) translateY(calc(var(--baseY) + var(--yOffset, 0px) + 0px)) scale(var(--scale-factor)) rotate(0deg);
    }
    25% {
    transform: translateX(var(--xPos, 0px)) translateY(calc(var(--baseY) + var(--yOffset, 0px) - 6px)) scale(var(--scale-factor)) rotate(var(--wiggle-angle));
    }
    50% {
    transform: translateX(var(--xPos, 0px)) translateY(calc(var(--baseY) + var(--yOffset, 0px) + 0px)) scale(var(--scale-factor)) rotate(calc(var(--wiggle-angle) * -1));
    }
    75% {
    transform: translateX(var(--xPos, 0px)) translateY(calc(var(--baseY) + var(--yOffset, 0px) + 6px)) scale(var(--scale-factor)) rotate(var(--wiggle-angle));
    }
    100% {
    transform: translateX(var(--xPos, 0px)) translateY(calc(var(--baseY) + var(--yOffset, 0px) + 0px)) scale(var(--scale-factor)) rotate(0deg);
    }
}

:root {
    --note-offset: 1s; /* Delay between note starts */
    --scale-factor: 1.1; /* Base scale factor (overridden per note) */
    --startX: -90px; /* Start further left */
    --stopX: 90px;  /* End further right */
    --wiggle-angle: 6deg; /* Wiggle amount */
    --baseY: -46px; /* Lift notes into the middle of the circle */
}

/* Horizontal animation already defined above as moveRight */

/* Class for notes */
.note {
    animation-name: moveRight;
    animation-timing-function: cubic-bezier(0.6, 0.2, 0.1, 1);
    animation-iteration-count: infinite;
    animation-fill-mode: forwards;
    animation-duration: 9.5s; /* default, overridden below */
    transform-origin: center center;
    transform-box: fill-box; /* Ensure SVG transforms behave predictably */
    opacity: 1;
    fill: var(--tertiary-color);
}

@media (prefers-reduced-motion: reduce) {
    .note {
        animation: none !important;
        opacity: 1;
    }
}

#clippath {
    fill: var(--green-secondary);
}

/* 3D piano preview area */
.piano-stage {
    max-width: 100;
    padding: 0;
}
.piano-canvas-wrap {
     /* Pin the canvas to the viewport below the fixed header so
         UI panels won't push the 3D canvas out of view.  The top offset
         uses a CSS variable set from JS to match the actual header height. */
    position: fixed;
    /* Align directly under the header's measured height to avoid clipping */
    top: var(--header-height, 10rem);
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: auto;
    overflow: hidden;
    z-index: 50; /* below overlay UI */
    display: block;
}
#pianoCanvas {
    width: 100%;
    height: 100%;
    display: block;
    z-index: 10;
    background: transparent;
}
.piano-play {
    position: absolute;
    top: 50%;
    right: 24px; /* Move button to right side of the content window */
    transform: translateY(-50%); /* Vertically center only */
    background: linear-gradient(180deg,var(--purple-secondary),var(--purple-primary));
    filter: brightness(1.5);
    color: #fff;
    border: none;
    padding: 0.8rem 1.2rem;
    border-radius: 999px;
    font: 600 18px/.5 "Source Sans 3", system-ui, -apple-system, Segoe UI, Roboto, Arial;
    letter-spacing: .02rem;
    box-shadow: 0 8px 18px rgba(126, 63, 224, 0.45);
    cursor: pointer;
}
.piano-play:hover { filter: brightness(2); }
.piano-play:active { transform: translateY(-50%) scale(0.98); }
.sync-offset-wrap {
    position:absolute;
    right:24px;
    top:calc(50% + 70px);
    width:220px;
    background:rgba(30,30,34,0.7);
    backdrop-filter: blur(4px);
    padding:10px 14px 12px;
    border-radius:12px;
    box-shadow:0 4px 12px rgba(0,0,0,0.35);
    font:500 12px/1.3 "Source Sans 3", system-ui;
    color:#cfd5e8;
}
/* New container for moved panels below header */
.music-info-panels {
    /* kept for legacy, not used when overlay is enabled */
    display:none;
}
.music-info-panels .piano-controls {
    display:flex;
    gap:8px;
    align-items:center;
    background:rgba(0,0,0,0.4);
    padding:6px 8px;
    border-radius:6px;
}
.music-info-panels .sync-offset-wrap { position:static; width:auto; }
/* Ensure panels sit above header and can overlap slightly to align with play button */
.music-ui-overlay {
    position:fixed;
    top: calc(10rem + 0.75rem);
    right: 16px;
    z-index: 1200;
    display:flex;
    gap:12px;
    align-items:center;
}
.instrument-picker {
    position: fixed;
    left: 0.75rem;
    /* push further down so it doesn't overlap the head graphic */
    top: calc(var(--header-height, 10rem) + 6rem);
    z-index: 1300; /* above .music-ui-overlay */
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 0.25rem;
    max-height: calc(100vh - (var(--header-height, 10rem) + 7rem));
    overflow: auto;
    pointer-events: auto;
    transition: transform 0.12s ease, box-shadow .12s ease;
    box-shadow: 0 6px 20px rgba(0,0,0,0.45);
    border-radius: 8px;
    backdrop-filter: blur(6px);
}

.instrument-picker--backboard {
    left: 0;
    top: 0;
    max-height: none;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 0.4rem;
    padding: 0.5rem 0.75rem;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(4px);
    border-radius: 10px;
    display: none; /* hidden in DOM; rendered on backboard */
}
.instrument-picker button {
    background: rgba(255,255,255,0.06);
    color: var(--fg, #fff);
    border: 1px solid rgba(255,255,255,0.06);
    padding: 0.4rem 0.6rem;
    font-size: 0.85rem;
    cursor: pointer;
    border-radius: 4px;
}
.instrument-picker button:hover{
    transform: translateY(-2px);
    filter: brightness(1.25);
}
.instrument-picker button:active{
    transform: translateY(0) scale(.98);
}
.instrument-picker button.active {
    background: #ff8c00; /* orange */
    color: #000;
    box-shadow: 0 4px 10px rgba(0,0,0,0.45);
}
.instrument-picker button.loading { opacity: 0.6; }
.music-ui-overlay .piano-controls {
    display:flex;
    gap:8px;
    align-items:center;
    background:rgba(0,0,0,0.4);
    padding:6px 8px;
    border-radius:6px;
}
.music-ui-overlay .sync-offset-wrap { width:220px; }
.music-ui-overlay .piano-play { position:relative; z-index:1300; }
.sync-label { display:flex; flex-direction:column; gap:4px; font-weight:600; font-size:12px; }
#syncOffset { width:100%; accent-color:#7b3fe0; }
.sync-value { font-weight:600; font-size:12px; color:#fff; }
.sync-hint { display:block; margin-top:6px; font-size:11px; opacity:0.6; }
@media (max-width: 800px){
    .sync-offset-wrap { position:static; margin:8px auto 0; top:auto; right:auto; transform:none; }
    .piano-play { right:50%; transform:translate(50%, -50%); }
}
.piano-notes { margin-top: 0.5rem; color: #c9c9d4; font: 500 12px/1.4 "Source Sans 3", system-ui; text-align: center; }

===== END FILE: music.css =====


===== START FILE: music-piano-debug.js =====

// === RESET-DEBUG: detect reload vs navigation vs HMR ===
(() => {
  const tag = (msg, extra={}) => console.log('[RESET-DEBUG] ' + msg, extra);
  try{
    window.addEventListener('beforeunload', () => tag('beforeunload (page is unloading)', {url: location.href}));
    window.addEventListener('unload', () => tag('unload', {url: location.href}));
    window.addEventListener('popstate', () => tag('popstate', {url: location.href}));
    window.addEventListener('hashchange', () => tag('hashchange', {url: location.href}));
    const _push = history.pushState.bind(history);
    const _replace = history.replaceState.bind(history);
    history.pushState = function(...args){ tag('history.pushState', {args, stack: (new Error()).stack}); return _push(...args); };
    history.replaceState = function(...args){ tag('history.replaceState', {args, stack: (new Error()).stack}); return _replace(...args); };
    window.addEventListener('error', (ev) => tag('window error', {message: ev.message, filename: ev.filename, lineno: ev.lineno, colno: ev.colno}));
    window.addEventListener('unhandledrejection', (ev) => tag('unhandledrejection', {reason: ev.reason}));
    const key = '__reset_debug_count__';
    const n = Number(sessionStorage.getItem(key) || 0) + 1;
    sessionStorage.setItem(key, String(n));
    tag('boot', {bootCountThisTab: n, url: location.href, navType: performance.getEntriesByType('navigation')?.[0]?.type});
  }catch(e){ console.warn('[RESET-DEBUG] instrumentation failed', e); }
})();

// music-piano-debug.js
// Fresh debug loader: isolates GLB visibility without previous logic
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { getSyncOffsetMs } from './global-sync.js';
// Tablet helper currently a no-op; import kept so future
// tablet code can be re-enabled without touching this file.
import { setupMusicTabletScreen } from './music-tablet.js';
window.addEventListener('DOMContentLoaded', ()=>{
  instrumentPickerEl = document.getElementById('instrumentPicker');
  if(instrumentPickerEl){
    instrumentPickerEl.classList.add('instrument-picker--backboard');
    instrumentPickerEl.style.display = 'none';
  }
  // Hide original DOM label and rely on backboard UI
  try{
    const status = instrumentPickerEl.querySelector('div');
    if(status) status.style.display = 'none';
  }catch(e){}
  // Backboard click debug panel
  backboardClickPanel = document.createElement('div');
  backboardClickPanel.style.cssText = 'position:fixed;left:10px;bottom:10px;padding:8px 10px;background:rgba(0,0,0,0.7);color:#d0ffe4;font:12px monospace;z-index:2000;pointer-events:none;border-radius:6px;white-space:pre;';
  backboardClickPanel.textContent = 'backboard: none';
  document.body.appendChild(backboardClickPanel);

  document.addEventListener('keydown', (e)=>{
    if(e.code === 'F10'){
      const dbg = document.getElementById('uiDebugCanvas');
      if(dbg){
        dbg.style.display = (dbg.style.display === 'none') ? 'block' : 'none';
      }
    }
  });
});
const canvas = document.getElementById('pianoCanvas');
if (!canvas) { console.error('Canvas #pianoCanvas not found'); }
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
try{ renderer.outputColorSpace = THREE.SRGBColorSpace; }catch(e){}
// Match videos page renderer defaults for tone/shadows
try{ renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0; }catch(e){}
try{ renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; }catch(e){}
try{ renderer.physicallyCorrectLights = true; }catch(e){}
const clock = new THREE.Clock();
const scene = new THREE.Scene();
// Lighting rig — mirror videos page for consistent look
const cam = new THREE.PerspectiveCamera(45, canvas.clientWidth/canvas.clientHeight, 0.001, 500);
// Initial camera; final framing is driven by fit()/intro tween after GLB load
cam.position.set(-2.32, 2.14, 10.58);
cam.lookAt(0,0,0);
// Hemisphere + key + fill + rim + under + subtle ambient (videos.js style)
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.85); scene.add(hemi);
const keyLight = new THREE.DirectionalLight(0xffffff, 1.25); keyLight.position.set(4,6,8); keyLight.castShadow = true;
try{ keyLight.shadow.mapSize.set(2048,2048); keyLight.shadow.camera.near = 0.5; keyLight.shadow.camera.far = 30; }catch(e){}
scene.add(keyLight);
const fillLight = new THREE.DirectionalLight(0xffffff, 0.55); fillLight.position.set(-6,3,-4); scene.add(fillLight);
const rimLight = new THREE.DirectionalLight(0xffffff, 0.7); rimLight.position.set(0,5,-8); scene.add(rimLight);
const underLight = new THREE.DirectionalLight(0xffffff, 0.35); underLight.position.set(0,-3,2); scene.add(underLight); scene.add(underLight.target);
const subtleAmbient = new THREE.AmbientLight(0xffffff, 0.15); scene.add(subtleAmbient);
const loader = new GLTFLoader();
const draco = new DRACOLoader(); draco.setDecoderPath('https://unpkg.com/three@0.159.0/examples/jsm/libs/draco/');
loader.setDRACOLoader(draco); loader.setMeshoptDecoder(MeshoptDecoder);
const HUD = document.createElement('div');
HUD.style.cssText='position:fixed;left:8px;top:calc(var(--header-height, 6rem) + 8px);padding:6px 10px;background:rgba(0,0,0,.6);color:#d0ffe4;font:12px monospace;z-index:100;border-radius:6px;white-space:pre;';
document.body.appendChild(HUD);
let root=null; let keyMeshes=[]; let stickerMeshes=[]; let userStickersGroup = null;
let qwertyLabelsGroup = null;
let selectedKey=null; // middle key chosen for demo animation
const demoAngleWhite = THREE.MathUtils.degToRad(4);
const demoAngleBlack = THREE.MathUtils.degToRad(5);
// Orbit controls
const controls = new OrbitControls(cam, renderer.domElement);
// User-specified mouse button mapping
controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enablePan = true;
controls.panSpeed = 0.6;
controls.minDistance = 0.5;
controls.maxDistance = 20; // allow further zooming out
controls.target.set(0,0.4,0);
// MIDI structures
let midiEvents = []; // {timeMs, type:'on'|'off', note, velocity}
let ticksPerQuarter = 480; // default, will read header
let tempoUsPerQuarter = 500000; // default 120 BPM (500000 microseconds per quarter note)
let tempoMap = [{tick:0, timeMs:0, tempo:tempoUsPerQuarter}]; // record tempo changes
let midiLoaded = false;
let midiIndex = 0; // current event index during playback
let playingMIDI = false;
let audioStartCtxTime = 0; // AudioContext.start base time
let midiStartCtxTime = 0;  // When MIDI timeline starts relative to audioCtx
let midiFirstNoteMs = 0;    // earliest note-on for zero alignment
let sentinelFilteredCount = 0; // count of filtered sentinel notes
let midiStretch = 1.0;      // stretch factor to match audio active duration
let midiActiveDurationMs = 0; // MIDI active span (first on -> last off) after filtering
const STRETCH_CLAMP = 0.20; // +/-20% max stretch to cover export mismatches
const midiKeyMap = new Map(); // noteNumber -> mesh
const pressState = new Map(); // mesh -> currentRotation
const WHITE_MAX = demoAngleWhite; // reuse deg limits
const BLACK_MAX = demoAngleBlack;
// Sign to apply for key press rotation: +1 means positive X rotates downward visually
// Adjusted after user feedback (keys were going up). If your model changes, flip to -1.
const KEY_PRESS_SIGN = 1;
// Sustain pedal (right) animation support
let sustainPedalMesh = null;
const PEDAL_MAX_ANGLE = THREE.MathUtils.degToRad(6);
const PEDAL_PRESS_MS = 85;
const PEDAL_RELEASE_MS = 140;
const sustainAnim = { phase:'idle', startMs:0, fromAngle:0, targetAngle:0 };
// Smooth animation & velocity scaling
// For predictive pedal bounce
let sustainEventTimes = []; // times (ms) of cc64 presses (value>=64) for lookahead
const PEDAL_BOUNCE_ANGLE = THREE.MathUtils.degToRad(0.9);
const PEDAL_LOOKAHEAD_MS = 160; // if next press within this after release start, force fast release
const PRESS_ATTACK_MS = 55;   // ramp press
const RELEASE_DECAY_MS = 110; // ramp release
const VELOCITY_MIN = 20;      // floor for depth scaling
const VELOCITY_MAX = 127;     // MIDI max
// NOTE fade / attack constants used for smoothing note start/stops
const NOTE_FADE_SEC = 0.03; // 0.02–0.06 recommended
const NOTE_ATTACK_SEC = 0.005; // quick attack to avoid clicks
const FADE_SEC = NOTE_FADE_SEC; // backward-compatible alias used elsewhere
// Per-note animation state: noteNumber -> { mesh, phase, startMs, fromAngle, targetAngle }
const keyAnimState = new Map();
// Audio context and sampler state
let audioCtx=null, audioBuffer=null, audioSource=null; let audioReady=false, audioPlaying=false; let audioError=false; let midiError=false;
let masterGain = null;
// Sampler (SoundFont) support
let instrumentPlayer = null; // Soundfont player instance for current instrument
let currentInstrumentName = null;
const activeSampleNodes = new Map(); // midiNum -> node returned by instrumentPlayer.play()
let audioTrimMs = 0; // detected leading silence trim
const TRIM_THRESHOLD = 0.0025; // RMS amplitude threshold
const TRIM_WINDOW_SAMPLES = 2048; // window size for scanning
const MAX_TRIM_MS = 20000; // safety cap (allow long tails up to 20s)
let audioActiveDurationMs = 0; // duration between first audible and last audible
let currentPlaybackRate = 1.0;
let savedAudioPosSec = 0; // persisted playhead when paused
// Animation frame lock configuration
const LOCK_FRAME = 140; // target frame to freeze at
const LOCK_FPS = 30;    // assumed export FPS (adjust if different)
let animationMixer = null;
let tabletStandMesh = null; // auto-rotated display stand
let tabletStandTargetAngle = 0; // computed each frame
let tabletStandCurrentAngle = 0; // smoothed applied angle
const TABLET_ROTATION_LERP_SPEED = 8.0; // larger = snappier, smaller = looser
// Backboard screen canvas (note display)
let backboardMesh = null;
let backboardCanvas = null;
let backboardCtx = null;
let backboardTexture = null;
// Backboard redraw throttle / dirty flag to avoid per-frame canvas uploads
let backboardDirty = true;
let lastBackboardDrawMs = 0;
const BACKBOARD_MAX_FPS = 20; // throttle canvas uploads to ~20 FPS
function requestBackboardRedraw(){ backboardDirty = true; }
// Surface aspect (world w/h) used to pre-compensate canvas drawing so
// circles/text look visually correct when mapped to the mesh UVs.
let backboardSurfaceAspect = 1;
let backboardUvDebugLogged = false;
// logical CSS-pixel drawing size for the backboard canvas (set once at creation)
let backboardCssW = 2048;
let backboardCssH = 512;
const BACKBOARD_BASE_HEIGHT = 512;
// Instrument picker overlay targeting the backboard
let instrumentPickerEl = null;
let lastInstrumentPickerRect = { x: 0, y: 0, w: 0, h: 0 };
let screenPlane = null;
let screenPlaneNormal = new THREE.Vector3(0,0,1);
let uvDebugMode = true; // draw UV test card
const INSTRUMENT_BUTTONS = [
  { id: 'acoustic_grand_piano', label: 'Acoustic Piano' },
  { id: 'bright_acoustic_piano', label: 'Bright Piano' },
  { id: 'electric_piano_1', label: 'Electric Piano 1' },
  { id: 'electric_piano_2', label: 'Electric Piano 2' },
  { id: 'honkytonk', label: 'Honky-Tonk' },
  { id: 'harpsichord', label: 'Harpsichord' },
  { id: 'vibraphone', label: 'Vibraphone' },
  { id: 'church_organ', label: 'Organ' },
  { id: 'accordion', label: 'Accordion' },
  { id: 'string_ensemble_1', label: 'Strings' },
  { id: 'pad_1', label: 'Pad' },
  { id: 'choir_aahs', label: 'Choir' }
];
const panelState = {
  left: { offset: 0, selected: INSTRUMENT_BUTTONS[0].id },
  right: { offset: Math.max(0, INSTRUMENT_BUTTONS.length - 6), selected: INSTRUMENT_BUTTONS[1].id }
};
let panelHitRects = [];
let panelHover = null;
let backboardClickPanel = null;
let backboardPointerDown = false;
// Backboard UV orientation correction (detect if UV island is rotated/flipped)
// backboardUVCorrection: per-axis correction detected at load time
// { swap:bool, mirrorU:bool, mirrorV:bool }
let backboardUVCorrection = { swap:false, mirrorU:false, mirrorV:false };
// Backboard world-space horizontal span (used to derive per-key lanes)
let backboardHorizAxis = 'x';
let backboardWorldSpan = { min:0, max:1, span:1 };
// Backboard UV bounds (uMin/uMax/vMin/vMax) used to crop the canvas texture to the
// mesh UV island so drawings are 1:1 and not stretched.
let backboardUVBounds = { uMin:0, uMax:1, vMin:0, vMax:1, uSpan:1, vSpan:1 };
let keyByNote = new Map();
let jsonKeymapLoaded = false;
let keymapULeft = 0;
let keymapURight = 1;
let RAYCAST_KEYMAP_READY = false;
const activeNotes = new Map(); // note -> { velocity, tOn }
const activeNoteSet = new Set(); // stores MIDI note numbers currently held down
const codeToMidiDown = new Map(); // ev.code -> latched midi number
const PERSISTENT_HIGHLIGHTS = [36]; // C2

// Debug lane guide toggle
const DEBUG_LANES = true;
let keyLanesAbs = new Map(); // note -> {u0,u1} derived from world positions

const BLACK_PCS = new Set([1,3,6,8,10]);
function isBlackNoteByNumber(n){ return BLACK_PCS.has(n % 12); }

function noteToGlowColor(note, velocity=1){
  const pc = note % 12; const hue = Math.round((pc/12)*360);
  const a = 0.35 + 0.45 * Math.min(1, velocity);
  return `hsla(${hue},90%,60%,${a})`;
}

// Draw a left->right UV gradient (red@0, green@0.5, blue@1) for debugging UV mapping
function drawUGradient(canvas){
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const grad = ctx.createLinearGradient(0,0,W,0);
  grad.addColorStop(0.0, '#ff0000');
  grad.addColorStop(0.5, '#00ff00');
  grad.addColorStop(1.0, '#0000ff');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);
}

// V mapping constants for backboard "island" (local v in [0,1] maps into this UV range)
const V_MIN = 0.442326;
const V_MAX = 0.557674;
const V_RANGE = V_MAX - V_MIN; // 0.115348

// Map backboard mesh to screen-space rect for DOM overlays (instrument picker)
function getBackboardScreenRect(){
  const target = screenPlane || backboardMesh;
  if(!target || !renderer || !cam) return null;
  const geom = target.geometry;
  if(!geom) return null;
  try{ if(!geom.boundingBox) geom.computeBoundingBox(); }catch(e){}
  const bb = geom.boundingBox;
  if(!bb) return null;
  const min = bb.min, max = bb.max;
  const corners = [
    new THREE.Vector3(min.x, min.y, min.z),
    new THREE.Vector3(min.x, min.y, max.z),
    new THREE.Vector3(min.x, max.y, min.z),
    new THREE.Vector3(min.x, max.y, max.z),
    new THREE.Vector3(max.x, min.y, min.z),
    new THREE.Vector3(max.x, min.y, max.z),
    new THREE.Vector3(max.x, max.y, min.z),
    new THREE.Vector3(max.x, max.y, max.z)
  ];
  const domRect = renderer.domElement.getBoundingClientRect();
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for(const c of corners){
    const v = c.clone();
    try{ v.applyMatrix4(target.matrixWorld); }catch(e){}
    try{ v.project(cam); }catch(e){}
    const x = (v.x * 0.5 + 0.5) * domRect.width + domRect.left;
    const y = (-v.y * 0.5 + 0.5) * domRect.height + domRect.top;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  }
  if(!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return null;
  return { x:minX, y:minY, w: Math.max(0, maxX-minX), h: Math.max(0, maxY-minY) };
}

function updateInstrumentPickerPosition(){
  if(!instrumentPickerEl) return;
  const rect = getBackboardScreenRect();
  if(!rect){
    instrumentPickerEl.style.opacity = '0';
    return;
  }
  instrumentPickerEl.style.opacity = '1';
  instrumentPickerEl.style.position = 'fixed';
  instrumentPickerEl.style.left = `${rect.x}px`;
  instrumentPickerEl.style.top = `${rect.y}px`;
  instrumentPickerEl.style.width = `${rect.w}px`;
  instrumentPickerEl.style.maxWidth = `${rect.w}px`;
  instrumentPickerEl.style.transform = 'translateY(0)';
  instrumentPickerEl.style.flexDirection = 'row';
  instrumentPickerEl.style.flexWrap = 'wrap';
  instrumentPickerEl.style.justifyContent = 'center';
  instrumentPickerEl.style.alignItems = 'center';
  // Avoid thrashing layout if unchanged
  const eps = 0.5;
  if(Math.abs(lastInstrumentPickerRect.x - rect.x) > eps ||
     Math.abs(lastInstrumentPickerRect.y - rect.y) > eps ||
     Math.abs(lastInstrumentPickerRect.w - rect.w) > eps ||
     Math.abs(lastInstrumentPickerRect.h - rect.h) > eps){
    lastInstrumentPickerRect = rect;
  }
}

// Convert a local v (0..1 within the backboard island) into canvas Y pixels
function vLocalToYPx(vLocal, H){
  const vAbs = V_MIN + (vLocal * V_RANGE); // absolute UV v
  return (1.0 - vAbs) * H;                   // convert UV v to canvas y (y=0 top)
}

// Convert an absolute UV v (0..1) into canvas Y pixels
function vAbsToYPx(vAbs, H){
  return (1.0 - vAbs) * H; // y = (1 - v) * H
}

// Simple UV test card
function drawUvTestCard(ctx, W, H){
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,W,H);
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  const steps = 10;
  for(let i=0;i<=steps;i++){
    const x = (i/steps)*W;
    const y = (i/steps)*H;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  ctx.fillStyle = '#0f0';
  ctx.font = `${Math.max(16, Math.round(H*0.05))}px monospace`;
  ctx.fillText('TOP', W*0.45, H*0.08);
  ctx.fillText('BOTTOM', W*0.38, H*0.95);
  ctx.fillText('(0,0)', 8, H-8);
  ctx.fillText('(1,1)', W-70, 20);
}

function createBackboardCanvas(aspect){
  if(backboardCanvas) return; // already created; do not resize
  const baseH = BACKBOARD_BASE_HEIGHT;
  const targetW = Math.round((baseH * aspect) / 64) * 64;
  backboardCssW = Math.max(64, targetW);
  backboardCssH = baseH;
  backboardCanvas = document.createElement('canvas');
  backboardCanvas.width = backboardCssW;
  backboardCanvas.height = backboardCssH;
  backboardCanvas.id = 'uiDebugCanvas';
  backboardCanvas.style.position = 'fixed';
  backboardCanvas.style.left = '10px';
  backboardCanvas.style.bottom = '10px';
  backboardCanvas.style.width = '900px';
  backboardCanvas.style.height = 'auto';
  backboardCanvas.style.zIndex = '1500';
  backboardCanvas.style.border = '2px solid magenta';
  backboardCanvas.style.pointerEvents = 'none';
  document.body.appendChild(backboardCanvas);

  backboardCtx = backboardCanvas.getContext('2d');
  backboardTexture = new THREE.CanvasTexture(backboardCanvas);
  try{ backboardTexture.colorSpace = THREE.SRGBColorSpace; }catch(e){ try{ backboardTexture.encoding = THREE.sRGBEncoding; }catch(e){} }
  try{ backboardTexture.flipY = false; }catch(e){}
  backboardTexture.needsUpdate = true;

  // Aggressive debug draw
  const ctx = backboardCtx;
  ctx.fillStyle = '#ff00ff';
  ctx.fillRect(0,0,backboardCssW, backboardCssH);
  ctx.strokeStyle = '#0ff';
  ctx.lineWidth = 20;
  ctx.strokeRect(10,10, backboardCssW-20, backboardCssH-20);
  ctx.fillStyle = '#000';
  ctx.font = '72px Arial Black, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('TOP', backboardCssW/2, 90);
  ctx.fillText('BOTTOM', backboardCssW/2, backboardCssH - 60);
  backboardTexture.needsUpdate = true;
}

function uvToCanvasPx(uv){
  if(!backboardUVBounds || !backboardCanvas) return null;
  const uSpan = backboardUVBounds.uSpan || (backboardUVBounds.uMax - backboardUVBounds.uMin) || 1;
  const vSpan = backboardUVBounds.vSpan || (backboardUVBounds.vMax - backboardUVBounds.vMin) || 1;
  const uNorm = (uv.x - backboardUVBounds.uMin) / uSpan;
  const vNorm = (uv.y - backboardUVBounds.vMin) / vSpan;
  if(!isFinite(uNorm) || !isFinite(vNorm)) return null;
  const px = uNorm * backboardCssW;
  const py = (1 - vNorm) * backboardCssH;
  return { px, py };
}

function raycastBackboardForUv(clientX, clientY){
  if(!screenPlane) return null;
  const rect = canvas.getBoundingClientRect();
  const nx = ((clientX - rect.left)/rect.width)*2 - 1;
  const ny = -((clientY - rect.top)/rect.height)*2 + 1;
  pointer.set(nx, ny);
  raycaster.setFromCamera(pointer, cam);
  const hits = raycaster.intersectObject(screenPlane, true);
  if(!hits.length) return null;
  const h = hits[0];
  if(!h.uv) return null;
  return h.uv;
}

function setBackboardDebug(uv){
  if(!backboardClickPanel) return;
  if(!uv){
    backboardClickPanel.textContent = 'backboard: none';
    return;
  }
  const pt = uvToCanvasPx(uv);
  const px = pt ? pt.px.toFixed(1) : 'n/a';
  const py = pt ? pt.py.toFixed(1) : 'n/a';
  backboardClickPanel.textContent = `backboard hit\nu:${uv.x.toFixed(4)} v:${uv.y.toFixed(4)}\npx:${px} py:${py}`;
}

function hitTestPanelUI(uv){
  const pt = uvToCanvasPx(uv);
  if(!pt) return null;
  for(const hit of panelHitRects){
    const r = hit.rect;
    if(pt.px >= r.x && pt.px <= r.x + r.w && pt.py >= r.y && pt.py <= r.y + r.h){
      return hit;
    }
  }
  return null;
}

function updateInstrumentHover(clientX, clientY){
  const uv = raycastBackboardForUv(clientX, clientY);
  const hit = uv ? hitTestPanelUI(uv) : null;
  const nextHover = hit ? hit.id : null;
  if(nextHover !== panelHover){
    panelHover = nextHover;
    requestBackboardRedraw();
  }
}

async function triggerInstrumentButton(id){
  // keep selection per panel; caller sets desired panel before calling
  requestBackboardRedraw();
  try{
    await loadInstrument(id);
  }catch(e){
    console.warn('Instrument load via backboard UI failed', id, e);
  }
}

// Backboard UV map mode: 'none' | 'u' | 'v'
let backboardUVMapMode = 'none';
// mirror current mode on window so non-module scripts can read it
try{ window.backboardUVMapMode = backboardUVMapMode; }catch(e){}

// Set backboard UV map mode and request a texture update
function setBackboardUVMapMode(mode){
  if(!mode) mode = 'none';
  mode = String(mode).toLowerCase();
  if(!['none','u','v','checker'].includes(mode)) mode = 'none';
  backboardUVMapMode = mode;
  try{ window.backboardUVMapMode = backboardUVMapMode; }catch(e){}
  // trigger a redraw/update of the texture if canvas exists
  try{
    requestBackboardRedraw();
  }catch(e){}
  try{
    if(backboardTexture){
      // re-apply repeat/offset so the live canvas remains cropped to the UV island
      try{ backboardTexture.repeat.set(backboardUVBounds.uSpan, backboardUVBounds.vSpan); }catch(e){}
      try{ backboardTexture.offset.set(backboardUVBounds.uMin, backboardUVBounds.vMin); }catch(e){}
      backboardTexture.needsUpdate = true;
      // One-time debug print
      try{
        if(!backboardUvDebugLogged){
          console.log('Backboard UV', 'flipY:', backboardTexture.flipY, 'repeat:', backboardTexture.repeat.x, backboardTexture.repeat.y, 'offset:', backboardTexture.offset.x, backboardTexture.offset.y);
          backboardUvDebugLogged = true;
        }
      }catch(e){}
    }
  }catch(e){}
}

function toggleBackboardUVMap(){
  const order = ['none','u','v'];
  const idx = order.indexOf(backboardUVMapMode);
  const next = order[(idx+1) % order.length];
  setBackboardUVMapMode(next);
}

// Draw U (horizontal) color map
function drawUMap(canvas){
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = backboardCssW, H = backboardCssH;
  try{ ctx.imageSmoothingEnabled = true; }catch(e){}
  // Draw gradient only across the U local viewport (keymapULeft..keymapURight)
  const uMin = Number(keymapULeft || 0);
  const uMax = Number(keymapURight || 1);
  const x0 = Math.round(uMin * W);
  const x1 = Math.round(uMax * W);
  const grad = ctx.createLinearGradient(x0, 0, x1, 0);
  grad.addColorStop(0.0, '#ff0000');
  grad.addColorStop(0.5, '#00ff00');
  grad.addColorStop(1.0, '#0000ff');
  // fill full vertical span but only in the U window horizontally
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle = grad;
  ctx.fillRect(x0, 0, Math.max(1, x1-x0), H);
}

// Map helpers: localU/localV in [0..1] -> absolute UV -> canvas px
// Map normalized local coords [0..1] -> absolute UV (0..1) taking into account
// the detected UV island bounds and any axis swap or per-axis mirroring.
function mapNormToUv(localU, localV){
  const ub = backboardUVBounds || { uMin: Number(keymapULeft||0), uMax: Number(keymapURight||1), vMin: V_MIN, vMax: V_MAX, uSpan: (Number(keymapURight||1) - Number(keymapULeft||0)), vSpan: V_RANGE };
  const uSpan = (ub.uSpan != null) ? ub.uSpan : (ub.uMax - ub.uMin);
  const vSpan = (ub.vSpan != null) ? ub.vSpan : (ub.vMax - ub.vMin);
  let uAbs, vAbs;
  if(backboardUVCorrection && backboardUVCorrection.swap){
    // axes swapped: localU -> V, localV -> U
    uAbs = ub.uMin + (localV * vSpan);
    vAbs = ub.vMin + (localU * uSpan);
  } else {
    uAbs = ub.uMin + (localU * uSpan);
    vAbs = ub.vMin + (localV * vSpan);
  }
  if(backboardUVCorrection && backboardUVCorrection.mirrorU){ uAbs = (ub.uMin + ub.uMax) - uAbs; }
  if(backboardUVCorrection && backboardUVCorrection.mirrorV){ vAbs = (ub.vMin + ub.vMax) - vAbs; }
  return { u: uAbs, v: vAbs };
}

function localUToAbs(localU){ return mapNormToUv(localU, 0).u; }
function localVToAbs(localV){ return mapNormToUv(0, localV).v; }

function absUToXpx(uAbs, W){ return Math.round(uAbs * W); }
function absVToYpx(vAbs, H){ return Math.round((1.0 - vAbs) * H); }

// Convert absolute U (0..1) to backboard canvas X taking UV cropping into account
function absUToBackboardX(uAbs, W){
  const uv = backboardUVBounds || { uMin:0, uSpan:1 };
  const uMin = Number(uv.uMin ?? 0);
  const span = Math.max(1e-6, Number(uv.uSpan ?? (uv.uMax - uv.uMin) ?? 1));
  return Math.round(((uAbs - uMin) / span) * W);
}

// Compute approximate world-per-UV scale for the backboard mesh so markers draw with correct aspect
function computeWorldPerUV(mesh){
  if(!mesh || !mesh.isMesh){ return null; }
  try{
    const bb = new THREE.Box3().setFromObject(mesh);
    const size = bb.getSize(new THREE.Vector3());
    // pick largest and second-largest components as width/height
    const comps = [size.x, size.y, size.z].map((v,i)=>({v, i})).sort((a,b)=>b.v-a.v);
    const worldW = Math.max(1e-6, comps[0].v);
    const worldH = Math.max(1e-6, comps[1].v);
    const uMin = Number(keymapULeft || 0);
    const uMax = Number(keymapURight || 1);
    const uvW = Math.max(1e-6, (uMax - uMin));
    const uvH = Math.max(1e-6, V_RANGE);
    const worldPerU = worldW / uvW;
    const worldPerV = worldH / uvH;
    return { worldPerU, worldPerV, worldW, worldH };
  }catch(e){ return null; }
}

// Derive backboard horizontal axis and span from its world-space bounding box
function computeBackboardWorldSpan(mesh){
  if(!mesh || !mesh.isMesh) return false;
  try{
    const bb = new THREE.Box3().setFromObject(mesh);
    const size = bb.getSize(new THREE.Vector3());
    const axis = (size.x >= size.z) ? 'x' : 'z';
    const min = bb.min[axis];
    const max = bb.max[axis];
    const span = Math.max(1e-6, max - min);
    backboardHorizAxis = axis;
    backboardWorldSpan = { min, max, span };
    return true;
  }catch(e){ return false; }
}

// Compute per-key lane boundaries in absolute U [0..1] derived from world positions
function computeKeyLanesFromWorld(){
  if(!backboardMesh || !midiKeyMap || !midiKeyMap.size) return;
  if(!computeBackboardWorldSpan(backboardMesh)) return;
  const lanes = new Map();
  let entries = [];
  midiKeyMap.forEach((mesh, note)=>{
    try{
      const bb = new THREE.Box3().setFromObject(mesh);
      let u0 = (bb.min[backboardHorizAxis] - backboardWorldSpan.min) / backboardWorldSpan.span;
      let u1 = (bb.max[backboardHorizAxis] - backboardWorldSpan.min) / backboardWorldSpan.span;
      if(u0 > u1) { const t=u0; u0=u1; u1=t; }
      u0 = Math.max(0, Math.min(1, u0));
      u1 = Math.max(0, Math.min(1, u1));
      lanes.set(Number(note), { u0, u1 });
      // augment keyByNote entry so downstream consumers can use abs lanes
      const existing = keyByNote.get(Number(note)) || { name: mesh?.name };
      existing.u0_abs = u0; existing.u1_abs = u1;
      keyByNote.set(Number(note), existing);
      entries.push({ note:Number(note), mid:(u0+u1)*0.5 });
    }catch(e){ /* ignore per-key failure */ }
  });
  // Mirror if mids decrease with ascending MIDI
  try{
    entries.sort((a,b)=>a.note-b.note);
    let inversions = 0;
    for(let i=1;i<entries.length;i++){
      if(entries[i].mid < entries[i-1].mid) inversions++;
    }
    if(inversions > Math.max(2, Math.floor(entries.length*0.05))){
      lanes.forEach((v,k)=>{
        const nu0 = 1 - v.u1;
        const nu1 = 1 - v.u0;
        v.u0 = Math.min(nu0, nu1);
        v.u1 = Math.max(nu0, nu1);
        lanes.set(k, v);
        const kb = keyByNote.get(Number(k));
        if(kb){ kb.u0_abs = v.u0; kb.u1_abs = v.u1; keyByNote.set(Number(k), kb); }
      });
      console.warn('Mirrored world-derived key lanes to enforce left-to-right order');
    }
  }catch(e){ /* ignore mirror check */ }
  keyLanesAbs = lanes;
  try{ requestBackboardRedraw(); }catch(e){}
}


// Draw V (vertical) color map
function drawVMap(canvas){
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = backboardCssW, H = backboardCssH;
  try{ ctx.imageSmoothingEnabled = true; }catch(e){}
  // Map local V [0..1] into absolute V range V_MIN..V_MAX and draw gradient within that band
  const yTop = vAbsToYPx(V_MAX, H);    // top (smaller y)
  const yBottom = vAbsToYPx(V_MIN, H); // bottom (larger y)
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
  const grad = ctx.createLinearGradient(0, yTop, 0, yBottom);
  grad.addColorStop(0.0, '#ff0000');
  grad.addColorStop(0.5, '#00ff00');
  grad.addColorStop(1.0, '#0000ff');
  ctx.fillStyle = grad;
  ctx.fillRect(0, yTop, W, Math.max(1, Math.round(yBottom - yTop)));
}

// Draw a small-cell checkerboard for high-resolution UV debugging
function drawCheckerMap(canvas, cellW = 16, cellH = 12){
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = backboardCssW, H = backboardCssH;
  try{ ctx.imageSmoothingEnabled = true; }catch(e){}
  // Draw checker only inside local UV viewport (u: keymapULeft..keymapURight, v: V_MIN..V_MAX)
  const uMin = Number(keymapULeft || 0);
  const uMax = Number(keymapURight || 1);
  const x0 = Math.round(uMin * W);
  const x1 = Math.round(uMax * W);
  const yTop = vAbsToYPx(V_MAX, H);
  const yBottom = vAbsToYPx(V_MIN, H);
  const y0 = Math.max(0, Math.min(H-1, Math.round(yTop)));
  const y1 = Math.max(0, Math.min(H, Math.round(yBottom)));
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
  for(let yy = y0; yy < y1; yy += cellH){
    for(let xx = x0; xx < x1; xx += cellW){
      const xi = Math.floor((xx - x0) / cellW);
      const yi = Math.floor((yy - y0) / cellH);
      const even = ((xi + yi) & 1) === 0;
      ctx.fillStyle = even ? '#e6e6e6' : '#444444';
      ctx.fillRect(xx, yy, Math.min(cellW, x1 - xx), Math.min(cellH, y1 - yy));
    }
  }
}

// Publicize control functions for the page UI
window.setBackboardUVMapMode = setBackboardUVMapMode;
window.toggleBackboardUVMap = toggleBackboardUVMap;
// Diagnostic helpers for note names and on-screen debug text
const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
function midiToName(n) {
  const pc = ((n % 12) + 12) % 12;
  const octave = Math.floor(n / 12) - 1;
  return `${NOTE_NAMES[pc]}${octave}`;
}
function drawDebugText(ctx, lines){
  ctx.save();
  ctx.font = "16px sans-serif";
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(8, 8, 420, 24 * lines.length + 12);
  ctx.fillStyle = "white";
  lines.forEach((s, i) => ctx.fillText(s, 16, 32 + i * 24));
  ctx.restore();
}
const TABLET_HYSTERESIS = 0.0025; // radians: small threshold before target updates (~0.14deg)
const TABLET_MAX_ROT_SPEED = 3.0; // radians per second maximum applied change
let animActionsA = [];
let animActionsB = [];
// ---- Glow materials for active notes ----
// Blender-specified glow materials (provided spec)
const GlowMaterials = {
  'keys_black_glow': {
    color: 0x860B07,
    emissive: 0x860B07,
    emissiveIntensity: 1.000,
    metalness: 0.000,
    roughness: 0.353,
  },
  'keys_white_glow': {
    color: 0x17FF1C,
    emissive: 0x17FF1C,
    emissiveIntensity: 1.000,
    metalness: 0.000,
    roughness: 0.307,
  },
};
let glbGlowMaterial = null; // still capture if a unified 'glow' exists, but we prefer spec pair
const glowMatBlack = new THREE.MeshStandardMaterial({
  name: 'keys_black_glow',
  color: new THREE.Color(GlowMaterials['keys_black_glow'].color),
  emissive: new THREE.Color(GlowMaterials['keys_black_glow'].emissive),
  emissiveIntensity: GlowMaterials['keys_black_glow'].emissiveIntensity,
  metalness: GlowMaterials['keys_black_glow'].metalness,
  roughness: GlowMaterials['keys_black_glow'].roughness
});
const glowMatWhite = new THREE.MeshStandardMaterial({
  name: 'keys_white_glow',
  color: new THREE.Color(GlowMaterials['keys_white_glow'].color),
  emissive: new THREE.Color(GlowMaterials['keys_white_glow'].emissive),
  emissiveIntensity: GlowMaterials['keys_white_glow'].emissiveIntensity,
  metalness: GlowMaterials['keys_white_glow'].metalness,
  roughness: GlowMaterials['keys_white_glow'].roughness
});
glowMatBlack.side = THREE.DoubleSide; glowMatWhite.side = THREE.DoubleSide;
// Track how many overlapping note-ons are active per key to safely restore material
const keyActiveCount = new Map(); // noteNumber -> count
const safeRun = (fn, label = 'Non-critical failure') => {
  try { fn(); }
  catch (err) { console.warn(label, err); }
};
const disposeAudioSource = (reason) => {
  if (!audioSource) return;
  const prefix = reason ? `${reason}:` : 'audioSource cleanup';
  safeRun(() => audioSource.stop(), `${prefix} stop failed`);
  safeRun(() => audioSource.disconnect(), `${prefix} disconnect failed`);
  audioSource = null;
};
// Clear all active glow states and restore original materials
function clearAllKeyGlow(){
  keyActiveCount.clear();
  if(keyMeshes && keyMeshes.length){
    keyMeshes.forEach(m => {
      const orig = m?.userData?._origMaterial;
      if(orig && m.material !== orig){
        m.material = orig;
        if(m.material) m.material.needsUpdate = true;
      }
    });
  }
}

// Load an instrument by name (SoundFont player preferred, WebAudioFont as fallback).
async function loadInstrument(name){
  // Backend selection: check user preference
  const preferred = (window.PREFERRED_INSTRUMENT_BACKEND || 'auto').toString().toLowerCase();
  const trySoundfontFirst = (preferred === 'auto' || preferred === 'soundfont');
  const tryWebAudioFont = (preferred === 'auto' || preferred === 'webaudiofont' || preferred === 'webaudiofont-local');
  // Try Soundfont-player first if allowed
  const SF = window.Soundfont || window.SoundFont || window.SoundfontPlayer || window.SoundfontPlayer || window.Soundfont || window.SoundfontPlayer;
  if(trySoundfontFirst){
    if(SF){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        const opts = { soundfont: 'MusyngKite', format: 'mp3', url: 'https://gleitz.github.io/midi-js-soundfonts/MusyngKite/' };
        const inst = await SF.instrument(audioCtx, name, opts);
        instrumentPlayer = inst;
        currentInstrumentName = name + ' (SoundFont)';
        console.log('Loaded instrument (SoundFont)', name, inst);
        if(HUD) HUD.textContent = `instrument: ${currentInstrumentName}`;
        return inst;
      }catch(e){
        console.warn('SoundFont.instrument failed', e);
        if(preferred === 'soundfont'){
          if(HUD) HUD.textContent = `soundfont load failed`;
          return null;
        }
      }
    } else {
      console.warn('Soundfont-player not found (no global SF)');
      if(preferred === 'soundfont'){
        if(HUD) HUD.textContent = `soundfont missing`;
        return null;
      }
    }
  }

  // WebAudioFont fallback
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    // WebAudioFont script source selection based on preference
    let wafScript = 'https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js';
    if(window.PREFERRED_INSTRUMENT_BACKEND === 'webaudiofont-local'){
      wafScript = '/assets/vendor/WebAudioFontPlayer.js';
    }
    // Load WebAudioFontPlayer script if not present
    if(!window.WebAudioFontPlayer){
      await new Promise((resolve, reject)=>{
        const s = document.createElement('script');
        s.src = wafScript;
        s.async = true;
        s.onload = ()=>{ console.log('WebAudioFontPlayer loaded from', wafScript); resolve(); };
        s.onerror = (e)=>{ console.warn('Failed to load WebAudioFontPlayer script', wafScript, e); reject(e); };
        document.head.appendChild(s);
      });
    }
    // create player instance if needed
    if(!window._WAF_player){
      window._WAF_player = new WebAudioFontPlayer();
    }
    const player = window._WAF_player;

    // Friendly name -> General MIDI program mapping (subset)
    const nameToProgram = {
      'acoustic_grand_piano': 1,
      'bright_acoustic_piano': 2,
      'electric_piano_1': 5,
      'electric_piano_2': 6,
      'honkytonk': 4,
      'harpsichord': 7,
      'vibraphone': 12,
      'church_organ': 20,
      'accordion': 21,
      'string_ensemble_1': 49,
      'pad_1': 89,
      'choir_aahs': 52
    };
    const program = nameToProgram[name] || 1;
    // find instrument index and info
    const idx = player.loader.findInstrument(program);
    const info = player.loader.instrumentInfo(idx);
    if(!info || !info.url || !info.variable){
      console.warn('WebAudioFont info missing for program', program, info);
      if(HUD) HUD.textContent = `webaudiofont: missing info`;
      return null;
    }
    // start loading preset script
    player.loader.startLoad(audioCtx, info.url, info.variable);
    // wait until preset variable becomes available
    await new Promise((resolve, reject)=>{
      const timeout = setTimeout(()=>reject(new Error('WAF preset load timeout')), 10000);
      const check = ()=>{
        if(window[info.variable]){ clearTimeout(timeout); resolve(); }
        else setTimeout(check, 120);
      };
      check();
    });
    // Create a thin adapter exposing .play(midiNum, when, opts) returning an object with .stop()
    const preset = window[info.variable];
    const adapter = {
      _player: player,
      _preset: preset,
      play: function(midiNum, whenSec, opts){
        const dur = (opts && opts.duration) ? opts.duration : 1.8; // default short note
        const vol = (opts && typeof opts.gain === 'number') ? opts.gain : 1;
        // allow an external gainNode to be supplied so we can control fades without touching library internals
        const dest = (opts && opts.gainNode) ? opts.gainNode : audioCtx.destination;
        const env = this._player.queueWaveTable(audioCtx, dest, this._preset, whenSec || audioCtx.currentTime, midiNum, dur, vol);
        // envelope contains audioBufferSourceNode for stopping
        const wrapper = {
          _env: env,
          stop: function(stopWhenSec){ try{ if(env && env.audioBufferSourceNode){ env.audioBufferSourceNode.stop(stopWhenSec||audioCtx.currentTime); } }catch(e){} }
        };
        return wrapper;
      }
    };
    instrumentPlayer = adapter;
    currentInstrumentName = name + ' (WebAudioFont)';
    console.log('Loaded instrument (WebAudioFont)', name, info.url, info.variable);
    if(HUD) HUD.textContent = `instrument: ${currentInstrumentName}`;
    return adapter;
  }catch(e){
    console.warn('WebAudioFont fallback failed', e);
    if(HUD) HUD.textContent = `instrument load error: ${name}`;
    return null;
  }
}
window.loadInstrument = loadInstrument;
window.getCurrentInstrumentName = () => currentInstrumentName;
function ensureAudio(){
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  if(!masterGain){
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.22; // lower overall level to reduce clipping
    masterGain.connect(audioCtx.destination);
  }
}
function applyKeyGlow(mesh, noteNumber, on){
  if(!mesh) return;
  const cur = (keyActiveCount.get(noteNumber) || 0) + (on? 1 : -1);
  const next = Math.max(0, cur);
  keyActiveCount.set(noteNumber, next);
  if(on){
    // Save original material once
    if(mesh.userData && mesh.userData._origMaterial === undefined){
      mesh.userData._origMaterial = mesh.material;
    }
    // Prefer the Blender spec pair; only fall back to a single captured glbGlowMaterial if explicitly desired
    const gm = (isBlackKey(mesh) ? glowMatBlack : glowMatWhite);
    mesh.material = gm;
    if(mesh.material) mesh.material.needsUpdate = true;
  } else if(next===0) {
    // Restore original when no more active presses remain
    const orig = mesh.userData ? mesh.userData._origMaterial : null;
    if(orig){ mesh.material = orig; if(mesh.material) mesh.material.needsUpdate = true; }
  }
  // Request backboard redraw when visual key glow changes
  try{ requestBackboardRedraw(); }catch(e){}
}
function applyPersistentHighlights(){
  PERSISTENT_HIGHLIGHTS.forEach((note)=>{
    const mesh = midiKeyMap.get(note);
    if(mesh) applyKeyGlow(mesh, note, true);
  });
}
// ---- Track Metadata (moved earlier to avoid TDZ issues) ----
// Track metadata (adjust paths if actual filenames differ)
const TRACKS = {
  baby: {
    label: 'Baby',
    audioCandidates: [
      './music/Baby,-Just-Shut-Up!,-A-Lullaby.wav',
      './music/Baby,-Just-Shut-Up!,-A-Lullaby.mp3'
    ],
    midi: './midi/babyshutup.mid'
  },
  raisins: {
    label: 'Raisins',
    audioCandidates: [
      './music/Those-Raisins-Are-Mine!.wav', // preferred if added later
      './music/Those-Raisins-Are-Mine!.mp3'
    ],
    midi: './midi/raisins.mid'
  },
  forests: {
    label: 'Forests',
    audioCandidates: [
      './music/No-Forests-Left-to-Give.wav',
      './music/No-Forests-Left-to-Give.mp3'
    ],
    // Supports multiple MIDI parts to be merged
    midi: [
      './midi/Forests-Accomp.mid',
      './midi/Forests-Harmony.mid',
      './midi/Forests-Melody.mid'
    ]
  }
};
let currentTrackKey = 'baby';

// Adjustable framing tightness (lower value = closer). Original was 1.55 (looser)
const FRAME_TIGHTNESS = 1.6; // higher => further camera distance
function fit(box){
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);
  const maxDim = Math.max(size.x,size.y,size.z);
  const fov = cam.fov*Math.PI/180;
  const dist = (maxDim/2)/Math.tan(fov/2) * FRAME_TIGHTNESS;

  // Static framing for debug: "10 frames back" from the closer hero shot.
  // Slightly higher and farther so more of the stand is visible.
  const debugDist = dist * 0.90;
  const camPos = new THREE.Vector3(
    center.x + debugDist * 0.04,
    center.y + size.y * 0.72,
    center.z + debugDist * 0.78
  );

  const target = new THREE.Vector3(center.x, center.y + size.y * 0.32, center.z);

  cam.position.copy(camPos);
  cam.lookAt(target);
  controls.target.copy(target);
}
function collectKeys(node){
  const found=[];
  const midiPattern = /^(\d{3})_([A-G](?:#|b)?\d)$/i; // extract MIDI number
  node.traverse(o=>{
    if(o.isMesh){
      const nm = o.name || '';
      const m = nm.match(midiPattern);
      if(m){
        const midiNum = parseInt(m[1],10);
        midiKeyMap.set(midiNum, o);
        found.push(o);
      } else if(/key|white|black/.test(nm.toLowerCase())) {
        found.push(o);
      }
    }
  });
  keyMeshes = found; console.log('Debug collect keys:', found.map(f=>f.name));
  if(keyMeshes.length){
    chooseMiddleKey();
  }
  // init pressState
  keyMeshes.forEach(k=>pressState.set(k,0));
  // Build animation state map for MIDI keys
  midiKeyMap.forEach((mesh, note)=>{
    keyAnimState.set(note, { mesh, phase:'idle', startMs:0, fromAngle:0, targetAngle:0 });
  });
  applyPersistentHighlights();
}
function chooseMiddleKey(){
  // Sort keys by world X position to find median (approx middle C)
  const positions = keyMeshes.map(k=>{
    k.updateWorldMatrix(true,false);
    const p = new THREE.Vector3();
    k.getWorldPosition(p);
    return {mesh:k, x:p.x};
  }).sort((a,b)=>a.x-b.x);
  const median = positions[Math.floor(positions.length/2)];
  selectedKey = median.mesh;
  // Heuristic brighten highlight
  if(selectedKey.material && selectedKey.material.color){
    selectedKey.material.emissive ||= new THREE.Color(0x000000);
    selectedKey.material.emissive.setHex(0x442266);
  }
  console.log('Selected middle key for demo:', selectedKey.name);
}
// Make all white keys share the C8 material so their finish matches visually
function unifyWhiteKeysToReference(){
  // Subtle ivory PBR material with vertex colors/maps disabled to avoid baked tints
  const ivory = new THREE.MeshStandardMaterial({
    color: new THREE.Color(0xf8f3eb), // warm ivory
    metalness: 0.02,
    roughness: 0.30,
    envMapIntensity: 0.35,
    toneMapped: true,
    vertexColors: false
  });
  ivory.name = 'keys_white_ivory';
  midiKeyMap.forEach((mesh, note)=>{
    if(isBlackNoteByNumber(Number(note))) return;
    if(!mesh || Array.isArray(mesh.material)) return;
    mesh.material = ivory;
    // Ensure no baked maps/vertex colors alter the tone
    if(mesh.material) {
      mesh.material.map = null;
      mesh.material.aoMap = null;
      mesh.material.lightMap = null;
      mesh.material.vertexColors = false;
    }
    // Gentle contact shadows on white keys; avoid them casting onto others
    mesh.castShadow = false;
    mesh.receiveShadow = true;
    try{ mesh.material.needsUpdate = true; }catch(e){}
    if(mesh.userData) mesh.userData._origMaterial = ivory;
  });
}
function isBlackKey(mesh){
  // User guarantee: all black keys include a '#' in their name
  return /#/i.test(mesh?.name||'');
}
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  const dt = clock.getDelta();
  if(animationMixer) animationMixer.update(dt);
  renderer.render(scene, cam);
  if(root){
    const box = new THREE.Box3().setFromObject(root);
    const s = box.getSize(new THREE.Vector3());
  let midiLine = midiError? 'midi:error' : (midiLoaded? (playingMIDI? `midi:${midiIndex}/${midiEvents.length}` : 'midi:ready') : 'midi:loading');
  let audioLine = audioError? 'audio:error' : (audioReady ? (audioPlaying? 'audio:playing' : 'audio:ready') : 'audio:loading');
  const trimInfo = audioReady ? ` trim:${audioTrimMs.toFixed(0)}ms` : '';
  // Live drift diagnostics: compare MIDI and audio elapsed clocks
  let driftLine = '';
  if(audioCtx && (audioPlaying||playingMIDI)){
    const elapsedAudioMs = (audioCtx.currentTime - audioStartCtxTime) * 1000;
    const elapsedMidiMs = (audioCtx.currentTime - midiStartCtxTime) * 1000;
    const driftMs = elapsedMidiMs - elapsedAudioMs;
    driftLine = ` drift:${driftMs.toFixed(1)}ms`;
  }
  HUD.textContent = `children:${root.children.length}\nsize:${s.x.toFixed(3)},${s.y.toFixed(3)},${s.z.toFixed(3)}\nkeys:${keyMeshes.length}\n${midiLine}\n${audioLine}${trimInfo}${driftLine}\ntempos:${tempoMap.length} sentinels:${sentinelFilteredCount}\ncam:${cam.position.x.toFixed(2)},${cam.position.y.toFixed(2)},${cam.position.z.toFixed(2)}`;
    // Demo animation for selected key or fallback
    // Always update view-driven transforms (e.g., tablet stand)
    updateViewDrivenTransforms(dt);
    if(playingMIDI){
      const elapsedMidiSec = audioCtx ? (audioCtx.currentTime - midiStartCtxTime) : 0;
      if(elapsedMidiSec >= 0) advanceMIDI(elapsedMidiSec * 1000);
    }
    updateKeyAnimations();
      // update backboard overlay only when dirty (throttled to BACKBOARD_MAX_FPS)
      try{
        const nowMs = performance.now();
        if(backboardDirty && (nowMs - lastBackboardDrawMs) >= (1000 / BACKBOARD_MAX_FPS)){
          try{ renderBackboardOverlay(); }catch(e){}
          backboardDirty = false;
          lastBackboardDrawMs = nowMs;
        }
      }catch(e){ /* ignore */ }
  }
  updateInstrumentPickerPosition();
}
animate();
// Proper signature: (url, onLoad, onProgress, onError)
const MODEL_VERSION = 'v20251115a'; // bump to bust cache when GLB updated
loader.load((window && window.mediaUrl) ? window.mediaUrl('glb/toy-piano.glb') + `?${MODEL_VERSION}` : `glb/toy-piano.glb?${MODEL_VERSION}`,
  gltf => {
    root = gltf.scene;
    scene.add(root);
    // Future: attach tablet screen canvas/texture here.
    // Currently a no-op so tablet changes don't affect playback.
    try { setupMusicTabletScreen(root); } catch (e) { console.warn('setupMusicTabletScreen failed', e); }
    // brightening + double side
    root.traverse(o=>{ 
      if(/note_stickers|noteSticker|noteAccidental|noteText/i.test(o.name)) { stickerMeshes.push(o); o.visible = true; }
      if(!sustainPedalMesh && /(sustain|damper|right.*pedal|pedal.*right)/i.test(o.name)){
        sustainPedalMesh = o;
      }
      if(!tabletStandMesh && /tablet_stand/i.test(o.name)) { tabletStandMesh = o; try{ tabletStandCurrentAngle = (tabletStandMesh.rotation && typeof tabletStandMesh.rotation.x === 'number') ? tabletStandMesh.rotation.x : 0; tabletStandTargetAngle = tabletStandCurrentAngle; }catch(e){} }
      // Backboard screen for note info: look for mesh named SK_backboard_screen
        if(!backboardMesh && /SK_backboard_screen/i.test(o.name)){
        backboardMesh = o;
        try{
          // Create overlay canvas sized by the mesh world aspect ratio and HiDPI backing store
          // Compute mesh world bounding box to choose a sensible CSS pixel dimension
          try{ o.updateMatrixWorld(true); }catch(e){}
          let bbMesh = null; try{ bbMesh = new THREE.Box3().setFromObject(o); }catch(e){ bbMesh = null; }
          let worldW = 1.0, worldH = 0.125;
          try{
            if(bbMesh){
              // Use sorted dims to pick true surface width/height (avoid assuming X/Z order)
              const size = bbMesh.getSize(new THREE.Vector3());
              const dims = [size.x, size.y, size.z].map(v => Math.max(1e-6, v)).sort((a,b)=>a-b);
              const thickness = dims[0];
              const h = dims[1];
              const w = dims[2];
              backboardSurfaceAspect = w / h;
              worldW = w; worldH = h;
              console.log('backboardSurfaceAspect', backboardSurfaceAspect, 'canvas', backboardCssW, backboardCssH, 'uvBounds', backboardUVBounds);
            }
          }catch(e){ worldW = 1.0; worldH = 0.125; }
          let aspect = backboardSurfaceAspect || (worldW / Math.max(1e-6, worldH));
          if(!isFinite(aspect) || aspect <= 0) aspect = 8.0; // piano-ish fallback
          const dpr = Math.min(2, window.devicePixelRatio || 1);
          const BASE_W = 4096; // high quality base width (lower to 2048 if perf needed)
          // Prefer sizing the canvas to the UV island aspect so drawings are 1:1.
          let screenAspect = aspect;
          try{
            if(backboardUVBounds && backboardUVBounds.uSpan > 0 && backboardUVBounds.vSpan > 0){
              screenAspect = backboardUVBounds.uSpan / backboardUVBounds.vSpan;
            }
          }catch(e){}
          // CSS-pixel logical canvas size (we draw in CSS pixels and scale the backing store by dpr)
          backboardCssW = Math.round(BASE_W);
          backboardCssH = Math.max(64, Math.round(BASE_W / Math.max(1e-6, screenAspect)));
          backboardCanvas = document.createElement('canvas');
          // Create HiDPI backing store and set drawing transform so code can draw in CSS pixels
          backboardCanvas.width = Math.round(backboardCssW * dpr);
          backboardCanvas.height = Math.round(backboardCssH * dpr);
          backboardCanvas.style.width = backboardCssW + 'px';
          backboardCanvas.style.height = backboardCssH + 'px';
          backboardCtx = backboardCanvas.getContext('2d');
          // Set transform so drawing commands can use CSS-pixel coordinates
          try{ backboardCtx.setTransform(dpr,0,0,dpr,0,0); }catch(e){}
          try{ backboardCtx.imageSmoothingEnabled = true; }catch(e){}
          // Create texture and apply to mesh material
          backboardTexture = new THREE.CanvasTexture(backboardCanvas);
          // Prefer colorSpace when available (r152+), fallback to encoding
          try{ backboardTexture.colorSpace = THREE.SRGBColorSpace; }catch(e){ try{ backboardTexture.encoding = THREE.sRGBEncoding; }catch(e){} }
          // Ensure texture Y orientation matches canvas coordinate expectations for our overlay
          try{ backboardTexture.flipY = false; }catch(e){}
          // Apply texture filtering and mipmaps for improved crispness
          try{ backboardTexture.generateMipmaps = true; }catch(e){}
          try{ backboardTexture.minFilter = THREE.LinearMipmapLinearFilter; }catch(e){ backboardTexture.minFilter = THREE.LinearFilter; }
          try{ backboardTexture.magFilter = THREE.LinearFilter; }catch(e){ backboardTexture.magFilter = THREE.LinearFilter; }
          // If available, enable anisotropy for better sharpness at glancing angles
          try{ backboardTexture.anisotropy = (renderer && renderer.capabilities && typeof renderer.capabilities.getMaxAnisotropy === 'function') ? (renderer.capabilities.getMaxAnisotropy() || 1) : 1; }catch(e){}
          backboardTexture.wrapS = THREE.ClampToEdgeWrapping; backboardTexture.wrapT = THREE.ClampToEdgeWrapping;
          backboardTexture.needsUpdate = true;
          // Build a dedicated screen plane as a child for stable UVs/hit-testing
          try{
            const bbLocal = new THREE.Box3().setFromObject(backboardMesh);
            const sizeLocal = bbLocal.getSize(new THREE.Vector3());
            const planeW = sizeLocal.x || 1;
            const planeH = sizeLocal.y || 0.3;
            const planeGeom = new THREE.PlaneGeometry(planeW, planeH);
            const planeMat = new THREE.MeshBasicMaterial({
              map: backboardTexture,
              transparent: true,
              opacity: 1.0,
              depthWrite: false,
              toneMapped: false,
              side: THREE.DoubleSide
            });
            screenPlane = new THREE.Mesh(planeGeom, planeMat);
            screenPlane.name = 'UI_ScreenPlane';
            screenPlane.position.set(0, 0, 0.001);
            screenPlane.renderOrder = 20;
            backboardMesh.add(screenPlane);
            screenPlane.updateMatrixWorld(true);
          }catch(e){ console.warn('ScreenPlane creation failed', e); }
          console.log('Backboard canvas ready', backboardCanvas.width, backboardCanvas.height);

          // Note: do NOT alter the original backboard mesh material here —
          // we want to preserve the imported GLB appearance. The overlay
          // plane created below will carry the yellow circle texture.

          // Overlay plane creation removed: we apply the backboard canvas texture
          // directly to the imported `SK_backboard_screen` material so the
          // circle drawn by `renderBackboardOverlay()` appears on the mesh.
          // Attempt to load precomputed keymap.json and use it preferentially
          (async ()=>{
            try{
              const resp = await fetch('keymap.json');
              if(!resp.ok) throw new Error('HTTP '+resp.status);
              const keymap = await resp.json();
              if(keymap && Array.isArray(keymap.keys)){
                keyByNote.clear();
                for(const k of keymap.keys){
                  // enforce numeric keys
                  keyByNote.set(Number(k.note), { u0: k.u0, u1: k.u1, name: k.name || String(k.note) });
                }
                keymapULeft = Number(keymap.uLeft) || keymapULeft;
                keymapURight = Number(keymap.uRight) || keymapURight;
                jsonKeymapLoaded = true;
                RAYCAST_KEYMAP_READY = keyByNote.size > 0;
                // Ensure U runs left->right: flip if mids decrease with ascending note
                try{
                  const entries = Array.from(keyByNote.entries()).map(([note, obj])=>({
                    note: Number(note),
                    u0: Number(obj.u0),
                    u1: Number(obj.u1),
                    mid: (Number(obj.u0)+Number(obj.u1))*0.5
                  })).sort((a,b)=>a.note-b.note);
                  let inversions = 0;
                  for(let i=1;i<entries.length;i++){
                    if(entries[i].mid < entries[i-1].mid) inversions++;
                  }
                  if(false && inversions > Math.max(2, Math.floor(entries.length*0.05))){
                    const uL = Number(keymapULeft||0);
                    const uR = Number(keymapURight||1);
                    const span = uR - uL;
                    const mirror = (u)=> uL + (span - (u - uL));
                    keyByNote.forEach((v,k)=>{
                      const nu0 = mirror(Number(v.u1));
                      const nu1 = mirror(Number(v.u0));
                      v.u0 = Math.min(nu0, nu1);
                      v.u1 = Math.max(nu0, nu1);
                      keyByNote.set(k, v);
                    });
                    console.warn('keymap.json U mirrored to enforce left-to-right order');
                  }
                }catch(e){ console.warn('keymap.json mirror check failed', e); }
                console.log('Loaded keymap.json: uLeft/uRight', keymapULeft, keymapURight);
                console.log('k28', keyByNote.get(28), 'k60', keyByNote.get(60), 'k108', keyByNote.get(108));
                // Derive UV bounds from keymap.json if present. Preferred fields:
                // keymap.screenUvBounds.{uMin,uMax,vMin,vMax} OR keymap.uv_uMin,uv_uMax,uv_vMin,uv_vMax
                try{
                  let uMin=0,uMax=1,vMin=0,vMax=1;
                  if(isFinite(keymapULeft) && isFinite(keymapURight) && keymapURight > keymapULeft){
                    uMin = keymapULeft; uMax = keymapURight;
                  }
                  if(keymap.screenUvBounds && typeof keymap.screenUvBounds === 'object'){
                    uMin = Number(keymap.screenUvBounds.uMin ?? uMin);
                    uMax = Number(keymap.screenUvBounds.uMax ?? uMax);
                    vMin = Number(keymap.screenUvBounds.vMin ?? vMin);
                    vMax = Number(keymap.screenUvBounds.vMax ?? vMax);
                  } else if('uv_uMin' in keymap || 'uv_uMax' in keymap || 'uv_vMin' in keymap || 'uv_vMax' in keymap){
                    uMin = Number(keymap.uv_uMin ?? uMin);
                    uMax = Number(keymap.uv_uMax ?? uMax);
                    vMin = Number(keymap.uv_vMin ?? vMin);
                    vMax = Number(keymap.uv_vMax ?? vMax);
                  }
                  let uSpan = (uMax - uMin); let vSpan = (vMax - vMin);
                  if(!(isFinite(uSpan) && isFinite(vSpan) && uSpan>0 && vSpan>0)){
                    console.warn('Invalid UV spans from keymap.json; falling back to full 0..1');
                    uMin=0; uMax=1; vMin=0; vMax=1; uSpan=1; vSpan=1;
                  }
                  backboardUVBounds = { uMin, uMax, vMin, vMax, uSpan, vSpan };
          // Do not resize backboard canvas after creation; only update bounds
          try{ backboardTexture.repeat.set(1,1); backboardTexture.offset.set(0,0); backboardTexture.needsUpdate = true; }catch(e){}
                }catch(e){ console.warn('Error parsing keymap.json UV bounds', e); }
                try{ requestBackboardRedraw(); }catch(e){}
              }
            }catch(e){ console.warn('Loading keymap.json failed or not present', e); }
          })();
          // Note: keymap.json loading disabled — runtime raycast will generate authoritative keymap
          // Detect UV island orientation to know if U runs left->right or was rotated/flipped in Blender
          try{
            const geom = o.geometry;
            if(geom && geom.isBufferGeometry && geom.attributes && geom.attributes.position && geom.attributes.uv){
              const posAttr = geom.attributes.position;
              const uvAttr = geom.attributes.uv;
              const count = posAttr.count;
              // find extrema indices for X, Y, Z
              let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,minZ=Infinity,maxZ=-Infinity;
              let iMinX=0,iMaxX=0,iMinY=0,iMaxY=0,iMinZ=0,iMaxZ=0;
              for(let i=0;i<count;i++){
                const x = posAttr.getX(i), y = posAttr.getY(i), z = posAttr.getZ(i);
                if(x < minX){ minX = x; iMinX = i; } if(x > maxX){ maxX = x; iMaxX = i; }
                if(y < minY){ minY = y; iMinY = i; } if(y > maxY){ maxY = y; iMaxY = i; }
                if(z < minZ){ minZ = z; iMinZ = i; } if(z > maxZ){ maxZ = z; iMaxZ = i; }
              }
              // choose vertical axis by span Y vs Z
              const spanY = maxY - minY; const spanZ = maxZ - minZ;
              const verticalAxis = (spanY >= spanZ) ? 'Y' : 'Z';
              // Compare UV.x at left-most and right-most mesh positions to detect mirrorU
              const uAtMinX = uvAttr.getX(iMinX); const uAtMaxX = uvAttr.getX(iMaxX);
              const mirrorU = (uAtMaxX < uAtMinX);
              // For V, compare UV.y at bottom vs top (using chosen vertical axis)
              const iBot = (verticalAxis === 'Y') ? iMinY : iMinZ;
              const iTop = (verticalAxis === 'Y') ? iMaxY : iMaxZ;
              const vAtBot = uvAttr.getY(iBot); const vAtTop = uvAttr.getY(iTop);
              const mirrorV = (vAtTop < vAtBot);
              // Detect axis swap: check whether UV changes more in U or V when moving along mesh X
              const du = Math.abs(uAtMaxX - uAtMinX);
              const dv = Math.abs(uvAttr.getY(iMaxX) - uvAttr.getY(iMinX));
              const swapped = dv > du;
              backboardUVCorrection = { swap: !!swapped, mirrorU: !!mirrorU, mirrorV: !!mirrorV };
              console.log('Backboard UV correction detected:', backboardUVCorrection, 'verticalAxis', verticalAxis, 'du', du.toFixed(3), 'dv', dv.toFixed(3));
            }
          }catch(e){ console.warn('backboard UV detect failed', e); }
        }catch(e){ console.warn('Backboard overlay setup failed', e); }
      }
      if(o.isMesh && o.material && o.material.color){ 
        if(o.material.color.getHex()===0x000000) o.material.color.set(0x333333); 
        o.material.side=THREE.DoubleSide; 
        o.frustumCulled=false; 
      }
      // Set all shape keys (morph targets) to 1.0
      if(o.isMesh && Array.isArray(o.morphTargetInfluences)){
        for(let i=0;i<o.morphTargetInfluences.length;i++){
          o.morphTargetInfluences[i] = 1.0;
        }
      }
      // Capture any material named 'glow' to use for active keys
      if(o.isMesh && o.material){
        const mat = o.material;
        const name = (mat.name||'').toLowerCase();
        if(!glbGlowMaterial && /\bglow\b/.test(name)){
          glbGlowMaterial = mat;
        }
      }
    });
    // initial box
    let box = new THREE.Box3().setFromObject(root);
    let size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x,size.y,size.z);
    // Auto-scale if enormous (> 20 units) or microscopic (< 0.5)
    if (maxDim > 20 || maxDim < 0.5) {
      const scale = maxDim > 20 ? 10 / maxDim : 1 / maxDim; // shrink or enlarge toward ~10 units
      root.scale.setScalar(scale);
      root.updateMatrixWorld(true);
      box = new THREE.Box3().setFromObject(root);
      size = box.getSize(new THREE.Vector3());
      console.warn('Applied auto-scale factor', scale.toFixed(5), 'new size:', size);
    }
    fit(box);
    collectKeys(root);
    computeKeyLanesFromWorld();
    unifyWhiteKeysToReference();
    // Create our own sticker sprites (do not use mesh stickers). Hide original sticker meshes.
    try{
      // Build reverse map from CODE_TO_MIDI (midi -> display key char)
      const midiToKey = new Map();
      if(typeof CODE_TO_MIDI !== 'undefined'){
        const displayFromCode = (code)=>{
          if(!code) return '';
          if(code.startsWith('Key')) return code.slice(3).toLowerCase();
          if(code.startsWith('Digit')) return code.slice(5);
          switch(code){
            case 'Comma': return ',';
            case 'Period': return '.';
            case 'Slash': return '/';
            case 'Semicolon': return ';';
            case 'BracketLeft': return '[';
            case 'BracketRight': return ']';
            case 'Minus': return '-';
            default: return code;
          }
        };
        CODE_TO_MIDI.forEach((v,k)=> midiToKey.set(Number(v), displayFromCode(k)));
      }
      // helper: find nearest key mesh to a sticker mesh
      const findNearestMidiForMesh = (mesh)=>{
        const p = new THREE.Vector3(); mesh.getWorldPosition(p);
        let best = null; let bestDist = Infinity;
        midiKeyMap.forEach((mMesh, mNum)=>{
          try{
            const q = new THREE.Vector3(); mMesh.getWorldPosition(q);
            const d = p.distanceTo(q);
            if(d < bestDist){ bestDist = d; best = Number(mNum); }
          }catch(e){}
        });
        return (bestDist < 0.12) ? best : null; // threshold in world units
      };

      // Remove any previously created user stickers
      if(userStickersGroup){ safeRun(()=> root.remove(userStickersGroup)); userStickersGroup = null; }
      userStickersGroup = new THREE.Group(); userStickersGroup.name = 'user_stickers_group';
      root.add(userStickersGroup);

      stickerMeshes.forEach(sm=>{
        try{
          // hide original mesh so we can control clipping/appearance ourselves
          sm.visible = false;
          const midi = findNearestMidiForMesh(sm);
          if(midi == null) return; // no nearby key
          const keyChar = midiToKey.get(midi);
          if(!keyChar) return; // skip notes not mapped to keyboard

          // world position and slight offset toward camera to avoid z-fighting/clipping
          const pos = new THREE.Vector3(); sm.getWorldPosition(pos);
          const camPos = new THREE.Vector3(); cam.getWorldPosition(camPos);
          const towardCam = camPos.sub(pos).normalize();
          pos.add(towardCam.multiplyScalar(0.03));

          // size hint from sticker mesh bbox
          const bbox = new THREE.Box3().setFromObject(sm);
          const boxSize = bbox.getSize(new THREE.Vector3());
          const baseScale = Math.max(boxSize.x, boxSize.y, boxSize.z) * 1.8 || 0.12;

          // draw canvas texture for the key label (ASDF key char)
          const W = 256, H = 160;
          const c = document.createElement('canvas'); c.width = W; c.height = H;
          const ctx = c.getContext('2d');
          // rounded rect background (white) with subtle border
          ctx.clearRect(0,0,W,H);
          ctx.fillStyle = 'rgba(255,255,255,0.98)';
          const r = 12;
          ctx.beginPath(); ctx.moveTo(r,0); ctx.lineTo(W-r,0); ctx.quadraticCurveTo(W,0,W,r); ctx.lineTo(W,H-r); ctx.quadraticCurveTo(W,H,W-r,H); ctx.lineTo(r,H); ctx.quadraticCurveTo(0,H,0,H-r); ctx.lineTo(0,r); ctx.quadraticCurveTo(0,0,r,0); ctx.closePath(); ctx.fill();
          ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 2; ctx.stroke();
          // key character
          ctx.fillStyle = '#000'; ctx.font = 'bold 92px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(String(keyChar).toUpperCase(), W/2, H/2 + 6);

          const tex = new THREE.CanvasTexture(c); try{ tex.encoding = THREE.sRGBEncoding; }catch(e){}
          tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter; tex.needsUpdate = true;

          // Use sprite so it always faces camera and avoids complex UV/clipping
          const mat = new THREE.SpriteMaterial({ map: tex, depthTest: true, depthWrite: false });
          const sprite = new THREE.Sprite(mat);
          sprite.position.copy(pos);
          sprite.scale.set(baseScale, baseScale * (H / W), 1);
          sprite.userData = { midi, key: keyChar };
          userStickersGroup.add(sprite);
        }catch(e){ console.warn('user sticker create failed', e); }
      });
      // Create QWERTY labels as camera-facing sprites so they never mirror and can be positioned above keys
      try{
        if(qwertyLabelsGroup){ safeRun(()=> root.remove(qwertyLabelsGroup)); qwertyLabelsGroup = null; }
        qwertyLabelsGroup = new THREE.Group(); qwertyLabelsGroup.name = 'qwerty_labels_group';
        root.add(qwertyLabelsGroup);
        // Build midi->label from CODE_TO_MIDI if available
        const midiToKeyLabel = new Map();
        if(typeof CODE_TO_MIDI !== 'undefined'){
          const displayFromCode = (code)=>{
            if(!code) return '';
            if(code.startsWith('Key')) return code.slice(3).toLowerCase();
            if(code.startsWith('Digit')) return code.slice(5);
            switch(code){ case 'Comma': return ','; case 'Period': return '.'; case 'Slash': return '/'; case 'Semicolon': return ';'; case 'BracketLeft': return '['; case 'BracketRight': return ']'; case 'Minus': return '-'; default: return code; }
          };
          CODE_TO_MIDI.forEach((midi, code)=> midiToKeyLabel.set(Number(midi), displayFromCode(code)));
        }
        // Create a sprite per white key
        midiToKeyLabel.forEach((label, midi)=>{
          try{
            const mNum = Number(midi);
            if(isBlackNoteByNumber(mNum)) return;
            const kMesh = midiKeyMap.get(mNum);
            if(!kMesh) return;
            // Position slightly above the key toward the camera to avoid black-key occlusion
            const pos = new THREE.Vector3(); kMesh.getWorldPosition(pos);
            const camPos = new THREE.Vector3(); cam.getWorldPosition(camPos);
            const towardCam = camPos.sub(pos).normalize();
            // small upward world offset plus toward-camera offset
            pos.y += 0.03;
            pos.addScaledVector(towardCam, 0.03);
            // Size based on key physical width
            const bbox = new THREE.Box3().setFromObject(kMesh);
            const bsz = bbox.getSize(new THREE.Vector3());
            const baseScale = Math.max(0.03, (bsz.x || 0.04) * 0.9);
            const Wc = 128, Hc = 96; const c = document.createElement('canvas'); c.width = Wc; c.height = Hc;
            const ctx = c.getContext('2d'); ctx.clearRect(0,0,Wc,Hc);
            // Draw transparent background and text with subtle shadow
            const fontPx = Math.max(18, Math.round(Math.min(48, Wc * 0.28)));
            ctx.font = `bold ${fontPx}px system-ui, Arial, sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillText(String(label).toUpperCase(), Wc/2 + 1, Hc/2 + 1);
            ctx.fillStyle = 'white'; ctx.fillText(String(label).toUpperCase(), Wc/2, Hc/2);
            const tex = new THREE.CanvasTexture(c); try{ tex.encoding = THREE.sRGBEncoding; }catch(e){}
            tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter; tex.needsUpdate = true;
            const mat = new THREE.SpriteMaterial({ map: tex, depthTest: true, depthWrite: false });
            const sprite = new THREE.Sprite(mat);
            sprite.position.copy(pos);
            sprite.scale.set(baseScale, baseScale * (Hc / Wc) * 0.9, 1);
            qwertyLabelsGroup.add(sprite);
          }catch(e){ /* ignore single-label failures */ }
        });
      }catch(e){ console.warn('qwerty label generation failed', e); }
    }catch(e){ console.warn('user sticker generation failed', e); }
    // After keys are collected and backboard identified, generate runtime keymap via raycasting
    try{ if(backboardMesh && keyMeshes && keyMeshes.length){
      if(!jsonKeymapLoaded){
        generateRuntimeKeymap(backboardMesh, keyMeshes);
      } else {
        console.log('Skipping raycast keymap generation because keymap.json loaded');
      }
      applyPersistentHighlights();
    } }catch(e){ console.warn('generateRuntimeKeymap failed', e); }
    // Ensure all individual keys have scale 1
    safeRun(() => keyMeshes.forEach(k => { if (k && k.scale) k.scale.setScalar(1); }), 'key scale normalize');
    // Recenter origin after potential scaling
    const c = box.getCenter(new THREE.Vector3()); root.position.sub(c);
    // Recompute box after recenter to ensure framing updates for new geometry (e.g., pedals)
    const box2 = new THREE.Box3().setFromObject(root);
    fit(box2);
    // Refresh world-derived lanes after recenter so backboard mapping aligns
    computeKeyLanesFromWorld();
    console.log('GLB loaded. Final box size:', size, 'post-recenter size:', box2.getSize(new THREE.Vector3()));
    // If there are animations, prepare subclips and lock pose initially
    if(gltf.animations && gltf.animations.length){
      const clips = gltf.animations;
      animationMixer = new THREE.AnimationMixer(root);
      clips.forEach(clip=>{
        // Create subclips for requested ranges
        const subA = THREE.AnimationUtils.subclip(clip, (clip.name||'clip')+':A', 1, 140, LOCK_FPS);
        const subB = THREE.AnimationUtils.subclip(clip, (clip.name||'clip')+':B', 151, 300, LOCK_FPS);
        const actA = animationMixer.clipAction(subA); actA.setLoop(THREE.LoopOnce, 0); actA.clampWhenFinished = true; animActionsA.push(actA);
        const actB = animationMixer.clipAction(subB); actB.setLoop(THREE.LoopOnce, 0); actB.clampWhenFinished = true; animActionsB.push(actB);
        // Lock pose at frame 140 initially
        const baseAction = animationMixer.clipAction(clip);
        baseAction.play();
        const frameTime = LOCK_FRAME / LOCK_FPS;
        baseAction.time = Math.min(frameTime, clip.duration);
        animationMixer.update(0);
        baseAction.paused = true;
        console.log(`Prepared subclips for '${clip.name||'(unnamed)'}' and locked at frame ${LOCK_FRAME}`);
      });
    } else {
      console.log('No animations found to lock.');
    }
  },
  prog => {
    const pct = prog.total ? (prog.loaded / prog.total) * 100 : 0;
    HUD.textContent = `Loading GLB: ${pct.toFixed(1)}%`;
  },
  err => {
    console.error('GLB load FAILED', err);
    HUD.textContent = 'GLB load FAILED';
  }
);
// Resize listener
window.addEventListener('resize', ()=>{
  const w = canvas.parentElement.clientWidth; const h = Math.max(420, Math.floor(window.innerHeight*0.65));
  renderer.setSize(w,h,false); cam.aspect=w/h; cam.updateProjectionMatrix();
});
// ---- MIDI Parsing & Playback ----
function readVLQ(data, offset){
  let value=0; let i=offset; let byte;
  do { byte = data[i++]; value = (value<<7) | (byte & 0x7f); } while(byte & 0x80);
  return {value, next:i};
}
async function loadMIDI(urlOrArray){
  try {
    if(Array.isArray(urlOrArray)){
      const urls = urlOrArray;
      const fetched = await Promise.all(urls.map(async u=>{
        try { const r=await fetch(encodeURI(u)); if(!r.ok) throw new Error('HTTP '+r.status); return await r.arrayBuffer(); }
        catch(err){ console.warn('[MIDI] fetch failed for', u, err); return null; }
      }));
      const valid = fetched.filter(Boolean);
      if(valid.length===0) throw new Error('All MIDI fetches failed');
      // Parse off-main in small timeout to keep UI responsive
      setTimeout(()=>{
        const allEvents=[];
        let primaryTempoMap=null; let primaryTPQ=ticksPerQuarter;
        valid.forEach((ab, idx)=>{
          const {events, tempoMap:tm, ticksPerQuarter:tpq} = parseMIDIToEventList(new Uint8Array(ab));
          if(idx===0){ primaryTempoMap = tm; primaryTPQ = tpq; }
          allEvents.push(...events);
        });
        allEvents.sort((a,b)=>a.timeMs-b.timeMs);
        // Assign to globals
        tempoMap = primaryTempoMap || [];
        ticksPerQuarter = primaryTPQ || ticksPerQuarter;
        midiEvents = allEvents;
        sustainEventTimes = midiEvents.filter(e=> e.type==='cc64' && (e.value|0)>=64).map(e=> e.timeMs);
        // Post-process
        filterSentinelNotes();
        computeMidiActiveSpan();
        recomputeStretch();
        midiLoaded=true; midiError=false;
        console.log('[Track:'+currentTrackKey+'] MIDI merged from', valid.length, 'files; events:', midiEvents.length);
        updatePlayButton();
      },0);
    } else {
      const resp = await fetch(encodeURI(urlOrArray));
      if(!resp.ok) throw new Error('HTTP '+resp.status);
      const buf = await resp.arrayBuffer();
      // parse in timeout to avoid blocking paint
      setTimeout(()=>{ parseMIDI(new Uint8Array(buf)); midiLoaded=true; midiError=false; console.log('[Track:'+currentTrackKey+'] MIDI parsed:', midiEvents.length); updatePlayButton(); },0);
    }
  } catch(e){ console.error('MIDI load failed:', e); midiError=true; updatePlayButton(); }
}
function parseMIDIToEventList(bytes){
  // Two-pass parser: collect events in ticks and tempo changes, then map ticks->ms.
  let p=0;
  function readStr(n){ const s = String.fromCharCode(...bytes.slice(p,p+n)); p+=n; return s; }
  const header = readStr(4); if(header!=='MThd'){ console.error('Bad MIDI header'); return; }
  const hdrLen = (bytes[p]<<24)|(bytes[p+1]<<16)|(bytes[p+2]<<8)|bytes[p+3]; p+=4;
  const format = (bytes[p]<<8)|bytes[p+1]; p+=2;
  const nTracks = (bytes[p]<<8)|bytes[p+1]; p+=2;
  const localTPQ = (bytes[p]<<8)|bytes[p+1]; p+=2;
  p += hdrLen - 6;
  console.log('MIDI header', {format, nTracks, ticksPerQuarter: localTPQ});
  const eventsTicks = []; // {tick,type,note,velocity,chan,value}
  const tempoTicks = [{tick:0, tempo:tempoUsPerQuarter}];
  for(let track=0; track<nTracks; track++){
    const id = readStr(4); if(id!=='MTrk'){ console.warn('Non-track chunk', id); break; }
    const len = (bytes[p]<<24)|(bytes[p+1]<<16)|(bytes[p+2]<<8)|bytes[p+3]; p+=4;
    const end = p+len; let tick=0; let runningStatus=0;
    while(p<end){
      const {value:delta, next:nxt} = readVLQ(bytes,p); p=nxt; tick+=delta;
      let status = bytes[p];
      if(status < 0x80){ status = runningStatus; } else { p++; runningStatus = status; }
      if(status===0xff){
        const type = bytes[p++];
        const {value:mlen, next:n2} = readVLQ(bytes,p); p=n2;
        if(type===0x51 && mlen===3){
          const tempo = (bytes[p]<<16)|(bytes[p+1]<<8)|bytes[p+2];
          tempoTicks.push({tick, tempo});
        }
        p+=mlen; continue;
      }
      if(status===0xf0 || status===0xf7){ const {value:slen, next:n3} = readVLQ(bytes,p); p=n3+slen; continue; }
      const typeNib = status & 0xf0; const chan = status & 0x0f;
      if(typeNib===0x90 || typeNib===0x80){
        const note = bytes[p++]; const vel = bytes[p++];
        const isOn = (typeNib===0x90 && vel>0);
        eventsTicks.push({tick, type:isOn?'on':'off', note, velocity:vel, chan});
      } else if(typeNib===0xb0){
        const controller = bytes[p++]; const value = bytes[p++];
        if(controller===64){ // sustain pedal
          eventsTicks.push({tick, type:'cc64', value, chan});
        }
      } else {
        if(typeNib===0xc0 || typeNib===0xd0){ p+=1; } else { p+=2; }
      }
    }
  }
  // Build segments
  tempoTicks.sort((a,b)=>a.tick-b.tick);
  const localTempoMap = []; let accMs=0; let prevTick=0; let currentTempo=tempoTicks[0].tempo;
  localTempoMap.push({tick:0, timeMs:0, tempo:currentTempo});
  for(let i=1;i<tempoTicks.length;i++){
    const T=tempoTicks[i].tick; const dt=T-prevTick;
    accMs += (dt*currentTempo)/localTPQ/1000; prevTick=T; currentTempo=tempoTicks[i].tempo;
    localTempoMap.push({tick:T, timeMs:accMs, tempo:currentTempo});
  }
  function tickToMs(T){
    let idx=0; for(let i=localTempoMap.length-1;i>=0;i--){ if(localTempoMap[i].tick<=T){ idx=i; break; } }
    const seg=localTempoMap[idx]; return seg.timeMs + ( (T-seg.tick) * seg.tempo)/localTPQ/1000;
  }
  const localEvents = eventsTicks.map(e=>({ timeMs: tickToMs(e.tick), type:e.type, note:e.note, velocity:e.velocity, chan:e.chan, value:e.value }));
  localEvents.sort((a,b)=>a.timeMs-b.timeMs);
  return { events: localEvents, tempoMap: localTempoMap, ticksPerQuarter: localTPQ };
}
function parseMIDI(bytes){
  const {events, tempoMap:tm, ticksPerQuarter:tpq} = parseMIDIToEventList(bytes);
  midiEvents = events;
  tempoMap = tm;
  ticksPerQuarter = tpq;
  sustainEventTimes = midiEvents.filter(e=> e.type==='cc64' && (e.value|0)>=64).map(e=> e.timeMs);
  filterSentinelNotes();
  computeMidiActiveSpan();
  recomputeStretch();
  console.log('Tempo map (segments):', tempoMap);
  // Diagnostics for Baby: summarize MIDI duration
  if(currentTrackKey === 'baby'){
    let lastOff = 0; for(let i=midiEvents.length-1;i>=0;i--){ if(midiEvents[i].type==='off'){ lastOff = midiEvents[i].timeMs; break; } }
    const midiDur = (lastOff>midiFirstNoteMs) ? (lastOff - midiFirstNoteMs) : 0;
    console.log('[Diag:BABY] MIDI dur(ms)=', Math.round(midiDur), 'TPQ=', ticksPerQuarter, 'segments=', tempoMap.length);
  }
}
// Identify and remove the very first and very last short, inaudible notes
// as described by the user (e.g., velocity 1, very short duration),
// without affecting middle content.
const SENTINEL_VEL_MAX = 8;      // <= 8 considered inaudible
const SENTINEL_DUR_MS_MAX = 120; // <= 120ms considered short
function filterSentinelNotes(){
  sentinelFilteredCount = 0;
  // Pair note-ons to offs
  const active = new Map(); // key "chan:note" -> {idx,timeMs,velocity}
  const pairs = []; // {onIdx, offIdx, on, off, dur}
  for(let i=0;i<midiEvents.length;i++){
    const ev = midiEvents[i];
    if(ev.type==='on'){
      const key = `${ev.chan}:${ev.note}`;
      active.set(key, {idx:i, timeMs:ev.timeMs, velocity:ev.velocity});
    } else if(ev.type==='off'){
      const key = `${ev.chan}:${ev.note}`;
      const on = active.get(key);
      if(on){
        const dur = Math.max(0, ev.timeMs - on.timeMs);
        pairs.push({onIdx:on.idx, offIdx:i, on: midiEvents[on.idx], off: ev, dur});
        active.delete(key);
      }
    }
  }
  if(pairs.length===0) return;
  // earliest candidate
  const earliest = pairs.reduce((a,b)=> (a.on.timeMs <= b.on.timeMs ? a : b));
  // latest candidate by off time
  const latest = pairs.reduce((a,b)=> (a.off.timeMs >= b.off.timeMs ? a : b));
  const toRemoveIdx = new Set();
  function consider(pair){
    if(pair.on.velocity <= SENTINEL_VEL_MAX && pair.dur <= SENTINEL_DUR_MS_MAX){
      toRemoveIdx.add(pair.onIdx);
      toRemoveIdx.add(pair.offIdx);
    }
  }
  consider(earliest);
  if(latest !== earliest) consider(latest);
  if(toRemoveIdx.size){
    midiEvents = midiEvents.filter((_,i)=> !toRemoveIdx.has(i));
    sentinelFilteredCount = toRemoveIdx.size/2; // pairs count
    // recompute midiFirstNoteMs as earliest remaining on
    midiFirstNoteMs = 0;
    for(const ev of midiEvents){ if(ev.type==='on'){ midiFirstNoteMs = ev.timeMs; break; } }
  } else {
    // no filtering; compute first note if not set
    for(const ev of midiEvents){ if(ev.type==='on'){ midiFirstNoteMs = ev.timeMs; break; } }
  }
}
function computeMidiActiveSpan(){
  // With sentinels removed, first ON is midiFirstNoteMs; find last OFF
  let lastOff = 0;
  for(let i=midiEvents.length-1;i>=0;i--){
    const ev = midiEvents[i];
    if(ev.type==='off'){ lastOff = ev.timeMs; break; }
  }
  if(midiFirstNoteMs>0 && lastOff>midiFirstNoteMs){
    midiActiveDurationMs = lastOff - midiFirstNoteMs;
  } else {
    midiActiveDurationMs = 0;
  }
}
function recomputeStretch(){
  if(audioActiveDurationMs>0 && midiActiveDurationMs>0){
    const raw = audioActiveDurationMs / midiActiveDurationMs;
    const clamped = Math.min(1+STRETCH_CLAMP, Math.max(1-STRETCH_CLAMP, raw));
    midiStretch = clamped;
  } else {
    midiStretch = 1.0;
  }
  // Stretch impacts adjusted times; rebuild fall schedule if MIDI already loaded
}
function startMIDIPlayback(){
  if(!midiLoaded||playingMIDI||!audioCtx) return;
  // Ensure audio context is running (browser gesture requirement)
  if(audioCtx.state !== 'running'){
    safeRun(() => audioCtx.resume(), 'audioCtx resume');
  }
  // Remove lingering glow from previous session before starting new playback
  clearAllKeyGlow();
  // Hard stop anything lingering and reset position to start
  disposeAudioSource('startMIDIPlayback cleanup');
  savedAudioPosSec = 0;
  midiIndex = 0;
  resetKeys();
  const offsetMs = getSyncOffsetMs();
  const userOffsetSec = offsetMs/1000;
  const firstNoteSec = (midiFirstNoteMs||0)/1000;
  const lead = 0.2; // schedule slightly in the future for stability
  const now = audioCtx.currentTime;
  // If no sampled instrument is loaded, provide only visual feedback and do not run oscillator fallback
  if(!instrumentPlayer){
    if(mesh){ const base = (isBlackKey(mesh)? BLACK_MAX : WHITE_MAX) * KEY_PRESS_SIGN; mesh.rotation.x = base * 0.6; }
    return;
  }
  const t0 = now + lead;
  const tAudio = t0 + Math.max(userOffsetSec, 0);
  const tMidiZero = t0 + Math.max(-userOffsetSec, 0);
  // Align so that first MIDI note occurs exactly at tMidiZero
  midiStartCtxTime = tMidiZero - firstNoteSec;
  // Start audio at tAudio, skipping detected leading silence internally
  startAudio((tAudio - now)*1000);
  audioStartCtxTime = tAudio;
  playingMIDI=true; midiIndex=0;
  console.log('Playback start (audioCtx)', {offsetMs, firstNoteSec, t0, tAudio, tMidiZero, midiStartCtxTime});
}
function advanceMIDI(elapsedMs){
  if(midiIndex>=midiEvents.length) return;
  while(midiIndex < midiEvents.length){
    const ev = midiEvents[midiIndex];
    const adjTime = midiFirstNoteMs + (ev.timeMs - midiFirstNoteMs) * (midiStretch / Math.max(1e-6, currentPlaybackRate));
    if(adjTime > elapsedMs) break;
    midiIndex++;
    if(ev.type==='on' || ev.type==='off'){
      const state = keyAnimState.get(ev.note);
      if(!state) continue;
      const mesh = state.mesh;
      if(ev.type==='on'){
        const base = (isBlackKey(mesh)? BLACK_MAX : WHITE_MAX) * KEY_PRESS_SIGN;
        const vel = Math.max(VELOCITY_MIN, ev.velocity);
        const depthScale = (vel - VELOCITY_MIN) / (VELOCITY_MAX - VELOCITY_MIN);
        const target = base * (0.55 + 0.45 * depthScale);
        state.phase='press'; state.startMs=elapsedMs; state.fromAngle=mesh.rotation.x; state.targetAngle=target;
        // Apply glow while the note is active
        applyKeyGlow(mesh, ev.note, true);
        // Mark active note for backboard overlay
        const nnum = Number(ev.note);
        activeNotes.set(nnum, { velocity: Math.max(0, Math.min(1, ev.velocity/127)), tOn: performance.now() });
        activeNoteSet.add(nnum);
      } else {
        state.phase='release'; state.startMs=elapsedMs; state.fromAngle=mesh.rotation.x; state.targetAngle=0;
        // Remove glow when the note-off occurs (respect overlapping notes via counter)
        applyKeyGlow(mesh, ev.note, false);
        // Remove from overlay
        const deln = Number(ev.note);
        activeNotes.delete(deln);
        activeNoteSet.delete(deln);
      }
    } else if(ev.type==='cc64'){
      if(!sustainPedalMesh) continue;
      const pressed = (ev.value|0) >= 64;
      if(pressed){
        // If previous release was still mid-way, force full rest (bounce up) before press
        if(sustainAnim.phase==='release'){
          sustainPedalMesh.rotation.x = 0;
          sustainAnim.fromAngle = 0;
        }
        // Optional quick bounce: small upward overshoot then press
        sustainAnim.phase='press';
        sustainAnim.startMs=elapsedMs;
        sustainAnim.fromAngle = sustainPedalMesh.rotation.x || 0;
        sustainAnim.targetAngle = PEDAL_MAX_ANGLE;
      } else {
        // Release logic with lookahead: if next press soon, use fast release
        const nextPress = sustainEventTimes.find(t => t>ev.timeMs);
        const soon = nextPress!==undefined && (nextPress - ev.timeMs) < PEDAL_LOOKAHEAD_MS;
        sustainAnim.phase='release';
        sustainAnim.startMs=elapsedMs;
        sustainAnim.fromAngle = sustainPedalMesh.rotation.x || 0;
        sustainAnim.targetAngle = 0;
        if(soon){
          // accelerate by temporarily adjusting constants (store original?)
          // We simulate by snapping closer to 0 immediately
          sustainPedalMesh.rotation.x = Math.max(0, sustainPedalMesh.rotation.x - PEDAL_BOUNCE_ANGLE);
        }
        // Once pedal goes up, apply sustain release to voices
        applySustainState();
      }
    }
  }
}
function updateKeyAnimations(){
  // elapsed MIDI time using context clock
  const elapsed = audioCtx ? (audioCtx.currentTime - midiStartCtxTime) * 1000 : 0;
  keyAnimState.forEach(st => {
    const mesh = st.mesh; if(!mesh) return;
    let dur=0;
    if(st.phase==='press') dur=PRESS_ATTACK_MS; else if(st.phase==='release') dur=RELEASE_DECAY_MS; else return;
    const t = (elapsed - st.startMs)/dur;
    if(t>=1){
      mesh.rotation.x = st.targetAngle;
      st.fromAngle=st.targetAngle;
      st.phase = (st.phase==='press')? 'held':'idle';
      return;
    }
    // smoothstep easing
    const e = t*t*(3-2*t);
    mesh.rotation.x = st.fromAngle + (st.targetAngle - st.fromAngle) * e;
  });
  // Sustain pedal easing
  if(sustainPedalMesh && sustainAnim.phase!=='idle'){
    const dur = sustainAnim.phase==='press' ? PEDAL_PRESS_MS : PEDAL_RELEASE_MS;
    const t = Math.max(0, (elapsed - sustainAnim.startMs)/Math.max(1,dur));
    if(t>=1){
      sustainPedalMesh.rotation.x = sustainAnim.targetAngle;
      sustainAnim.fromAngle = sustainAnim.targetAngle;
      sustainAnim.phase = (sustainAnim.phase==='press') ? 'held' : 'idle';
    } else {
      const e2 = t*t*(3-2*t);
      sustainPedalMesh.rotation.x = sustainAnim.fromAngle + (sustainAnim.targetAngle - sustainAnim.fromAngle) * e2;
    }
  }
}

// --- Backboard overlay rendering (note bars) ---
function renderBackboardOverlay(){
  if(!backboardCanvas || !backboardCtx || !backboardTexture) return;
  const ctx = backboardCtx; const W = backboardCssW, H = backboardCssH; // logical CSS-pixel drawing units
  try{ ctx.imageSmoothingEnabled = true; }catch(e){}
  // Use canvas-derived aspect (width/height) for visual compensation
  try{ backboardSurfaceAspect = (W / Math.max(1, H)); }catch(e){}
  // Clear canvas and draw orange background to confirm the overlay is visible
  ctx.clearRect(0,0,W,H);
  if(uvDebugMode){
    drawUvTestCard(ctx, W, H);
  }else{
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);
  }

  // Draw selected UV map mode if enabled
  if(backboardUVMapMode === 'u'){
    drawUMap(backboardCanvas);
  } else if(backboardUVMapMode === 'v'){
    drawVMap(backboardCanvas);
  } else if(backboardUVMapMode === 'checker'){
    drawCheckerMap(backboardCanvas);
  } else {
    // none: keep solid black background (already filled above)
  }

  // Instrument buttons UI (spread horizontally across the screen)
  // Draw panels
  try{
    panelHitRects = [];
    const panelW = W * 0.42;
    const panelH = H * 0.8;
    const panelY = (H - panelH) / 2;
    const leftX = W * 0.04;
    const rightX = W - panelW - leftX;
    const pad = panelW * 0.04;
    const btnH = (panelH - pad * 2) / 8; // 6 buttons + 2 arrows
    const fontSize = Math.max(14, Math.round(btnH * 0.38));
    const drawPanel = (panelId, x0)=>{
      const state = panelState[panelId];
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.strokeStyle = '#8df7d4';
      ctx.lineWidth = Math.max(2, W * 0.0018);
      const radius = 12;
      if(typeof ctx.roundRect === 'function'){
        ctx.beginPath(); ctx.roundRect(x0, panelY, panelW, panelH, radius); ctx.fill(); ctx.stroke();
      } else {
        ctx.fillRect(x0, panelY, panelW, panelH); ctx.strokeRect(x0, panelY, panelW, panelH);
      }
      ctx.fillStyle = '#fff';
      ctx.font = `${fontSize}px "Source Sans 3", system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Arrow up
      const upRect = { x: x0 + pad, y: panelY + pad, w: panelW - pad*2, h: btnH };
      ctx.fillStyle = panelHover === `${panelId}-up` ? '#1c9' : '#222';
      ctx.fillRect(upRect.x, upRect.y, upRect.w, upRect.h);
      ctx.fillStyle = '#fff';
      ctx.fillText('▲', upRect.x + upRect.w/2, upRect.y + upRect.h/2);
      panelHitRects.push({ panel: panelId, type: 'arrow-up', id: `${panelId}-up`, rect: upRect });
      // Buttons (6 visible)
      const startIdx = Math.max(0, Math.min(INSTRUMENT_BUTTONS.length - 6, state.offset));
      for(let i=0;i<6;i++){
        const idx = startIdx + i;
        const btn = INSTRUMENT_BUTTONS[idx];
        const y = panelY + pad + btnH * (i+1);
        const rect = { x: x0 + pad, y, w: panelW - pad*2, h: btnH };
        const selected = state.selected === btn.id;
        const hover = panelHover === `${panelId}-${btn.id}`;
        ctx.fillStyle = selected ? '#ffb347' : (hover ? '#244' : '#111');
        ctx.strokeStyle = selected ? '#ffda8c' : '#0f9';
        if(typeof ctx.roundRect === 'function'){
          ctx.beginPath(); ctx.roundRect(rect.x, rect.y, rect.w, rect.h, 8); ctx.fill(); ctx.stroke();
        } else {
          ctx.fillRect(rect.x, rect.y, rect.w, rect.h); ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        }
        ctx.fillStyle = '#fff';
        ctx.fillText(btn.label, rect.x + rect.w/2, rect.y + rect.h/2);
        panelHitRects.push({ panel: panelId, type: 'button', id: btn.id, rect });
      }
      // Arrow down
      const downRect = { x: x0 + pad, y: panelY + panelH - pad - btnH, w: panelW - pad*2, h: btnH };
      ctx.fillStyle = panelHover === `${panelId}-down` ? '#1c9' : '#222';
      ctx.fillRect(downRect.x, downRect.y, downRect.w, downRect.h);
      ctx.fillStyle = '#fff';
      ctx.fillText('▼', downRect.x + downRect.w/2, downRect.y + downRect.h/2);
      panelHitRects.push({ panel: panelId, type: 'arrow-down', id: `${panelId}-down`, rect: downRect });
      ctx.restore();
    };
    drawPanel('left', leftX);
    drawPanel('right', rightX);
  }catch(e){ /* ignore draw panel errors */ }
  // Draw 12 circles horizontally centered
  try{
    const n = 12;
    const radius = Math.max(6, Math.min(W, H) * 0.03);
    const left = W * 0.05;
    const right = W * 0.95;
    const span = right - left;
    const y = H * 0.5;
    ctx.strokeStyle = '#ff6';
    ctx.lineWidth = Math.max(2, W * 0.002);
    for(let i=0;i<n;i++){
      const t = n>1 ? i/(n-1) : 0.5;
      const x = left + span * t;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI*2);
      ctx.stroke();
    }
  }catch(e){ /* ignore */ }

  // Ensure texture is updated for three.js
  backboardTexture.needsUpdate = true;
}
// Update camera-dependent transforms (runs every frame)
function updateViewDrivenTransforms(dt){
  if(!tabletStandMesh || !root) return;
  // ensure dt is defined (fallback to small step)
  dt = (typeof dt === 'number' && isFinite(dt) && dt>0) ? dt : Math.min(Math.max(clock.getDelta(), 0.001), 0.1);
  const center = new THREE.Vector3();
  new THREE.Box3().setFromObject(root).getCenter(center);
  const toCam = new THREE.Vector3().subVectors(cam.position, center).normalize();
  const front = new THREE.Vector3(0,0,1);
  const up = new THREE.Vector3(0,1,0);
  const frontDot = THREE.MathUtils.clamp(front.dot(toCam), -1, 1);
  const upDot = THREE.MathUtils.clamp(up.dot(toCam), -1, 1);
  const wFront = Math.max(0, frontDot);
  const wTop = Math.max(0, upDot);
  const denom = wFront + wTop;
  let angle = 0;
  if(denom>1e-5){
    const tWeight = wFront/denom; // 0 top/back -> 0deg, 1 front -> 90deg
    angle = THREE.MathUtils.degToRad(90 * tWeight);
  }
  // set target and smoothly interpolate current applied angle
  tabletStandTargetAngle = angle;
  // frame-rate independent smoothing using exponential lerp
  const alpha = 1 - Math.exp(-TABLET_ROTATION_LERP_SPEED * dt);
  tabletStandCurrentAngle += (tabletStandTargetAngle - tabletStandCurrentAngle) * alpha;
  // Dead-zone snapping to avoid micro-oscillation when camera damping causes tiny target jitter
  const EPSILON = 0.0025; // ~0.14 degrees
  if (Math.abs(tabletStandTargetAngle - tabletStandCurrentAngle) < EPSILON) {
    tabletStandCurrentAngle = tabletStandTargetAngle;
  }
  // Hysteresis: only update target if camera movement produces a noticeable change
  // (helps when controls damping slightly toggles the desired angle back/forth)
  // Compute desired angle again for hysteresis check (re-evaluate from center/cam)
  // (Note: 'angle' variable above is the freshly computed desired angle assigned to tabletStandTargetAngle)
  // Cap rate of change per frame to avoid overshoot/jitter
  const maxDelta = TABLET_MAX_ROT_SPEED * dt;
  const delta = tabletStandCurrentAngle - tabletStandTargetAngle;
  // enforce max rate on current->target convergence (prevent sudden micro oscillation)
  if (Math.abs(delta) > maxDelta) {
    const sign = delta > 0 ? 1 : -1;
    tabletStandCurrentAngle = tabletStandTargetAngle + sign * maxDelta;
  }
  tabletStandMesh.rotation.x = tabletStandCurrentAngle;
}

// Generate authoritative keymap by raycasting key edge midpoints to the screen mesh
function generateRuntimeKeymap(screenMesh, keys){
  if(!screenMesh || !keys || !keys.length) return;
  const ray = new THREE.Raycaster();
  ray.near = 0;
  ray.far = 10000;
  // ensure world matrices are current
  screenMesh.updateWorldMatrix(true, false);
  const screenBox = new THREE.Box3().setFromObject(screenMesh);
  const screenCenter = screenBox.getCenter(new THREE.Vector3());
  // compute a stable world-space normal from the mesh geometry
  function computeWorldNormalFromFirstTriangle(mesh){
    try{
      const geom = mesh.geometry;
      if(!geom || !geom.attributes || !geom.attributes.position) return null;
      const pos = geom.attributes.position;
      if(pos.count < 3) return null;
      const a = new THREE.Vector3(); const b = new THREE.Vector3(); const c = new THREE.Vector3();
      const aw = new THREE.Vector3(); const bw = new THREE.Vector3(); const cw = new THREE.Vector3();
      a.fromBufferAttribute(pos, 0); b.fromBufferAttribute(pos, 1); c.fromBufferAttribute(pos, 2);
      aw.copy(a).applyMatrix4(mesh.matrixWorld);
      bw.copy(b).applyMatrix4(mesh.matrixWorld);
      cw.copy(c).applyMatrix4(mesh.matrixWorld);
      const n = new THREE.Vector3();
      n.subVectors(bw, aw).cross(new THREE.Vector3().subVectors(cw, aw)).normalize();
      if(n.length() === 0) return null;
      return n;
    }catch(e){ return null; }
  }
  // Prefer a reliable screen normal computed from the mesh world quaternion.
  // Try common local axes in order: +Z, -Z, +Y, -Y transformed to world space.
  const q = new THREE.Quaternion(); screenMesh.getWorldQuaternion(q);
  const candidates = [
    new THREE.Vector3(0,0,1).applyQuaternion(q),
    new THREE.Vector3(0,0,-1).applyQuaternion(q),
    new THREE.Vector3(0,1,0).applyQuaternion(q),
    new THREE.Vector3(0,-1,0).applyQuaternion(q)
  ];
  let screenNormal = null;
  // We'll pick the first candidate that yields hits for a sample key; fallback to camera->center direction
  const sampleMesh = keys[0];
  for(const cand of candidates){
    if(!cand) continue;
    const dirTest = cand.clone().normalize();
    // choose a sample origin from sampleMesh bounds
    const bbTest = new THREE.Box3().setFromObject(sampleMesh);
    const midYt = (bbTest.min.y + bbTest.max.y) * 0.5; const midZt = (bbTest.min.z + bbTest.max.z) * 0.5;
    const centerTest = bbTest.getCenter(new THREE.Vector3());
    const leftTest = new THREE.Vector3(bbTest.min.x, midYt, midZt).addScaledVector(dirTest, -0.01);
    ray.set(leftTest, dirTest);
    const hits = ray.intersectObject(screenMesh, true);
    if(hits && hits.length) { screenNormal = dirTest; break; }
  }
  if(!screenNormal){ screenNormal = new THREE.Vector3().subVectors(cam.position, screenCenter).normalize(); }
  keyByNote.clear();
  for(const mesh of keys){
    if(!mesh) continue;
    try{
      const bb = new THREE.Box3().setFromObject(mesh);
      const min = bb.min; const max = bb.max;
      const midY = (min.y + max.y) * 0.5; const midZ = (min.z + max.z) * 0.5;
      const leftWorld = new THREE.Vector3(min.x, midY, midZ);
      const rightWorld = new THREE.Vector3(max.x, midY, midZ);
      const keyCenter = bb.getCenter(new THREE.Vector3());
      // Use the precomputed screen normal as the ray direction for stable horizontal mapping
      const toScreen = new THREE.Vector3().subVectors(screenCenter, keyCenter);
      let dir = screenNormal.clone();
      if(dir.dot(toScreen) < 0) dir.negate();
      // Nudge origins slightly toward the screen to avoid starting behind the plane
      const EPS = 0.01;
      const originL = leftWorld.clone().addScaledVector(dir, -EPS);
      const originR = rightWorld.clone().addScaledVector(dir, -EPS);
      // cast from left
      ray.set(originL, dir);
      let iL = ray.intersectObject(screenMesh, true);
      // cast from right
      ray.set(originR, dir);
      let iR = ray.intersectObject(screenMesh, true);
      // Log hit counts for diagnostics
      try{ console.log('NOTE', mesh.name, 'note?', midiNameToNumber(mesh.name), 'hitsL', (iL?iL.length:0), 'hitsR', (iR?iR.length:0), 'screenMesh.type', screenMesh.type); }catch(e){}
      let uL = null, uR = null;
      if(iL && iL.length && iL[0].uv) uL = iL[0].uv.x;
      if(iR && iR.length && iR[0].uv) uR = iR[0].uv.x;
      // fallback: try casting from center if edges missed
      if(uL==null || uR==null){
        ray.set(keyCenter, dir);
        const ic = ray.intersectObject(screenMesh, true);
        if(ic && ic.length && ic[0].uv){ const uc = ic[0].uv.x; if(uL==null) uL = uc; if(uR==null) uR = uc; }
      }
      if(uL==null || uR==null) {
        // nothing hit — skip
        continue;
      }
      // clamp
      uL = Math.min(1, Math.max(0, uL));
      uR = Math.min(1, Math.max(0, uR));
      let u0 = Math.min(uL, uR), u1 = Math.max(uL, uR);
      const note = midiNameToNumber(mesh.name);
      // If the backboard UVs were mirrored horizontally, mirror per-key lanes
      try{
        if(backboardUVCorrection && backboardUVCorrection.mirrorU){
          const ub = backboardUVBounds || { uMin: 0, uMax: 1 };
          const nu0 = (ub.uMin + ub.uMax) - u1;
          const nu1 = (ub.uMin + ub.uMax) - u0;
          u0 = Math.min(nu0, nu1); u1 = Math.max(nu0, nu1);
        }
      }catch(e){ /* ignore mirror failures */ }
      if(Number.isInteger(note)){
          keyByNote.set(Number(note), { u0, u1, name: mesh.name });
      }
    }catch(e){ console.warn('raycast keymap fail for', mesh.name, e); }
  }
  // Harden generated keymap: detect ordering/inversions and auto-flip U if needed
  try{
    const entries = Array.from(keyByNote.entries()).map(([note, obj])=>({ note: Number(note), u0: obj.u0, u1: obj.u1, mid: (obj.u0 + obj.u1) * 0.5 }));
    entries.sort((a,b)=>a.note - b.note);
    // count inversions (monotonicity violations)
    let inversions = 0;
    for(let i=1;i<entries.length;i++) if(entries[i].mid < entries[i-1].mid) inversions++;
    // detect sharp decreases (large backward jumps) as another heuristic
    let sharpDrops = 0; let prev = entries.length ? entries[0].mid : 0;
    for(let i=1;i<entries.length;i++){ const cur = entries[i].mid; if(cur + 0.15 < prev) sharpDrops++; prev = cur; }
    if(inversions > Math.max(5, Math.floor(entries.length * 0.03)) || sharpDrops > Math.max(1, Math.floor(entries.length * 0.02))){
      // flip U for all keys: u0' = 1 - u1, u1' = 1 - u0
      keyByNote.forEach((v,k)=>{
        const nu0 = 1 - v.u1; const nu1 = 1 - v.u0; v.u0 = nu0; v.u1 = nu1; keyByNote.set(k, v);
      });
      console.warn('Runtime keymap: detected non-monotonic U mids; auto-flipped U coordinates for all keys');
    }
  }catch(e){ console.warn('Keymap hardening check failed', e); }
  RAYCAST_KEYMAP_READY = keyByNote.size > 0;
  console.log('Runtime keymap generated, keys:', keyByNote.size, 'ready=', RAYCAST_KEYMAP_READY);
  try{ requestBackboardRedraw(); }catch(e){}
}
// Hook play button if exists
const playBtn = document.getElementById('playPerformance');
if(playBtn){
  playBtn.addEventListener('click', ()=>{
    togglePlayPause();
  });
}
const trackBabyBtn = document.getElementById('trackBaby');
if(trackBabyBtn){ trackBabyBtn.addEventListener('click', ()=> selectTrack('baby')); }
const trackRaisinsBtn = document.getElementById('trackRaisins');
if(trackRaisinsBtn){ trackRaisinsBtn.addEventListener('click', ()=> selectTrack('raisins')); }
const trackForestsBtn = document.getElementById('trackForests');
if(trackForestsBtn){ trackForestsBtn.addEventListener('click', ()=> selectTrack('forests')); }
const restartBtn = document.getElementById('restartPlayback');
if(restartBtn){ restartBtn.addEventListener('click', ()=> restartFromBeginning()); }
const rateSel = document.getElementById('playbackRate');
if(rateSel){ rateSel.addEventListener('change', ()=> setPlaybackRate(parseFloat(rateSel.value||'1'))); }
// Animation buttons
const animA = document.getElementById('animRangeA');
const animB = document.getElementById('animRangeB');
if(animA){ animA.addEventListener('click', ()=> playAnimRange('A')); }
if(animB){ animB.addEventListener('click', ()=> playAnimRange('B')); }
// Initialize button label
updatePlayButton();
updateTrackButtons();
// Initial default track load
selectTrack(currentTrackKey);
// ---- Audio loading ----
async function loadAudio(url){
  try {
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const resp = await fetch(encodeURI(url));
    if(!resp.ok) throw new Error('Audio HTTP '+resp.status);
    const arr = await resp.arrayBuffer();
    audioBuffer = await audioCtx.decodeAudioData(arr);
    const trimRms = detectLeadingSilence(audioBuffer);
    const trimEnergy = detectOnsetByEnergy(audioBuffer);
    // Be conservative: skip at least as much as either detector suggests
    audioTrimMs = Math.min(MAX_TRIM_MS, Math.max(Math.max(trimRms,0), Math.max(trimEnergy,0)));
    // Disable leading trim for 'Forests' track per request
    if(currentTrackKey === 'forests') {
      audioTrimMs = 0;
    }
    // For Baby: new exports are perfectly aligned; apply NO trim
    if(currentTrackKey === 'baby') {
      audioTrimMs = 0;
    }
    // trailing end detection to get active duration
    const trailMs = detectTrailingSilence(audioBuffer);
    const totalMs = audioBuffer.duration*1000;
    const endActiveMs = Math.max(audioTrimMs, totalMs - trailMs);
    audioActiveDurationMs = Math.max(0, endActiveMs - audioTrimMs);
    recomputeStretch();
    localStorage.setItem('audioLeadTrimMs', String(audioTrimMs));
    audioReady=true; audioError=false; console.log('[Track:'+currentTrackKey+'] Audio loaded trimMs=', audioTrimMs.toFixed(1)); updatePlayButton();
    // Diagnostics for Baby: summarize audio vs MIDI duration and raw stretch
    if(currentTrackKey === 'baby'){
      console.log('[Diag:BABY] Audio total(ms)=', Math.round(totalMs), 'active(ms)=', Math.round(audioActiveDurationMs), 'trim(ms)=', Math.round(audioTrimMs));
      if(midiActiveDurationMs>0){
        const raw = audioActiveDurationMs / midiActiveDurationMs;
        console.log('[Diag:BABY] raw stretch audio/midi =', raw.toFixed(6));
      }
    }
  } catch(e){ console.error('Audio load failed', e); audioError=true; updatePlayButton(); }
}
async function loadTrackAudio(candidates){
  if(!Array.isArray(candidates) || candidates.length===0){ audioError=true; updatePlayButton(); return; }
  console.log('[loadTrackAudio] candidates=', candidates);
  for(let i=0;i<candidates.length;i++){
    const url = candidates[i];
    const resolved = (window && window.mediaUrl) ? window.mediaUrl(url) : url;
    audioReady=false; audioError=false;
    try {
      await loadAudio(resolved);
      if(audioReady){
        console.log('[Track:'+currentTrackKey+'] Using audio source:', resolved);
        return;
      }
    } catch(e){
      console.warn('[loadTrackAudio] candidate failed', resolved, e);
    }
  }
  audioError=true; audioReady=false; console.error('[Track:'+currentTrackKey+'] All audio candidates failed'); updatePlayButton();
}
function startAudio(delayMs=0){
  if(!audioReady||audioPlaying) return;
  // Ensure no overlapping sources
  disposeAudioSource('startAudio cleanup');
  audioSource = audioCtx.createBufferSource();
  audioSource.buffer = audioBuffer;
  audioSource.playbackRate.setValueAtTime(currentPlaybackRate, audioCtx.currentTime);
  audioSource.connect(audioCtx.destination);
  const when = audioCtx.currentTime + Math.max(0, delayMs)/1000;
  const offset = Math.max(0, (audioTrimMs/1000) + savedAudioPosSec);
  audioSource.onended = ()=>{ audioPlaying=false; playingMIDI=false; savedAudioPosSec=0; resetKeys(); clearAllKeyGlow(); updatePlayButton(); };
  audioSource.start(when, offset);
  audioPlaying=true;
}
function detectLeadingSilence(buffer){
  try {
    const ch = buffer.getChannelData(0);
    const len = ch.length;
    let idx=0;
    while(idx < len){
      const end = Math.min(idx+TRIM_WINDOW_SAMPLES, len);
      let sumSq=0;
      for(let i=idx;i<end;i++){ const v=ch[i]; sumSq += v*v; }
      const rms = Math.sqrt(sumSq/(end-idx));
      if(rms > TRIM_THRESHOLD) break;
      idx = end;
      if((idx/buffer.sampleRate)*1000 > MAX_TRIM_MS) break;
    }
    const ms = Math.min(MAX_TRIM_MS, (idx/buffer.sampleRate)*1000);
    return ms;
  } catch(e){ console.warn('detectLeadingSilence failed', e); return 0; }
}
function detectTrailingSilence(buffer){
  try {
    const ch = buffer.getChannelData(0);
    const len = ch.length;
    let idx=len;
    while(idx > 0){
      const start = Math.max(0, idx-TRIM_WINDOW_SAMPLES);
      let sumSq=0; const count = idx-start;
      for(let i=start;i<idx;i++){ const v=ch[i]; sumSq += v*v; }
      const rms = Math.sqrt(sumSq/Math.max(1,count));
      if(rms > TRIM_THRESHOLD) break;
      idx = start;
      const elapsedMs = ((len-idx)/buffer.sampleRate)*1000;
      if(elapsedMs > MAX_TRIM_MS) break;
    }
    const ms = Math.min(MAX_TRIM_MS, ((len-idx)/buffer.sampleRate)*1000);
    return ms;
  } catch(e){ console.warn('detectTrailingSilence failed', e); return 0; }
}
// Short-time energy onset detection
function detectOnsetByEnergy(buffer){
  try {
    const sr = buffer.sampleRate;
    const ch0 = buffer.getChannelData(0);
    const ch1 = buffer.numberOfChannels>1 ? buffer.getChannelData(1) : null;
    const frame = 1024; const hop = 512;
    const n = Math.floor((ch0.length - frame)/hop);
    const energy = new Float32Array(Math.max(0,n));
    let maxE = 0;
    for(let i=0;i<n;i++){
      let sum=0; const off=i*hop;
      for(let k=0;k<frame;k++){
        const s0 = ch0[off+k]||0; const s1 = ch1? ch1[off+k] : 0;
        const s = (s0 + s1)*0.5; sum += s*s;
      }
      const e = sum/frame; energy[i]=e; if(e>maxE) maxE=e;
    }
    // Normalize and compute flux
    const flux = new Float32Array(energy.length);
    for(let i=1;i<energy.length;i++){
      const d = Math.max(0, energy[i]-energy[i-1]);
      flux[i] = d;
    }
    // Moving average baseline
    const win=8; let bestIdx=0;
    for(let i=win;i<flux.length;i++){
      let mean=0, varsum=0;
      for(let j=i-win;j<i;j++) mean += flux[j];
      mean/=win;
      for(let j=i-win;j<i;j++){ const dv=flux[j]-mean; varsum += dv*dv; }
      const std = Math.sqrt(varsum/win) || 1e-6;
      const z = (flux[i]-mean)/std;
      // Require energy also above small threshold
      if(z>3 && energy[i]> (0.005*maxE)){
        bestIdx = i; break;
      }
    }
    const ms = Math.min(MAX_TRIM_MS, (bestIdx*hop)/sr*1000);
    return ms||0;
  } catch(e){ console.warn('detectOnsetByEnergy failed', e); return 0; }
}
function selectTrack(key){
  if(!TRACKS[key]){ console.warn('Unknown track', key); return; }
  currentTrackKey = key;
  console.log('[selectTrack]', key, TRACKS[key]);
  // Stop current playback and reset state
  disposeAudioSource('selectTrack cleanup');
  audioPlaying=false; playingMIDI=false;
  savedAudioPosSec=0; midiIndex=0; midiLoaded=false; audioReady=false; midiError=false; audioError=false;
  midiEvents=[]; midiFirstNoteMs=0; midiActiveDurationMs=0; midiStretch=1.0; sentinelFilteredCount=0;
  updatePlayButton(); resetKeys();
  clearAllKeyGlow();
  // Load assets for track
  const t = TRACKS[key];
  loadTrackAudio(t.audioCandidates || [t.audio]);
  loadMIDI(t.midi);
  updateTrackButtons();
}
function updateTrackButtons(){
  const all = [
    document.getElementById('trackBaby'),
    document.getElementById('trackRaisins'),
    document.getElementById('trackForests')
  ];
  all.forEach(btn=>{
    if(!btn) return;
    const isActive = btn.dataset.track === currentTrackKey;
    btn.style.background = isActive ? 'rgba(90,200,160,0.6)' : 'rgba(255,255,255,0.15)';
    btn.style.color = '#fff';
    btn.style.border = isActive ? '1px solid #6ff' : '1px solid #444';
  });
}
// ---- Player controls logic ----
function updatePlayButton(){
  const btn = document.getElementById('playPerformance');
  if(!btn) return;
  if(audioError || midiError){
    btn.textContent = 'Load Error';
    btn.disabled = true; return;
  }
  btn.textContent = (audioPlaying||playingMIDI) ? 'Pause' : 'Play';
  btn.disabled = !midiLoaded || !audioReady;
}
function togglePlayPause(){
  if(!audioCtx || !audioReady || !midiLoaded){ return; }
  if(audioPlaying){
    // Pause: capture position, stop source, freeze MIDI index and clock origin
    const now = audioCtx.currentTime;
    const playedSec = (now - audioStartCtxTime) * currentPlaybackRate;
    savedAudioPosSec += Math.max(0, playedSec);
    disposeAudioSource('togglePlayPause cleanup');
    audioPlaying=false; playingMIDI=false; // will resume from savedAudioPosSec
    clearAllKeyGlow();
    updatePlayButton();
  } else {
    // If starting fresh (no saved position), use full alignment path
    if(savedAudioPosSec===0){
      startMIDIPlayback();
      updatePlayButton();
    } else {
      // Resume from saved position: set midiStartCtxTime so elapsed maps to saved position
      const now = audioCtx.currentTime;
      const lead = 0.05;
      const t0 = now + lead;
      const midiElapsedMs = (savedAudioPosSec*1000) / Math.max(1e-6, currentPlaybackRate);
      midiStartCtxTime = t0 - (midiElapsedMs/1000);
      startAudio((t0 - now)*1000);
      audioStartCtxTime = t0;
      playingMIDI=true;
      // Advance midiIndex to match saved position
      midiIndex = 0;
      advanceMIDI(savedAudioPosSec*1000);
      updatePlayButton();
    }
  }
}
function restartFromBeginning(){
  if(!audioCtx || !audioReady || !midiLoaded) return;
  // Stop any current playback
  disposeAudioSource('restartFromBeginning cleanup');
  audioPlaying=false; playingMIDI=false;
  savedAudioPosSec = 0;
  midiIndex = 0;
  resetKeys();
  clearAllKeyGlow();
  // Schedule fresh start with current offset and rate
  startMIDIPlayback();
  updatePlayButton();
}
function setPlaybackRate(rate){
  if(!isFinite(rate) || rate<=0) return;
  const wasPlaying = !!audioPlaying;
  // If currently playing, convert current position to saved, stop; we'll optionally resume
  if(audioCtx && wasPlaying){
    const now = audioCtx.currentTime;
    const playedSec = (now - audioStartCtxTime) * currentPlaybackRate;
    savedAudioPosSec += Math.max(0, playedSec);
    disposeAudioSource('setPlaybackRate cleanup');
    audioPlaying=false; playingMIDI=false;
  }
  currentPlaybackRate = rate;
  // Resume only if we were playing
  if(audioCtx && audioReady && midiLoaded && wasPlaying){
    togglePlayPause(); // resumes from saved position at new rate
  }
}
function resetKeys(){
  // Zero out all key rotations and clear animation state
  keyAnimState.forEach(st => {
    if(st.mesh){ st.mesh.rotation.x = 0; }
    st.phase = 'idle';
    st.startMs = 0;
    st.fromAngle = 0;
    st.targetAngle = 0;
  });
  pressState.forEach((_, mesh)=>{ if(mesh) pressState.set(mesh, 0); });
}
function stopAllAnimActions(){
  const all = [...animActionsA, ...animActionsB];
  all.forEach(action=>{
    if(!action) return;
    safeRun(() => action.stop(), 'anim action stop');
    safeRun(() => action.reset(), 'anim action reset');
  });
}
function playAnimRange(which){
  if(!animationMixer) return;
  stopAllAnimActions();
  const list = which==='A' ? animActionsA : animActionsB;
  list.forEach(action=>{
    action.reset();
    action.setLoop(THREE.LoopOnce, 0);
    action.clampWhenFinished = true;
    action.play();
  });
}
// ---- Key picking & basic synth note playback ----
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
// pointer tracking to distinguish click vs drag for playing notes
let pointerDownInfo = null; // { startX, startY, moved, midiNum, mesh, played, playedAt, glowApplied }
let pendingPlayTimer = null;
const MIN_USER_NOTE_MS = 250;
function midiNameToNumber(name){ const m = name.match(/^(\d{3})_/); return m? parseInt(m[1],10) : null; }
// Simple polyphonic piano-like synth with sustain support
const activeVoices = new Map(); // midiNum -> {osc, gain, stopTime, mesh}
function playUserNote(midiNum, mesh){
  midiNum = Number(midiNum);
  if(Number.isNaN(midiNum) || midiNum==null) return;
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state !== 'running'){ safeRun(() => audioCtx.resume(), 'audioCtx resume'); }
  const now = audioCtx.currentTime;
  // If a sampled instrument is loaded, prefer it
  if(instrumentPlayer){
    try{
      // If a previous sample node exists for this midi, gracefully fade it out
      const existing = activeSampleNodes.get(midiNum);
      const fadeShort = 0.06;
      if(existing && !existing.stopped){
        existing.stopped = true;
        try{
          if(existing.gainNode){
            const t = audioCtx.currentTime;
            existing.gainNode.gain.cancelScheduledValues(t);
            existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, t);
            existing.gainNode.gain.exponentialRampToValueAtTime(0.0001, t + fadeShort);
            if(existing.node && existing.node.stop) existing.node.stop(t + fadeShort + 0.02);
          } else if(existing.node && existing.node.stop){
            existing.node.stop(audioCtx.currentTime + fadeShort);
          }
        }catch(e){ /* ignore */ }
      }

      // Create a gain node so we can fade notes out cleanly (prevents clicks)
      ensureAudio();
      const gainNode = audioCtx.createGain();
      // start at 0 and apply a short linear attack to avoid clicks
      try{ gainNode.gain.cancelScheduledValues(now); }catch(e){}
      try{ gainNode.gain.setValueAtTime(0.0, now); }catch(e){}
      try{ gainNode.gain.linearRampToValueAtTime(1.0, now + NOTE_ATTACK_SEC); }catch(e){}
      gainNode.connect(masterGain);
      // Many players accept a gainNode option; WebAudioFont adapter we supply will honor it.
      const node = instrumentPlayer.play(midiNum, now, { gain: 1, gainNode });
      activeSampleNodes.set(midiNum, { node: node, gainNode: gainNode, startedAt: now, stopped: false });
      // defensive cleanup in case stop isn't called later (keep a long timeout)
      setTimeout(()=>{ const e = activeSampleNodes.get(midiNum); if(e && e.stopped) activeSampleNodes.delete(midiNum); }, 12000);
    }catch(e){ console.warn('Instrument play failed, falling back to synth', e); }
    if(mesh){ const base = (isBlackKey(mesh)? BLACK_MAX : WHITE_MAX) * KEY_PRESS_SIGN; mesh.rotation.x = base * 0.6; }
    // Update picker status if present (debug HUD handled separately)
    try{
      const status = document.querySelector('#instrumentPicker > div');
      if(status) status.textContent = 'Playing: ' + (currentInstrumentName || '') + ' ' + midiNum;
      setTimeout(()=>{ if(status) status.textContent = 'Loaded: ' + (currentInstrumentName || ''); }, 120);
    }catch(e){}
    // Mark active note for overlay
    const mn = Number(midiNum);
    activeNotes.set(mn, { velocity: 1, tOn: performance.now() });
    activeNoteSet.add(mn);
    try{ requestBackboardRedraw(); }catch(e){}
    return;
  }
  // No sampled instrument loaded: only provide visual feedback (no oscillator fallback)
  if(mesh){
    const base = (isBlackKey(mesh)? BLACK_MAX : WHITE_MAX) * KEY_PRESS_SIGN;
    mesh.rotation.x = base * 0.6;
  }
  // Register active note so highlights appear even without a sampled instrument
  const mn2 = Number(midiNum);
  activeNotes.set(mn2, { velocity: 1, tOn: performance.now() });
  activeNoteSet.add(mn2);
  try{ requestBackboardRedraw(); }catch(e){}
  return;
}

// Stop a user-triggered note quickly and remove glow
function stopUserNote(midiNum){
  midiNum = Number(midiNum);
  if(Number.isNaN(midiNum)) return;
  // Ensure cleanup always runs, even if audio operations throw
  const nowSec = (audioCtx ? audioCtx.currentTime : 0);
  // Guard: ensure a fade duration is available in case other code referenced lowercase fadeSec
  const DEFAULT_FADE_SEC = 0.06;
  const fadeSecLocal = (typeof FADE_SEC === 'number') ? FADE_SEC : DEFAULT_FADE_SEC;
  try{
    // First handle sample nodes if present
    const sampleEntry = activeSampleNodes.get(midiNum);
    if(sampleEntry){
      // Determine elapsed time since this note started so a short tap still respects MIN_USER_NOTE_MS
      const started = sampleEntry.startedAt || nowSec;
      const elapsed = Math.max(0, nowSec - started);
      const minSec = MIN_USER_NOTE_MS / 1000;
      let stopAt = nowSec + fadeSecLocal;
      if(elapsed < minSec){ stopAt = started + minSec + FADE_SEC; }

      // Mark stopped to avoid double-stops
      sampleEntry.stopped = true;
      // If we control a gainNode, ramp it down for a smooth release
      if(sampleEntry.gainNode){
        try{
          sampleEntry.gainNode.gain.cancelScheduledValues(nowSec);
          const currentGain = sampleEntry.gainNode.gain.value || 1.0;
          sampleEntry.gainNode.gain.setValueAtTime(currentGain, nowSec);
          sampleEntry.gainNode.gain.linearRampToValueAtTime(0.0, stopAt);
        }catch(e){ /* ignore */ }
      }
      // Finally stop underlying node if we have a stop API
      if(sampleEntry.node && sampleEntry.node.stop){
        try{ sampleEntry.node.stop(stopAt + 0.02); }catch(e){ /* ignore */ }
      }
      // remove mapping after a safe delay
      setTimeout(()=>{ activeSampleNodes.delete(midiNum); }, Math.round((Math.max(0, ( (sampleEntry.startedAt||nowSec) + (MIN_USER_NOTE_MS/1000) ) - nowSec) + fadeSecLocal + 50) ));
    }

    // Then handle oscillator voices if any
    const v = activeVoices.get(midiNum);
    if(v && !v.stopping){
      v.stopping = true;
      try{
        const now = nowSec;
        v.gain.gain.cancelScheduledValues(now);
        v.gain.gain.setValueAtTime(v.gain.gain.value, now);
        // ensure minimum duration before fading
        const playedAtMs = (v.playedAt !== undefined) ? v.playedAt : (v.startTime * 1000);
        const elapsed = (now * 1000) - playedAtMs;
        const remain = Math.max(0, MIN_USER_NOTE_MS - elapsed) / 1000;
        const when = now + remain;
        v.gain.gain.linearRampToValueAtTime(0.0, when + NOTE_FADE_SEC);
        setTimeout(()=>{ safeRun(()=>{ v.osc.stop(); v.oscB.stop(); v.oscC.stop(); }, 'user stop'); activeVoices.delete(midiNum); }, Math.round((remain + NOTE_FADE_SEC + 0.05)*1000));
      }catch(e){ /* ignore */ }
    }
  }catch(err){
    console.warn('stopUserNote audio path failed', err);
  } finally {
    // ALWAYS run visual/material cleanup
    const mesh = midiKeyMap.get(midiNum);
    try{
      keyActiveCount.set(Number(midiNum), 0);
      const orig = mesh && mesh.userData ? mesh.userData._origMaterial : null;
      if(orig && mesh){ mesh.material = orig; if(mesh.material) mesh.material.needsUpdate = true; }
    }catch(e){ /* ignore */ }
    // Remove overlay active note
    try{ activeNotes.delete(Number(midiNum)); }catch(e){}
    try{ activeNoteSet.delete(Number(midiNum)); }catch(e){}
    // restore key rotation and mark animation release state
    try{
      const v = activeVoices.get(midiNum);
      const m = mesh || (v && v.mesh);
      if(m) m.rotation.x = 0;
      const st = keyAnimState.get(midiNum);
      if(st){ st.phase = 'release'; st.startMs = (audioCtx ? (audioCtx.currentTime - (midiStartCtxTime||0)) * 1000 : 0); st.fromAngle = m ? m.rotation.x : 0; st.targetAngle = 0; }
    }catch(e){ /* ignore */ }
    try{ requestBackboardRedraw(); }catch(e){}
  }
}

function onGlobalPointerMove(e){
  // Safety: if we think pointer is down but no buttons are pressed (lost release), treat as pointer up
  if(pointerDownInfo && typeof e.buttons === 'number' && e.buttons === 0){
    const pid = pointerDownInfo.pointerId;
    onGlobalPointerUp();
    try{ if(pid !== undefined && pid !== null) canvas.releasePointerCapture(pid); }catch(err){}
    return;
  }
  if(!pointerDownInfo) return;
  const dx = e.clientX - pointerDownInfo.startX;
  const dy = e.clientY - pointerDownInfo.startY;
  const dist2 = dx*dx + dy*dy;
  if(!pointerDownInfo.moved && dist2 > (8*8)){
    pointerDownInfo.moved = true;
    if(pendingPlayTimer){ clearTimeout(pendingPlayTimer); pendingPlayTimer = null; }
    if(pointerDownInfo.played){ stopUserNote(pointerDownInfo.midiNum); pointerDownInfo.played = false; }
    // If we applied immediate visual glow but are now moving, clear it
    if(pointerDownInfo.glowApplied){ applyKeyGlow(pointerDownInfo.mesh, pointerDownInfo.midiNum, false); pointerDownInfo.glowApplied = false; }
    // do not re-enable rotate here if the pointer started on a key; rotation remains disabled until release
  }
  // Glissando: when pointer moved while down on a key, play notes encountered under pointer
  if(pointerDownInfo && pointerDownInfo.moved){
    // Only allow glissando playback while the primary button is held.
    if(typeof e.buttons === 'number' && ((e.buttons & 1) === 0)) return;
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
    pointer.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
    raycaster.setFromCamera(pointer, cam);
    const intersects = root ? raycaster.intersectObject(root, true) : [];
    if(intersects.length){
      const hit = intersects[0].object;
      const res = findKeyFromObject(hit);
      if(res && res.midiNum !== pointerDownInfo.lastMidi){
        const prev = pointerDownInfo.lastMidi;
        if(prev != null){
          try{ stopUserNote(prev); }catch(e){}
        }
        pointerDownInfo.lastMidi = res.midiNum;
        playUserNote(res.midiNum, res.mesh);
        applyKeyGlow(res.mesh, res.midiNum, true);
      }
    }
  }
}

function onGlobalPointerUp(e){
  if(!pointerDownInfo) return;
  if(!pointerDownInfo.moved){
    // If we haven't played yet, play briefly then stop
    if(!pointerDownInfo.played){
      playUserNote(pointerDownInfo.midiNum, pointerDownInfo.mesh);
      pointerDownInfo.played = true;
      const v = activeVoices.get(pointerDownInfo.midiNum);
      if(v) v.playedAt = performance.now();
    }
    if(pointerDownInfo.played){ stopUserNote(pointerDownInfo.midiNum); }
  }
  if(pendingPlayTimer){ clearTimeout(pendingPlayTimer); pendingPlayTimer = null; }
  // Ensure any last glissando note is stopped
  try{
    if(pointerDownInfo && pointerDownInfo.lastMidi != null){ stopUserNote(pointerDownInfo.lastMidi); }
  }catch(e){}
  pointerDownInfo = null;
}
// Handle pedal release affecting sustained voices
function applySustainState(){
  const sustainActive = (sustainAnim.phase==='press' || sustainAnim.phase==='held');
  if(!sustainActive){
    // Begin release on all voices that were held
    const now = audioCtx ? audioCtx.currentTime : 0;
    activeVoices.forEach(v => {
      if(v.stopping) return;
      v.stopping=true;
      v.gain.gain.cancelScheduledValues(now);
      v.gain.gain.setValueAtTime(v.gain.gain.value, now);
      v.gain.gain.exponentialRampToValueAtTime(0.0001, now+0.9);
      setTimeout(()=>{ safeRun(() => { v.osc.stop(); v.oscB.stop(); v.oscC.stop(); }, 'sustain voice release'); }, 1000);
    });
    // After release, clear map gradually
    setTimeout(()=>{ activeVoices.clear(); }, 1100);
  }
}
function findKeyFromObject(obj){
  let cur = obj;
  while(cur){
    const n = cur.name || '';
    const num = midiNameToNumber(n);
    if(Number.isInteger(num)) return {mesh:cur, midiNum:num};
    // Compare against midiKeyMap values
    for(const [nn, m] of midiKeyMap.entries()){ if(m===cur) return {mesh:cur, midiNum:nn}; }
    cur = cur.parent;
  }
  return null;
}
let suppressRotate = false;
function onPointerDown(e){
  // Ignore right-clicks
  if(e.button === 2) return;
  // Check backboard instrument UI first
  const uiUv = raycastBackboardForUv(e.clientX, e.clientY);
  const uiHit = uiUv ? hitTestPanelUI(uiUv) : null;
  if(uiUv) setBackboardDebug(uiUv);
  if(uiHit){
    if(uiHit.type === 'button'){
      panelState[uiHit.panel].selected = uiHit.id;
      triggerInstrumentButton(uiHit.id);
    } else if(uiHit.type === 'arrow-up'){
      const ps = panelState[uiHit.panel];
      ps.offset = Math.max(0, ps.offset - 1);
      requestBackboardRedraw();
    } else if(uiHit.type === 'arrow-down'){
      const ps = panelState[uiHit.panel];
      const maxOffset = Math.max(0, INSTRUMENT_BUTTONS.length - 6);
      ps.offset = Math.min(maxOffset, ps.offset + 1);
      requestBackboardRedraw();
    }
    updateInstrumentHover(e.clientX, e.clientY);
    // prevent camera rotation while down on backboard
    backboardPointerDown = true;
    controls.enableRotate = false;
    suppressRotate = true;
    try{ if(typeof e.pointerId !== 'undefined') canvas.setPointerCapture(e.pointerId); }catch(err){}
    e.preventDefault();
    return;
  }
  // If we hit the backboard plane but not UI (e.g., empty space), still suppress rotate like keys
  if(uiUv){
    backboardPointerDown = true;
    controls.enableRotate = false;
    suppressRotate = true;
    try{ if(typeof e.pointerId !== 'undefined') canvas.setPointerCapture(e.pointerId); }catch(err){}
    e.preventDefault();
    return;
  }
  const rect = canvas.getBoundingClientRect();
  pointer.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
  pointer.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
  raycaster.setFromCamera(pointer, cam);
  const intersects = root ? raycaster.intersectObject(root, true) : [];
  if(intersects.length){
    const hit = intersects[0].object;
    const res = findKeyFromObject(hit);
    if(res){
      pointerDownInfo = { startX: e.clientX, startY: e.clientY, moved: false, midiNum: res.midiNum, mesh: res.mesh, played: false, playedAt: null, glowApplied: false, pointerId: e.pointerId };
      // capture the pointer so we reliably receive pointerup even if the cursor leaves the canvas
      try{ if(typeof e.pointerId !== 'undefined') canvas.setPointerCapture(e.pointerId); }catch(err){}
      // immediate visual feedback so quick taps show highlight
      applyKeyGlow(res.mesh, res.midiNum, true);
      pointerDownInfo.glowApplied = true;
      // disable rotate while pointer is down on a key
      controls.enableRotate = false; suppressRotate = true;
      pendingPlayTimer = setTimeout(()=>{
        if(pointerDownInfo && !pointerDownInfo.moved){
          playUserNote(pointerDownInfo.midiNum, pointerDownInfo.mesh);
          pointerDownInfo.played = true;
          pointerDownInfo.playedAt = performance.now();
        }
        pendingPlayTimer = null;
      }, 40);
      e.preventDefault();
      return;
    }
  }
}

function onPointerUp(){
  // Release pointer capture if we had one
  const pid = pointerDownInfo && pointerDownInfo.pointerId;
  onGlobalPointerUp();
  try{ if(pid !== undefined && pid !== null) canvas.releasePointerCapture(pid); }catch(err){}
  if(suppressRotate){ controls.enableRotate=true; suppressRotate=false; }
  if(backboardPointerDown){
    backboardPointerDown = false;
    controls.enableRotate = true;
  }
  setBackboardDebug(null);
}
canvas.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointerup', onPointerUp);
// Also handle pointercancel to avoid sticky state on unexpected cancels
canvas.addEventListener('pointercancel', onPointerUp);
window.addEventListener('pointercancel', onPointerUp);
window.addEventListener('pointermove', onGlobalPointerMove);
canvas.addEventListener('pointermove', (e)=>updateInstrumentHover(e.clientX, e.clientY));
// Ensure pointer leaving the canvas also ends any active press
canvas.addEventListener('pointerleave', onPointerUp);
canvas.addEventListener('pointerleave', ()=>{ if(panelHover){ panelHover=null; requestBackboardRedraw(); }});
// prevent context menu on canvas
canvas.addEventListener('contextmenu', ev=>{ ev.preventDefault(); });

// QWERTY piano mapping by `event.code` -> MIDI
const CODE_TO_MIDI = new Map(Object.entries({
  // Bottom whites
  "KeyZ":48, "KeyX":50, "KeyC":52, "KeyV":53, "KeyB":55, "KeyN":57, "KeyM":59,
  "Comma":60, "Period":62, "Slash":64,

  // Bottom accidentals
  "KeyS":49, "KeyD":51, "KeyG":54, "KeyH":56, "KeyJ":58, "KeyL":61, "Semicolon":63,

  // Top whites (F4 -> C6)
  "KeyQ":65, "KeyW":67, "KeyE":69, "KeyR":71, "KeyT":72, "KeyY":74, "KeyU":76,
  "KeyI":77, "KeyO":79, "KeyP":81, "BracketLeft":83, "BracketRight":84,

  // Top accidentals (skip where no black key exists)
  "Digit2":66, "Digit3":68, "Digit4":70, "Digit6":73, "Digit7":75, "Digit9":78, "Digit0":80, "Minus":82
}));

const downCodes = new Set();

function noteOn(midi){
  try{
    const mesh = midiKeyMap.get(Number(midi));
    // Visual feedback: apply glow for keyboard-triggered notes
    if(mesh) try{ applyKeyGlow(mesh, Number(midi), true); }catch(e){}
    playUserNote(Number(midi), mesh);
  }catch(e){ console.warn('noteOn failed', e); }
}
function noteOff(midi){
  try{ stopUserNote(Number(midi)); }catch(e){ console.warn('noteOff failed', e); }
}

function handleKeyDown(ev){
  // Allow modifier shortcuts to pass through
  if(ev.ctrlKey || ev.altKey || ev.metaKey) return;
  const code = ev.code;
  const midi = CODE_TO_MIDI.get(code);
  if(midi == null) return;

  // Prevent default browser action for slash but allow note handling
  if(code === 'Slash') ev.preventDefault();

  // Avoid repeats and track by code
  if(ev.repeat) return;
  if(downCodes.has(code)) return;
  downCodes.add(code);

  // IMPORTANT: latch MIDI by `code` so keyup releases the same note regardless of layout/modifiers
  const m = Number(midi);
  codeToMidiDown.set(code, m);

  // Track active MIDI notes by number
  activeNoteSet.add(m);
  noteOn(m);
}

function handleKeyUp(ev){
  const code = ev.code;
  // ALWAYS release by the latched value, not by recomputing from key/code
  const m = codeToMidiDown.get(code);
  if(m == null) return;

  ev.preventDefault();

  downCodes.delete(code);
  codeToMidiDown.delete(code);
  activeNoteSet.delete(m);
  noteOff(m);
}

function allNotesOff(){
  for(const m of Array.from(activeNoteSet)){
    try{ noteOff(m); }catch(e){}
  }
  activeNoteSet.clear();
  downCodes.clear();
  codeToMidiDown.clear();
}

// Panic: stop audio and visuals for all sources (keyboard, pointer, samples, oscillators)
function panicAllNotes(){
  try{ allNotesOff(); }catch(e){}
  try{ activeVoices.forEach(v=>{ try{ v.osc && v.osc.stop && v.osc.stop(); v.oscB && v.oscB.stop && v.oscB.stop(); v.oscC && v.oscC.stop && v.oscC.stop(); }catch(e){} }); activeVoices.clear(); }catch(e){}
  try{ activeSampleNodes.forEach((entry, k)=>{ try{ const t = (audioCtx && audioCtx.currentTime) ? audioCtx.currentTime : 0; if(entry && entry.gainNode){ entry.gainNode.gain.cancelScheduledValues(t); entry.gainNode.gain.setValueAtTime(0.0, t); } if(entry && entry.node && entry.node.stop) entry.node.stop((t || 0) + 0.02); }catch(e){} }); activeSampleNodes.clear(); }catch(e){}
  try{ if(pointerDownInfo){ try{ if(pointerDownInfo.played) stopUserNote(pointerDownInfo.midiNum); if(pointerDownInfo.glowApplied) applyKeyGlow(pointerDownInfo.mesh, pointerDownInfo.midiNum, false); }catch(e){} } pointerDownInfo = null; }catch(e){}
  try{ if(typeof pendingPlayTimer !== 'undefined' && pendingPlayTimer){ clearTimeout(pendingPlayTimer); pendingPlayTimer = null; } }catch(e){}
  try{ requestBackboardRedraw(); }catch(e){}
}

window.addEventListener('keydown', handleKeyDown, { capture:true, passive:false });
window.addEventListener('keyup', handleKeyUp, { capture:true, passive:false });
window.addEventListener('blur', panicAllNotes);
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) panicAllNotes(); });

===== END FILE: music-piano-debug.js =====


===== START FILE: music-piano.js =====

// music-piano-debug.js
// Fresh debug loader: isolates GLB visibility without previous logic
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { getSyncOffsetMs } from './global-sync.js';
const canvas = document.getElementById('pianoCanvas');
if (!canvas) { console.error('Canvas #pianoCanvas not found'); }
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
const clock = new THREE.Clock();
const scene = new THREE.Scene();
// Debug axes helper removed per user request
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const cam = new THREE.PerspectiveCamera(45, canvas.clientWidth/canvas.clientHeight, 0.001, 500);
// Initial camera; final framing is driven by fit()/intro tween after GLB load
cam.position.set(1.4, 6, 2.8);
cam.lookAt(0,0,0);
const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.6); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(3,5,4); scene.add(dir);
const loader = new GLTFLoader();
const draco = new DRACOLoader(); draco.setDecoderPath('https://unpkg.com/three@0.159.0/examples/jsm/libs/draco/');
loader.setDRACOLoader(draco); loader.setMeshoptDecoder(MeshoptDecoder);
const HUD = document.createElement('div');
HUD.style.cssText='position:absolute;left:8px;top:8px;padding:6px 10px;background:rgba(0,0,0,.6);color:#d0ffe4;font:12px monospace;z-index:10;border-radius:6px;white-space:pre;';
canvas.parentElement?.appendChild(HUD);
let root=null; let keyMeshes=[];
let selectedKey=null; // middle key chosen for demo animation
const demoAngleWhite = THREE.MathUtils.degToRad(4);
const demoAngleBlack = THREE.MathUtils.degToRad(5);
// Orbit controls
const controls = new OrbitControls(cam, renderer.domElement);
// User-specified mouse button mapping
controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enablePan = true;
controls.panSpeed = 0.6;
controls.minDistance = 0.5;
controls.maxDistance = 20; // allow further zooming out
controls.target.set(0,0.4,0);
// MIDI structures
let midiEvents = []; // {timeMs, type:'on'|'off', note, velocity}
let ticksPerQuarter = 480; // default, will read header
let tempoUsPerQuarter = 500000; // default 120 BPM (500000 microseconds per quarter note)
let tempoMap = [{tick:0, timeMs:0, tempo:tempoUsPerQuarter}]; // record tempo changes
let midiLoaded = false;
let midiIndex = 0; // current event index during playback
let playingMIDI = false;
let audioStartCtxTime = 0; // AudioContext.start base time
let midiStartCtxTime = 0;  // When MIDI timeline starts relative to audioCtx
let midiFirstNoteMs = 0;    // earliest note-on for zero alignment
let sentinelFilteredCount = 0; // count of filtered sentinel notes
let midiStretch = 1.0;      // stretch factor to match audio active duration
let midiActiveDurationMs = 0; // MIDI active span (first on -> last off) after filtering
const STRETCH_CLAMP = 0.20; // +/-20% max stretch to cover export mismatches
const midiKeyMap = new Map(); // noteNumber -> mesh
const pressState = new Map(); // mesh -> currentRotation
const WHITE_MAX = demoAngleWhite; // reuse deg limits
const BLACK_MAX = demoAngleBlack;
// Sign to apply for key press rotation: +1 means positive X rotates downward visually
// Adjusted after user feedback (keys were going up). If your model changes, flip to -1.
const KEY_PRESS_SIGN = 1;
// Sustain pedal (right) animation support
let sustainPedalMesh = null;
const PEDAL_MAX_ANGLE = THREE.MathUtils.degToRad(6);
const PEDAL_PRESS_MS = 85;
const PEDAL_RELEASE_MS = 140;
const sustainAnim = { phase:'idle', startMs:0, fromAngle:0, targetAngle:0 };
// Smooth animation & velocity scaling
// For predictive pedal bounce
let sustainEventTimes = []; // times (ms) of cc64 presses (value>=64) for lookahead
const PEDAL_BOUNCE_ANGLE = THREE.MathUtils.degToRad(0.9);
const PEDAL_LOOKAHEAD_MS = 160; // if next press within this after release start, force fast release
const PRESS_ATTACK_MS = 55;   // ramp press
const RELEASE_DECAY_MS = 110; // ramp release
const VELOCITY_MIN = 20;      // floor for depth scaling
const VELOCITY_MAX = 127;     // MIDI max
// Per-note animation state: noteNumber -> { mesh, phase, startMs, fromAngle, targetAngle }
const keyAnimState = new Map();
let audioCtx=null, audioBuffer=null, audioSource=null; let audioReady=false, audioPlaying=false; let audioError=false; let midiError=false;
// Sampler (SoundFont) support
let instrumentPlayer = null;
let currentInstrumentName = null;
const activeSampleNodes = new Map(); // midiNum -> node
let audioTrimMs = 0; // detected leading silence trim
const TRIM_THRESHOLD = 0.0025; // RMS amplitude threshold
const TRIM_WINDOW_SAMPLES = 2048; // window size for scanning
const MAX_TRIM_MS = 20000; // safety cap (allow long tails up to 20s)
let audioActiveDurationMs = 0; // duration between first audible and last audible
let currentPlaybackRate = 1.0;
let savedAudioPosSec = 0; // persisted playhead when paused
// Animation frame lock configuration
const LOCK_FRAME = 140; // target frame to freeze at
const LOCK_FPS = 30;    // assumed export FPS (adjust if different)
let animationMixer = null;
let tabletStandMesh = null; // auto-rotated display stand
let animActionsA = [];
let animActionsB = [];
// ---- Glow materials for active notes ----
// Blender-specified glow materials (provided spec)
const GlowMaterials = {
  'keys_black_glow': {
    color: 0x860B07,
    emissive: 0x860B07,
    emissiveIntensity: 1.000,
    metalness: 0.000,
    roughness: 0.353,
  },
  'keys_white_glow': {
    color: 0x17FF1C,
    emissive: 0x17FF1C,
    emissiveIntensity: 1.000,
    metalness: 0.000,
    roughness: 0.307,
  },
};
let glbGlowMaterial = null; // still capture if a unified 'glow' exists, but we prefer spec pair
const glowMatBlack = new THREE.MeshStandardMaterial({
  name: 'keys_black_glow',
  color: new THREE.Color(GlowMaterials['keys_black_glow'].color),
  emissive: new THREE.Color(GlowMaterials['keys_black_glow'].emissive),
  emissiveIntensity: GlowMaterials['keys_black_glow'].emissiveIntensity,
  metalness: GlowMaterials['keys_black_glow'].metalness,
  roughness: GlowMaterials['keys_black_glow'].roughness
});
const glowMatWhite = new THREE.MeshStandardMaterial({
  name: 'keys_white_glow',
  color: new THREE.Color(GlowMaterials['keys_white_glow'].color),
  emissive: new THREE.Color(GlowMaterials['keys_white_glow'].emissive),
  emissiveIntensity: GlowMaterials['keys_white_glow'].emissiveIntensity,
  metalness: GlowMaterials['keys_white_glow'].metalness,
  roughness: GlowMaterials['keys_white_glow'].roughness
});
glowMatBlack.side = THREE.DoubleSide; glowMatWhite.side = THREE.DoubleSide;
// Track how many overlapping note-ons are active per key to safely restore material
const keyActiveCount = new Map(); // noteNumber -> count
const safeRun = (fn, label = 'Non-critical failure') => {
  try { fn(); }
  catch (err) { console.warn(label, err); }
};
const disposeAudioSource = (reason) => {
  if (!audioSource) return;
  const prefix = reason ? `${reason}:` : 'audioSource cleanup';
  safeRun(() => audioSource.stop(), `${prefix} stop failed`);
  safeRun(() => audioSource.disconnect(), `${prefix} disconnect failed`);
  audioSource = null;
};
// Clear all active glow states and restore original materials
function clearAllKeyGlow(){
  keyActiveCount.clear();
  if(keyMeshes && keyMeshes.length){
    keyMeshes.forEach(m => {
      const orig = m?.userData?._origMaterial;
      if(orig && m.material !== orig){
        m.material = orig;
        if(m.material) m.material.needsUpdate = true;
      }
    });
  }
}

// Load a SoundFont instrument by name (returns a promise). Exposed on window for UI.
async function loadInstrument(name){
  // detect Soundfont global under several possible names
  const SF = window.Soundfont || window.SoundFont || window.SoundfontPlayer || window.SoundfontPlayer || window.Soundfont || window.Soundfontplayer;
  if(!SF){ console.warn('Soundfont-player not found'); return null; }
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  try{
    const opts = { soundfont: 'MusyngKite', format: 'mp3', url: 'https://gleitz.github.io/midi-js-soundfonts/MusyngKite/' };
    const inst = await SF.instrument(audioCtx, name, opts);
    instrumentPlayer = inst;
    currentInstrumentName = name;
    console.log('Loaded instrument', name, inst);
    // update any picker UI active state (if present)
    try{ document.querySelectorAll('.instrument-picker button').forEach(b=>b.classList.toggle('active', b.dataset.instrument===name)); }catch(e){}
    return inst;
  }catch(e){ console.warn('Failed to load instrument', name, e); throw e; }
}
window.loadInstrument = loadInstrument;
window.getCurrentInstrumentName = () => currentInstrumentName;
function applyKeyGlow(mesh, noteNumber, on){
  if(!mesh) return;
  const cur = (keyActiveCount.get(noteNumber) || 0) + (on? 1 : -1);
  const next = Math.max(0, cur);
  keyActiveCount.set(noteNumber, next);
  if(on){
    // Save original material once
    if(mesh.userData && mesh.userData._origMaterial === undefined){
      mesh.userData._origMaterial = mesh.material;
    }
    // Prefer the Blender spec pair; only fall back to a single captured glbGlowMaterial if explicitly desired
    const gm = (isBlackKey(mesh) ? glowMatBlack : glowMatWhite);
    mesh.material = gm;
    if(mesh.material) mesh.material.needsUpdate = true;
  } else if(next===0) {
    // Restore original when no more active presses remain
    const orig = mesh.userData ? mesh.userData._origMaterial : null;
    if(orig){ mesh.material = orig; if(mesh.material) mesh.material.needsUpdate = true; }
  }
}
// ---- Track Metadata (moved earlier to avoid TDZ issues) ----
// Track metadata (adjust paths if actual filenames differ)
const TRACKS = {
  baby: {
    label: 'Baby',
    audioCandidates: [
      './music/Baby,-Just-Shut-Up!,-A-Lullaby.wav',
      './music/Baby,-Just-Shut-Up!,-A-Lullaby.mp3'
    ],
    midi: './midi/babyshutup.mid'
  },
  raisins: {
    label: 'Raisins',
    audioCandidates: [
      './music/Those-Raisins-Are-Mine!.wav', // preferred if added later
      './music/Those-Raisins-Are-Mine!.mp3'
    ],
    midi: './midi/raisins.mid'
  },
  forests: {
    label: 'Forests',
    audioCandidates: [
      './music/No-Forests-Left-to-Give.wav',
      './music/No-Forests-Left-to-Give.mp3'
    ],
    // Supports multiple MIDI parts to be merged
    midi: [
      './midi/Forests-Accomp.mid',
      './midi/Forests-Harmony.mid',
      './midi/Forests-Melody.mid'
    ]
  }
};
let currentTrackKey = 'baby';

// Intro camera animation state
let introState = {
  active: false,
  startTime: 0,
  duration: 2.0, // seconds
  startPos: new THREE.Vector3(),
  endPos: new THREE.Vector3(),
  startTarget: new THREE.Vector3(),
  endTarget: new THREE.Vector3()
};

// Helper: smoothstep easing 0-1
function easeSmooth(t){
  return t * t * (3 - 2 * t);
}

// Decide whether to run the intro tween for this page load.
// We want it on first visit, back/forward, and explicit reloads.
const navEntry = performance.getEntriesByType('navigation')[0];
const navType = navEntry ? navEntry.type : (performance.navigation || {}).type;
const shouldRunIntro = (navType === 'navigate' || navType === 'reload' || navType === 'back_forward' || navType === 0);

// Adjustable framing tightness (lower value = closer). Original was 1.55 (looser)
const FRAME_TIGHTNESS = 1.6; // higher => further camera distance
function fit(box){
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);
  const maxDim = Math.max(size.x,size.y,size.z);
  const fov = cam.fov*Math.PI/180;
  const dist = (maxDim/2)/Math.tan(fov/2) * FRAME_TIGHTNESS;

  // Base "wide" position: higher and back so everything is small.
  const widePos = new THREE.Vector3(
    center.x + dist * 0.05,
    center.y + size.y * 1.30,
    center.z + dist * 1.55
  );

  // Hero shot: closer, slightly higher, looking down – fills viewport.
  const heroDist = dist * 0.75;
  const heroPos = new THREE.Vector3(
    center.x + heroDist * 0.06,
    center.y + size.y * 0.60,
    center.z + heroDist * 0.58
  );

  const heroTarget = new THREE.Vector3(center.x, center.y + size.y * 0.32, center.z);

  if (shouldRunIntro) {
    // Start from wide, animate into hero.
    cam.position.copy(widePos);
    cam.lookAt(center);

    introState.startPos.copy(widePos);
    introState.endPos.copy(heroPos);
    introState.startTarget.copy(center);
    introState.endTarget.copy(heroTarget);
    introState.startTime = clock.getElapsedTime();
    introState.active = true;

    // Temporarily disable OrbitControls input during intro
    controls.enableRotate = false;
    controls.enablePan = false;
    controls.enableZoom = false;
  } else {
    // Directly jump to hero framing without tween
    cam.position.copy(heroPos);
    cam.lookAt(heroTarget);
    controls.target.copy(heroTarget);
  }
}
function collectKeys(node){
  const found=[];
  const midiPattern = /^(\d{3})_([A-G](?:#|b)?\d)$/i; // extract MIDI number
  node.traverse(o=>{
    if(o.isMesh){
      const nm = o.name || '';
      const m = nm.match(midiPattern);
      if(m){
        const midiNum = parseInt(m[1],10);
        midiKeyMap.set(midiNum, o);
        found.push(o);
      } else if(/key|white|black/.test(nm.toLowerCase())) {
        found.push(o);
      }
    }
  });
  keyMeshes = found; console.log('Debug collect keys:', found.map(f=>f.name));
  if(keyMeshes.length){
    chooseMiddleKey();
  }
  // init pressState
  keyMeshes.forEach(k=>pressState.set(k,0));
  // Build animation state map for MIDI keys
  midiKeyMap.forEach((mesh, note)=>{
    keyAnimState.set(note, { mesh, phase:'idle', startMs:0, fromAngle:0, targetAngle:0 });
  });
}
function chooseMiddleKey(){
  // Sort keys by world X position to find median (approx middle C)
  const positions = keyMeshes.map(k=>{
    k.updateWorldMatrix(true,false);
    const p = new THREE.Vector3();
    k.getWorldPosition(p);
    return {mesh:k, x:p.x};
  }).sort((a,b)=>a.x-b.x);
  const median = positions[Math.floor(positions.length/2)];
  selectedKey = median.mesh;
  // Heuristic brighten highlight
  if(selectedKey.material && selectedKey.material.color){
    selectedKey.material.emissive ||= new THREE.Color(0x000000);
    selectedKey.material.emissive.setHex(0x442266);
  }
  console.log('Selected middle key for demo:', selectedKey.name);
}
function isBlackKey(mesh){
  // User guarantee: all black keys include a '#' in their name
  return /#/i.test(mesh?.name||'');
}
function animate(){
  requestAnimationFrame(animate);
  // Handle intro camera tween if active
  if (introState.active) {
    const now = clock.getElapsedTime();
    let t = (now - introState.startTime) / introState.duration;
    if (t >= 1) {
      t = 1;
      introState.active = false;
      // Re-enable user camera controls once intro finishes
      controls.enableRotate = true;
      controls.enablePan = true;
      controls.enableZoom = true;
    }
    const k = easeSmooth(Math.min(Math.max(t, 0), 1));
    cam.position.lerpVectors(introState.startPos, introState.endPos, k);
    controls.target.lerpVectors(introState.startTarget, introState.endTarget, k);
    cam.lookAt(controls.target);
  }

  controls.update();
  const dt = clock.getDelta();
  if(animationMixer) animationMixer.update(dt);
  renderer.render(scene, cam);
  if(root){
    const box = new THREE.Box3().setFromObject(root);
    const s = box.getSize(new THREE.Vector3());
  let midiLine = midiError? 'midi:error' : (midiLoaded? (playingMIDI? `midi:${midiIndex}/${midiEvents.length}` : 'midi:ready') : 'midi:loading');
  let audioLine = audioError? 'audio:error' : (audioReady ? (audioPlaying? 'audio:playing' : 'audio:ready') : 'audio:loading');
  const trimInfo = audioReady ? ` trim:${audioTrimMs.toFixed(0)}ms` : '';
  // Live drift diagnostics: compare MIDI and audio elapsed clocks
  let driftLine = '';
  if(audioCtx && (audioPlaying||playingMIDI)){
    const elapsedAudioMs = (audioCtx.currentTime - audioStartCtxTime) * 1000;
    const elapsedMidiMs = (audioCtx.currentTime - midiStartCtxTime) * 1000;
    const driftMs = elapsedMidiMs - elapsedAudioMs;
    driftLine = ` drift:${driftMs.toFixed(1)}ms`;
  }
  HUD.textContent = `children:${root.children.length}\nsize:${s.x.toFixed(3)},${s.y.toFixed(3)},${s.z.toFixed(3)}\nkeys:${keyMeshes.length}\n${midiLine}\n${audioLine}${trimInfo}${driftLine}\ntempos:${tempoMap.length} sentinels:${sentinelFilteredCount}\ncam:${cam.position.x.toFixed(2)},${cam.position.y.toFixed(2)},${cam.position.z.toFixed(2)}`;
    // Demo animation for selected key or fallback
    // Always update view-driven transforms (e.g., tablet stand)
    updateViewDrivenTransforms();
    if(playingMIDI){
      const elapsedMidiSec = audioCtx ? (audioCtx.currentTime - midiStartCtxTime) : 0;
      if(elapsedMidiSec >= 0) advanceMIDI(elapsedMidiSec * 1000);
    }
    updateKeyAnimations();
  }
}
animate();
// Proper signature: (url, onLoad, onProgress, onError)
const MODEL_VERSION = 'v20251115a'; // bump to bust cache when GLB updated
loader.load((window && window.mediaUrl) ? window.mediaUrl('glb/toy-piano.glb') + `?${MODEL_VERSION}` : `glb/toy-piano.glb?${MODEL_VERSION}`,
  gltf => {
    root = gltf.scene;
    scene.add(root);
    // brightening + double side
    root.traverse(o=>{ 
      if(/note_stickers|noteSticker|noteAccidental|noteText/i.test(o.name)) { o.visible = false; }
      if(!sustainPedalMesh && /(sustain|damper|right.*pedal|pedal.*right)/i.test(o.name)){
        sustainPedalMesh = o;
      }
      if(!tabletStandMesh && /tablet_stand/i.test(o.name)) { tabletStandMesh = o; }
      if(o.isMesh && o.material && o.material.color){ 
        if(o.material.color.getHex()===0x000000) o.material.color.set(0x333333); 
        o.material.side=THREE.DoubleSide; 
        o.frustumCulled=false; 
      }
      // Set all shape keys (morph targets) to defaults, then
      // explicitly drive the tablet "left/right" ones to a
      // specific value for the tablet/screen meshes.
      if(o.isMesh && Array.isArray(o.morphTargetInfluences)){
        // First, default all influences to 1.0 as before.
        for(let i=0;i<o.morphTargetInfluences.length;i++){
          o.morphTargetInfluences[i] = 1.0;
        }

        // Then, for the main tablet and its screen, set L/R keys (1,2)
        // to 0.53 while leaving the top key (3) at 1.0.
        const n = (o.name||'').toLowerCase();
        if(/pe'rpad_screen|pe'rpad_tablet/.test(n)){
          const target = 0.53;
          if(o.morphTargetInfluences.length > 1) o.morphTargetInfluences[1] = target;
          if(o.morphTargetInfluences.length > 2) o.morphTargetInfluences[2] = target;
        }
      }
      // Capture any material named 'glow' to use for active keys
      if(o.isMesh && o.material){
        const mat = o.material;
        const name = (mat.name||'').toLowerCase();
        if(!glbGlowMaterial && /\bglow\b/.test(name)){
          glbGlowMaterial = mat;
        }
      }
    });
    // initial box
    let box = new THREE.Box3().setFromObject(root);
    let size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x,size.y,size.z);
    // Auto-scale if enormous (> 20 units) or microscopic (< 0.5)
    if (maxDim > 20 || maxDim < 0.5) {
      const scale = maxDim > 20 ? 10 / maxDim : 1 / maxDim; // shrink or enlarge toward ~10 units
      root.scale.setScalar(scale);
      root.updateMatrixWorld(true);
      box = new THREE.Box3().setFromObject(root);
      size = box.getSize(new THREE.Vector3());
      console.warn('Applied auto-scale factor', scale.toFixed(5), 'new size:', size);
    }
    fit(box);
    collectKeys(root);
    // Ensure all individual keys have scale 1
    safeRun(() => keyMeshes.forEach(k => { if (k && k.scale) k.scale.setScalar(1); }), 'key scale normalize');
    // Recenter origin after potential scaling
    const c = box.getCenter(new THREE.Vector3()); root.position.sub(c);
    // Recompute box after recenter to ensure framing updates for new geometry (e.g., pedals)
    const box2 = new THREE.Box3().setFromObject(root);
    fit(box2);
    console.log('GLB loaded. Final box size:', size, 'post-recenter size:', box2.getSize(new THREE.Vector3()));
    // If there are animations, prepare subclips and lock pose initially
    if(gltf.animations && gltf.animations.length){
      const clips = gltf.animations;
      animationMixer = new THREE.AnimationMixer(root);
      clips.forEach(clip=>{
        // Create subclips for requested ranges
        const subA = THREE.AnimationUtils.subclip(clip, (clip.name||'clip')+':A', 1, 140, LOCK_FPS);
        const subB = THREE.AnimationUtils.subclip(clip, (clip.name||'clip')+':B', 151, 300, LOCK_FPS);
        const actA = animationMixer.clipAction(subA); actA.setLoop(THREE.LoopOnce, 0); actA.clampWhenFinished = true; animActionsA.push(actA);
        const actB = animationMixer.clipAction(subB); actB.setLoop(THREE.LoopOnce, 0); actB.clampWhenFinished = true; animActionsB.push(actB);
        // Lock pose at frame 140 initially
        const baseAction = animationMixer.clipAction(clip);
        baseAction.play();
        const frameTime = LOCK_FRAME / LOCK_FPS;
        baseAction.time = Math.min(frameTime, clip.duration);
        animationMixer.update(0);
        baseAction.paused = true;
        console.log(`Prepared subclips for '${clip.name||'(unnamed)'}' and locked at frame ${LOCK_FRAME}`);
      });
    } else {
      console.log('No animations found to lock.');
    }
  },
  prog => {
    const pct = prog.total ? (prog.loaded / prog.total) * 100 : 0;
    HUD.textContent = `Loading GLB: ${pct.toFixed(1)}%`;
  },
  err => {
    console.error('GLB load FAILED', err);
    HUD.textContent = 'GLB load FAILED';
  }
);
// Resize listener
window.addEventListener('resize', ()=>{
  const w = canvas.parentElement.clientWidth; const h = Math.max(420, Math.floor(window.innerHeight*0.65));
  renderer.setSize(w,h,false); cam.aspect=w/h; cam.updateProjectionMatrix();
});
// ---- MIDI Parsing & Playback ----
function readVLQ(data, offset){
  let value=0; let i=offset; let byte;
  do { byte = data[i++]; value = (value<<7) | (byte & 0x7f); } while(byte & 0x80);
  return {value, next:i};
}
async function loadMIDI(urlOrArray){
  try {
    if(Array.isArray(urlOrArray)){
      const urls = urlOrArray;
      const fetched = await Promise.all(urls.map(async u=>{
        try { const r=await fetch(encodeURI(u)); if(!r.ok) throw new Error('HTTP '+r.status); return await r.arrayBuffer(); }
        catch(err){ console.warn('[MIDI] fetch failed for', u, err); return null; }
      }));
      const valid = fetched.filter(Boolean);
      if(valid.length===0) throw new Error('All MIDI fetches failed');
      // Parse off-main in small timeout to keep UI responsive
      setTimeout(()=>{
        const allEvents=[];
        let primaryTempoMap=null; let primaryTPQ=ticksPerQuarter;
        valid.forEach((ab, idx)=>{
          const {events, tempoMap:tm, ticksPerQuarter:tpq} = parseMIDIToEventList(new Uint8Array(ab));
          if(idx===0){ primaryTempoMap = tm; primaryTPQ = tpq; }
          allEvents.push(...events);
        });
        allEvents.sort((a,b)=>a.timeMs-b.timeMs);
        // Assign to globals
        tempoMap = primaryTempoMap || [];
        ticksPerQuarter = primaryTPQ || ticksPerQuarter;
        midiEvents = allEvents;
        sustainEventTimes = midiEvents.filter(e=> e.type==='cc64' && (e.value|0)>=64).map(e=> e.timeMs);
        // Post-process
        filterSentinelNotes();
        computeMidiActiveSpan();
        recomputeStretch();
        midiLoaded=true; midiError=false;
        console.log('[Track:'+currentTrackKey+'] MIDI merged from', valid.length, 'files; events:', midiEvents.length);
        updatePlayButton();
      },0);
    } else {
      const resp = await fetch(encodeURI(urlOrArray));
      if(!resp.ok) throw new Error('HTTP '+resp.status);
      const buf = await resp.arrayBuffer();
      // parse in timeout to avoid blocking paint
      setTimeout(()=>{ parseMIDI(new Uint8Array(buf)); midiLoaded=true; midiError=false; console.log('[Track:'+currentTrackKey+'] MIDI parsed:', midiEvents.length); updatePlayButton(); },0);
    }
  } catch(e){ console.error('MIDI load failed:', e); midiError=true; updatePlayButton(); }
}
function parseMIDIToEventList(bytes){
  // Two-pass parser: collect events in ticks and tempo changes, then map ticks->ms.
  let p=0;
  function readStr(n){ const s = String.fromCharCode(...bytes.slice(p,p+n)); p+=n; return s; }
  const header = readStr(4); if(header!=='MThd'){ console.error('Bad MIDI header'); return; }
  const hdrLen = (bytes[p]<<24)|(bytes[p+1]<<16)|(bytes[p+2]<<8)|bytes[p+3]; p+=4;
  const format = (bytes[p]<<8)|bytes[p+1]; p+=2;
  const nTracks = (bytes[p]<<8)|bytes[p+1]; p+=2;
  const localTPQ = (bytes[p]<<8)|bytes[p+1]; p+=2;
  p += hdrLen - 6;
  console.log('MIDI header', {format, nTracks, ticksPerQuarter: localTPQ});
  const eventsTicks = []; // {tick,type,note,velocity,chan,value}
  const tempoTicks = [{tick:0, tempo:tempoUsPerQuarter}];
  for(let track=0; track<nTracks; track++){
    const id = readStr(4); if(id!=='MTrk'){ console.warn('Non-track chunk', id); break; }
    const len = (bytes[p]<<24)|(bytes[p+1]<<16)|(bytes[p+2]<<8)|bytes[p+3]; p+=4;
    const end = p+len; let tick=0; let runningStatus=0;
    while(p<end){
      const {value:delta, next:nxt} = readVLQ(bytes,p); p=nxt; tick+=delta;
      let status = bytes[p];
      if(status < 0x80){ status = runningStatus; } else { p++; runningStatus = status; }
      if(status===0xff){
        const type = bytes[p++];
        const {value:mlen, next:n2} = readVLQ(bytes,p); p=n2;
        if(type===0x51 && mlen===3){
          const tempo = (bytes[p]<<16)|(bytes[p+1]<<8)|bytes[p+2];
          tempoTicks.push({tick, tempo});
        }
        p+=mlen; continue;
      }
      if(status===0xf0 || status===0xf7){ const {value:slen, next:n3} = readVLQ(bytes,p); p=n3+slen; continue; }
      const typeNib = status & 0xf0; const chan = status & 0x0f;
      if(typeNib===0x90 || typeNib===0x80){
        const note = bytes[p++]; const vel = bytes[p++];
        const isOn = (typeNib===0x90 && vel>0);
        eventsTicks.push({tick, type:isOn?'on':'off', note, velocity:vel, chan});
      } else if(typeNib===0xb0){
        const controller = bytes[p++]; const value = bytes[p++];
        if(controller===64){ // sustain pedal
          eventsTicks.push({tick, type:'cc64', value, chan});
        }
      } else {
        if(typeNib===0xc0 || typeNib===0xd0){ p+=1; } else { p+=2; }
      }
    }
  }
  // Build segments
  tempoTicks.sort((a,b)=>a.tick-b.tick);
  const localTempoMap = []; let accMs=0; let prevTick=0; let currentTempo=tempoTicks[0].tempo;
  localTempoMap.push({tick:0, timeMs:0, tempo:currentTempo});
  for(let i=1;i<tempoTicks.length;i++){
    const T=tempoTicks[i].tick; const dt=T-prevTick;
    accMs += (dt*currentTempo)/localTPQ/1000; prevTick=T; currentTempo=tempoTicks[i].tempo;
    localTempoMap.push({tick:T, timeMs:accMs, tempo:currentTempo});
  }
  function tickToMs(T){
    let idx=0; for(let i=localTempoMap.length-1;i>=0;i--){ if(localTempoMap[i].tick<=T){ idx=i; break; } }
    const seg=localTempoMap[idx]; return seg.timeMs + ( (T-seg.tick) * seg.tempo)/localTPQ/1000;
  }
  const localEvents = eventsTicks.map(e=>({ timeMs: tickToMs(e.tick), type:e.type, note:e.note, velocity:e.velocity, chan:e.chan, value:e.value }));
  localEvents.sort((a,b)=>a.timeMs-b.timeMs);
  return { events: localEvents, tempoMap: localTempoMap, ticksPerQuarter: localTPQ };
}
function parseMIDI(bytes){
  const {events, tempoMap:tm, ticksPerQuarter:tpq} = parseMIDIToEventList(bytes);
  midiEvents = events;
  tempoMap = tm;
  ticksPerQuarter = tpq;
  sustainEventTimes = midiEvents.filter(e=> e.type==='cc64' && (e.value|0)>=64).map(e=> e.timeMs);
  filterSentinelNotes();
  computeMidiActiveSpan();
  recomputeStretch();
  console.log('Tempo map (segments):', tempoMap);
  // Diagnostics for Baby: summarize MIDI duration
  if(currentTrackKey === 'baby'){
    let lastOff = 0; for(let i=midiEvents.length-1;i>=0;i--){ if(midiEvents[i].type==='off'){ lastOff = midiEvents[i].timeMs; break; } }
    const midiDur = (lastOff>midiFirstNoteMs) ? (lastOff - midiFirstNoteMs) : 0;
    console.log('[Diag:BABY] MIDI dur(ms)=', Math.round(midiDur), 'TPQ=', ticksPerQuarter, 'segments=', tempoMap.length);
  }
}
// Identify and remove the very first and very last short, inaudible notes
// as described by the user (e.g., velocity 1, very short duration),
// without affecting middle content.
const SENTINEL_VEL_MAX = 8;      // <= 8 considered inaudible
const SENTINEL_DUR_MS_MAX = 120; // <= 120ms considered short
function filterSentinelNotes(){
  sentinelFilteredCount = 0;
  // Pair note-ons to offs
  const active = new Map(); // key "chan:note" -> {idx,timeMs,velocity}
  const pairs = []; // {onIdx, offIdx, on, off, dur}
  for(let i=0;i<midiEvents.length;i++){
    const ev = midiEvents[i];
    if(ev.type==='on'){
      const key = `${ev.chan}:${ev.note}`;
      active.set(key, {idx:i, timeMs:ev.timeMs, velocity:ev.velocity});
    } else if(ev.type==='off'){
      const key = `${ev.chan}:${ev.note}`;
      const on = active.get(key);
      if(on){
        const dur = Math.max(0, ev.timeMs - on.timeMs);
        pairs.push({onIdx:on.idx, offIdx:i, on: midiEvents[on.idx], off: ev, dur});
        active.delete(key);
      }
    }
  }
  if(pairs.length===0) return;
  // earliest candidate
  const earliest = pairs.reduce((a,b)=> (a.on.timeMs <= b.on.timeMs ? a : b));
  // latest candidate by off time
  const latest = pairs.reduce((a,b)=> (a.off.timeMs >= b.off.timeMs ? a : b));
  const toRemoveIdx = new Set();
  function consider(pair){
    if(pair.on.velocity <= SENTINEL_VEL_MAX && pair.dur <= SENTINEL_DUR_MS_MAX){
      toRemoveIdx.add(pair.onIdx);
      toRemoveIdx.add(pair.offIdx);
    }
  }
  consider(earliest);
  if(latest !== earliest) consider(latest);
  if(toRemoveIdx.size){
    midiEvents = midiEvents.filter((_,i)=> !toRemoveIdx.has(i));
    sentinelFilteredCount = toRemoveIdx.size/2; // pairs count
    // recompute midiFirstNoteMs as earliest remaining on
    midiFirstNoteMs = 0;
    for(const ev of midiEvents){ if(ev.type==='on'){ midiFirstNoteMs = ev.timeMs; break; } }
  } else {
    // no filtering; compute first note if not set
    for(const ev of midiEvents){ if(ev.type==='on'){ midiFirstNoteMs = ev.timeMs; break; } }
  }
}
function computeMidiActiveSpan(){
  // With sentinels removed, first ON is midiFirstNoteMs; find last OFF
  let lastOff = 0;
  for(let i=midiEvents.length-1;i>=0;i--){
    const ev = midiEvents[i];
    if(ev.type==='off'){ lastOff = ev.timeMs; break; }
  }
  if(midiFirstNoteMs>0 && lastOff>midiFirstNoteMs){
    midiActiveDurationMs = lastOff - midiFirstNoteMs;
  } else {
    midiActiveDurationMs = 0;
  }
}
function recomputeStretch(){
  if(audioActiveDurationMs>0 && midiActiveDurationMs>0){
    const raw = audioActiveDurationMs / midiActiveDurationMs;
    const clamped = Math.min(1+STRETCH_CLAMP, Math.max(1-STRETCH_CLAMP, raw));
    midiStretch = clamped;
  } else {
    midiStretch = 1.0;
  }
  // Stretch impacts adjusted times; rebuild fall schedule if MIDI already loaded
}
function startMIDIPlayback(){
  if(!midiLoaded||playingMIDI||!audioCtx) return;
  // Ensure audio context is running (browser gesture requirement)
  if(audioCtx.state !== 'running'){
    safeRun(() => audioCtx.resume(), 'audioCtx resume');
  }
  // Remove lingering glow from previous session before starting new playback
  clearAllKeyGlow();
  // Hard stop anything lingering and reset position to start
  disposeAudioSource('startMIDIPlayback cleanup');
  savedAudioPosSec = 0;
  midiIndex = 0;
  resetKeys();
  const offsetMs = getSyncOffsetMs();
  const userOffsetSec = offsetMs/1000;
  const firstNoteSec = (midiFirstNoteMs||0)/1000;
  const lead = 0.2; // schedule slightly in the future for stability
  const now = audioCtx.currentTime;
  const t0 = now + lead;
  const tAudio = t0 + Math.max(userOffsetSec, 0);
  const tMidiZero = t0 + Math.max(-userOffsetSec, 0);
  // Align so that first MIDI note occurs exactly at tMidiZero
  midiStartCtxTime = tMidiZero - firstNoteSec;
  // Start audio at tAudio, skipping detected leading silence internally
  startAudio((tAudio - now)*1000);
  audioStartCtxTime = tAudio;
  playingMIDI=true; midiIndex=0;
  console.log('Playback start (audioCtx)', {offsetMs, firstNoteSec, t0, tAudio, tMidiZero, midiStartCtxTime});
}
function advanceMIDI(elapsedMs){
  if(midiIndex>=midiEvents.length) return;
  while(midiIndex < midiEvents.length){
    const ev = midiEvents[midiIndex];
    const adjTime = midiFirstNoteMs + (ev.timeMs - midiFirstNoteMs) * (midiStretch / Math.max(1e-6, currentPlaybackRate));
    if(adjTime > elapsedMs) break;
    midiIndex++;
    if(ev.type==='on' || ev.type==='off'){
      const state = keyAnimState.get(ev.note);
      if(!state) continue;
      const mesh = state.mesh;
      if(ev.type==='on'){
        const base = (isBlackKey(mesh)? BLACK_MAX : WHITE_MAX) * KEY_PRESS_SIGN;
        const vel = Math.max(VELOCITY_MIN, ev.velocity);
        const depthScale = (vel - VELOCITY_MIN) / (VELOCITY_MAX - VELOCITY_MIN);
        const target = base * (0.55 + 0.45 * depthScale);
        state.phase='press'; state.startMs=elapsedMs; state.fromAngle=mesh.rotation.x; state.targetAngle=target;
        // Apply glow while the note is active
        applyKeyGlow(mesh, ev.note, true);
      } else {
        state.phase='release'; state.startMs=elapsedMs; state.fromAngle=mesh.rotation.x; state.targetAngle=0;
        // Remove glow when the note-off occurs (respect overlapping notes via counter)
        applyKeyGlow(mesh, ev.note, false);
      }
    } else if(ev.type==='cc64'){
      if(!sustainPedalMesh) continue;
      const pressed = (ev.value|0) >= 64;
      if(pressed){
        // If previous release was still mid-way, force full rest (bounce up) before press
        if(sustainAnim.phase==='release'){
          sustainPedalMesh.rotation.x = 0;
          sustainAnim.fromAngle = 0;
        }
        // Optional quick bounce: small upward overshoot then press
        sustainAnim.phase='press';
        sustainAnim.startMs=elapsedMs;
        sustainAnim.fromAngle = sustainPedalMesh.rotation.x || 0;
        sustainAnim.targetAngle = PEDAL_MAX_ANGLE;
      } else {
        // Release logic with lookahead: if next press soon, use fast release
        const nextPress = sustainEventTimes.find(t => t>ev.timeMs);
        const soon = nextPress!==undefined && (nextPress - ev.timeMs) < PEDAL_LOOKAHEAD_MS;
        sustainAnim.phase='release';
        sustainAnim.startMs=elapsedMs;
        sustainAnim.fromAngle = sustainPedalMesh.rotation.x || 0;
        sustainAnim.targetAngle = 0;
        if(soon){
          // accelerate by temporarily adjusting constants (store original?)
          // We simulate by snapping closer to 0 immediately
          sustainPedalMesh.rotation.x = Math.max(0, sustainPedalMesh.rotation.x - PEDAL_BOUNCE_ANGLE);
        }
        // Once pedal goes up, apply sustain release to voices
        applySustainState();
      }
    }
  }
}
function updateKeyAnimations(){
  // elapsed MIDI time using context clock
  const elapsed = audioCtx ? (audioCtx.currentTime - midiStartCtxTime) * 1000 : 0;
  keyAnimState.forEach(st => {
    const mesh = st.mesh; if(!mesh) return;
    let dur=0;
    if(st.phase==='press') dur=PRESS_ATTACK_MS; else if(st.phase==='release') dur=RELEASE_DECAY_MS; else return;
    const t = (elapsed - st.startMs)/dur;
    if(t>=1){
      mesh.rotation.x = st.targetAngle;
      st.fromAngle=st.targetAngle;
      st.phase = (st.phase==='press')? 'held':'idle';
      return;
    }
    // smoothstep easing
    const e = t*t*(3-2*t);
    mesh.rotation.x = st.fromAngle + (st.targetAngle - st.fromAngle) * e;
  });
  // Sustain pedal easing
  if(sustainPedalMesh && sustainAnim.phase!=='idle'){
    const dur = sustainAnim.phase==='press' ? PEDAL_PRESS_MS : PEDAL_RELEASE_MS;
    const t = Math.max(0, (elapsed - sustainAnim.startMs)/Math.max(1,dur));
    if(t>=1){
      sustainPedalMesh.rotation.x = sustainAnim.targetAngle;
      sustainAnim.fromAngle = sustainAnim.targetAngle;
      sustainAnim.phase = (sustainAnim.phase==='press') ? 'held' : 'idle';
    } else {
      const e2 = t*t*(3-2*t);
      sustainPedalMesh.rotation.x = sustainAnim.fromAngle + (sustainAnim.targetAngle - sustainAnim.fromAngle) * e2;
    }
  }
}
// Update camera-dependent transforms (runs every frame)
function updateViewDrivenTransforms(){
  if(!tabletStandMesh || !root) return;
  const center = new THREE.Vector3();
  new THREE.Box3().setFromObject(root).getCenter(center);
  const toCam = new THREE.Vector3().subVectors(cam.position, center).normalize();
  const front = new THREE.Vector3(0,0,1);
  const up = new THREE.Vector3(0,1,0);
  const frontDot = THREE.MathUtils.clamp(front.dot(toCam), -1, 1);
  const upDot = THREE.MathUtils.clamp(up.dot(toCam), -1, 1);
  const wFront = Math.max(0, frontDot);
  const wTop = Math.max(0, upDot);
  const denom = wFront + wTop;
  let angle = 0;
  if(denom>1e-5){
    const tWeight = wFront/denom; // 0 top/back -> 0deg, 1 front -> 90deg
    angle = THREE.MathUtils.degToRad(90 * tWeight);
  }
  tabletStandMesh.rotation.x = angle;
}
// Hook play button if exists
const playBtn = document.getElementById('playPerformance');
if(playBtn){
  playBtn.addEventListener('click', ()=>{
    togglePlayPause();
  });
}
const trackBabyBtn = document.getElementById('trackBaby');
if(trackBabyBtn){ trackBabyBtn.addEventListener('click', ()=> selectTrack('baby')); }
const trackRaisinsBtn = document.getElementById('trackRaisins');
if(trackRaisinsBtn){ trackRaisinsBtn.addEventListener('click', ()=> selectTrack('raisins')); }
const trackForestsBtn = document.getElementById('trackForests');
if(trackForestsBtn){ trackForestsBtn.addEventListener('click', ()=> selectTrack('forests')); }
const restartBtn = document.getElementById('restartPlayback');
if(restartBtn){ restartBtn.addEventListener('click', ()=> restartFromBeginning()); }
const rateSel = document.getElementById('playbackRate');
if(rateSel){ rateSel.addEventListener('change', ()=> setPlaybackRate(parseFloat(rateSel.value||'1'))); }
// Animation buttons
const animA = document.getElementById('animRangeA');
const animB = document.getElementById('animRangeB');
if(animA){ animA.addEventListener('click', ()=> playAnimRange('A')); }
if(animB){ animB.addEventListener('click', ()=> playAnimRange('B')); }
// Initialize button label
updatePlayButton();
updateTrackButtons();
// Initial default track load
selectTrack(currentTrackKey);
// ---- Audio loading ----
async function loadAudio(url){
  try {
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const resp = await fetch(encodeURI(url));
    if(!resp.ok) throw new Error('Audio HTTP '+resp.status);
    const arr = await resp.arrayBuffer();
    audioBuffer = await audioCtx.decodeAudioData(arr);
    const trimRms = detectLeadingSilence(audioBuffer);
    const trimEnergy = detectOnsetByEnergy(audioBuffer);
    // Be conservative: skip at least as much as either detector suggests
    audioTrimMs = Math.min(MAX_TRIM_MS, Math.max(Math.max(trimRms,0), Math.max(trimEnergy,0)));
    // Disable leading trim for 'Forests' track per request
    if(currentTrackKey === 'forests') {
      audioTrimMs = 0;
    }
    // For Baby: new exports are perfectly aligned; apply NO trim
    if(currentTrackKey === 'baby') {
      audioTrimMs = 0;
    }
    // trailing end detection to get active duration
    const trailMs = detectTrailingSilence(audioBuffer);
    const totalMs = audioBuffer.duration*1000;
    const endActiveMs = Math.max(audioTrimMs, totalMs - trailMs);
    audioActiveDurationMs = Math.max(0, endActiveMs - audioTrimMs);
    recomputeStretch();
    localStorage.setItem('audioLeadTrimMs', String(audioTrimMs));
    audioReady=true; audioError=false; console.log('[Track:'+currentTrackKey+'] Audio loaded trimMs=', audioTrimMs.toFixed(1)); updatePlayButton();
    // Diagnostics for Baby: summarize audio vs MIDI duration and raw stretch
    if(currentTrackKey === 'baby'){
      console.log('[Diag:BABY] Audio total(ms)=', Math.round(totalMs), 'active(ms)=', Math.round(audioActiveDurationMs), 'trim(ms)=', Math.round(audioTrimMs));
      if(midiActiveDurationMs>0){
        const raw = audioActiveDurationMs / midiActiveDurationMs;
        console.log('[Diag:BABY] raw stretch audio/midi =', raw.toFixed(6));
      }
    }
  } catch(e){ console.error('Audio load failed', e); audioError=true; updatePlayButton(); }
}
async function loadTrackAudio(candidates){
  if(!Array.isArray(candidates) || candidates.length===0){ audioError=true; updatePlayButton(); return; }
  console.log('[loadTrackAudio] candidates=', candidates);
  for(let i=0;i<candidates.length;i++){
    const url = candidates[i];
    const resolved = (window && window.mediaUrl) ? window.mediaUrl(url) : url;
    audioReady=false; audioError=false;
    try {
      await loadAudio(resolved);
      if(audioReady){
        console.log('[Track:'+currentTrackKey+'] Using audio source:', resolved);
        return;
      }
    } catch(e){
      console.warn('[loadTrackAudio] candidate failed', resolved, e);
    }
  }
  audioError=true; audioReady=false; console.error('[Track:'+currentTrackKey+'] All audio candidates failed'); updatePlayButton();
}
function startAudio(delayMs=0){
  if(!audioReady||audioPlaying) return;
  // Ensure no overlapping sources
  disposeAudioSource('startAudio cleanup');
  audioSource = audioCtx.createBufferSource();
  audioSource.buffer = audioBuffer;
  audioSource.playbackRate.setValueAtTime(currentPlaybackRate, audioCtx.currentTime);
  audioSource.connect(audioCtx.destination);
  const when = audioCtx.currentTime + Math.max(0, delayMs)/1000;
  const offset = Math.max(0, (audioTrimMs/1000) + savedAudioPosSec);
  audioSource.onended = ()=>{ audioPlaying=false; playingMIDI=false; savedAudioPosSec=0; resetKeys(); clearAllKeyGlow(); updatePlayButton(); };
  audioSource.start(when, offset);
  audioPlaying=true;
}
function detectLeadingSilence(buffer){
  try {
    const ch = buffer.getChannelData(0);
    const len = ch.length;
    let idx=0;
    while(idx < len){
      const end = Math.min(idx+TRIM_WINDOW_SAMPLES, len);
      let sumSq=0;
      for(let i=idx;i<end;i++){ const v=ch[i]; sumSq += v*v; }
      const rms = Math.sqrt(sumSq/(end-idx));
      if(rms > TRIM_THRESHOLD) break;
      idx = end;
      if((idx/buffer.sampleRate)*1000 > MAX_TRIM_MS) break;
    }
    const ms = Math.min(MAX_TRIM_MS, (idx/buffer.sampleRate)*1000);
    return ms;
  } catch(e){ console.warn('detectLeadingSilence failed', e); return 0; }
}
function detectTrailingSilence(buffer){
  try {
    const ch = buffer.getChannelData(0);
    const len = ch.length;
    let idx=len;
    while(idx > 0){
      const start = Math.max(0, idx-TRIM_WINDOW_SAMPLES);
      let sumSq=0; const count = idx-start;
      for(let i=start;i<idx;i++){ const v=ch[i]; sumSq += v*v; }
      const rms = Math.sqrt(sumSq/Math.max(1,count));
      if(rms > TRIM_THRESHOLD) break;
      idx = start;
      const elapsedMs = ((len-idx)/buffer.sampleRate)*1000;
      if(elapsedMs > MAX_TRIM_MS) break;
    }
    const ms = Math.min(MAX_TRIM_MS, ((len-idx)/buffer.sampleRate)*1000);
    return ms;
  } catch(e){ console.warn('detectTrailingSilence failed', e); return 0; }
}
// Short-time energy onset detection
function detectOnsetByEnergy(buffer){
  try {
    const sr = buffer.sampleRate;
    const ch0 = buffer.getChannelData(0);
    const ch1 = buffer.numberOfChannels>1 ? buffer.getChannelData(1) : null;
    const frame = 1024; const hop = 512;
    const n = Math.floor((ch0.length - frame)/hop);
    const energy = new Float32Array(Math.max(0,n));
    let maxE = 0;
    for(let i=0;i<n;i++){
      let sum=0; const off=i*hop;
      for(let k=0;k<frame;k++){
        const s0 = ch0[off+k]||0; const s1 = ch1? ch1[off+k] : 0;
        const s = (s0 + s1)*0.5; sum += s*s;
      }
      const e = sum/frame; energy[i]=e; if(e>maxE) maxE=e;
    }
    // Normalize and compute flux
    const flux = new Float32Array(energy.length);
    for(let i=1;i<energy.length;i++){
      const d = Math.max(0, energy[i]-energy[i-1]);
      flux[i] = d;
    }
    // Moving average baseline
    const win=8; let bestIdx=0;
    for(let i=win;i<flux.length;i++){
      let mean=0, varsum=0;
      for(let j=i-win;j<i;j++) mean += flux[j];
      mean/=win;
      for(let j=i-win;j<i;j++){ const dv=flux[j]-mean; varsum += dv*dv; }
      const std = Math.sqrt(varsum/win) || 1e-6;
      const z = (flux[i]-mean)/std;
      // Require energy also above small threshold
      if(z>3 && energy[i]> (0.005*maxE)){
        bestIdx = i; break;
      }
    }
    const ms = Math.min(MAX_TRIM_MS, (bestIdx*hop)/sr*1000);
    return ms||0;
  } catch(e){ console.warn('detectOnsetByEnergy failed', e); return 0; }
}
function selectTrack(key){
  if(!TRACKS[key]){ console.warn('Unknown track', key); return; }
  currentTrackKey = key;
  console.log('[selectTrack]', key, TRACKS[key]);
  // Stop current playback and reset state
  disposeAudioSource('selectTrack cleanup');
  audioPlaying=false; playingMIDI=false;
  savedAudioPosSec=0; midiIndex=0; midiLoaded=false; audioReady=false; midiError=false; audioError=false;
  midiEvents=[]; midiFirstNoteMs=0; midiActiveDurationMs=0; midiStretch=1.0; sentinelFilteredCount=0;
  updatePlayButton(); resetKeys();
  clearAllKeyGlow();
  // Load assets for track
  const t = TRACKS[key];
  loadTrackAudio(t.audioCandidates || [t.audio]);
  loadMIDI(t.midi);
  updateTrackButtons();
}
function updateTrackButtons(){
  const all = [
    document.getElementById('trackBaby'),
    document.getElementById('trackRaisins'),
    document.getElementById('trackForests')
  ];
  all.forEach(btn=>{
    if(!btn) return;
    const isActive = btn.dataset.track === currentTrackKey;
    btn.style.background = isActive ? 'rgba(90,200,160,0.6)' : 'rgba(255,255,255,0.15)';
    btn.style.color = '#fff';
    btn.style.border = isActive ? '1px solid #6ff' : '1px solid #444';
  });
}
// ---- Player controls logic ----
function updatePlayButton(){
  const btn = document.getElementById('playPerformance');
  if(!btn) return;
  if(audioError || midiError){
    btn.textContent = 'Load Error';
    btn.disabled = true; return;
  }
  btn.textContent = (audioPlaying||playingMIDI) ? 'Pause' : 'Play';
  btn.disabled = !midiLoaded || !audioReady;
}
function togglePlayPause(){
  if(!audioCtx || !audioReady || !midiLoaded){ return; }
  if(audioPlaying){
    // Pause: capture position, stop source, freeze MIDI index and clock origin
    const now = audioCtx.currentTime;
    const playedSec = (now - audioStartCtxTime) * currentPlaybackRate;
    savedAudioPosSec += Math.max(0, playedSec);
    disposeAudioSource('togglePlayPause cleanup');
    audioPlaying=false; playingMIDI=false; // will resume from savedAudioPosSec
    clearAllKeyGlow();
    updatePlayButton();
  } else {
    // If starting fresh (no saved position), use full alignment path
    if(savedAudioPosSec===0){
      startMIDIPlayback();
      updatePlayButton();
    } else {
      // Resume from saved position: set midiStartCtxTime so elapsed maps to saved position
      const now = audioCtx.currentTime;
      const lead = 0.05;
      const t0 = now + lead;
      const midiElapsedMs = (savedAudioPosSec*1000) / Math.max(1e-6, currentPlaybackRate);
      midiStartCtxTime = t0 - (midiElapsedMs/1000);
      startAudio((t0 - now)*1000);
      audioStartCtxTime = t0;
      playingMIDI=true;
      // Advance midiIndex to match saved position
      midiIndex = 0;
      advanceMIDI(savedAudioPosSec*1000);
      updatePlayButton();
    }
  }
}
function restartFromBeginning(){
  if(!audioCtx || !audioReady || !midiLoaded) return;
  // Stop any current playback
  disposeAudioSource('restartFromBeginning cleanup');
  audioPlaying=false; playingMIDI=false;
  savedAudioPosSec = 0;
  midiIndex = 0;
  resetKeys();
  clearAllKeyGlow();
  // Schedule fresh start with current offset and rate
  startMIDIPlayback();
  updatePlayButton();
}
function setPlaybackRate(rate){
  if(!isFinite(rate) || rate<=0) return;
  const wasPlaying = !!audioPlaying;
  // If currently playing, convert current position to saved, stop; we'll optionally resume
  if(audioCtx && wasPlaying){
    const now = audioCtx.currentTime;
    const playedSec = (now - audioStartCtxTime) * currentPlaybackRate;
    savedAudioPosSec += Math.max(0, playedSec);
    disposeAudioSource('setPlaybackRate cleanup');
    audioPlaying=false; playingMIDI=false;
  }
  currentPlaybackRate = rate;
  // Resume only if we were playing
  if(audioCtx && audioReady && midiLoaded && wasPlaying){
    togglePlayPause(); // resumes from saved position at new rate
  }
}
function resetKeys(){
  // Zero out all key rotations and clear animation state
  keyAnimState.forEach(st => {
    if(st.mesh){ st.mesh.rotation.x = 0; }
    st.phase = 'idle';
    st.startMs = 0;
    st.fromAngle = 0;
    st.targetAngle = 0;
  });
  pressState.forEach((_, mesh)=>{ if(mesh) pressState.set(mesh, 0); });
}
function stopAllAnimActions(){
  const all = [...animActionsA, ...animActionsB];
  all.forEach(action=>{
    if(!action) return;
    safeRun(() => action.stop(), 'anim action stop');
    safeRun(() => action.reset(), 'anim action reset');
  });
}
function playAnimRange(which){
  if(!animationMixer) return;
  stopAllAnimActions();
  const list = which==='A' ? animActionsA : animActionsB;
  list.forEach(action=>{
    action.reset();
    action.setLoop(THREE.LoopOnce, 0);
    action.clampWhenFinished = true;
    action.play();
  });
}
// ---- Key picking & basic synth note playback ----
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
// Track pointer-down state to distinguish click vs drag
let pointerDownInfo = null; // { startX, startY, moved, midiNum, mesh, played, playedAt, glowApplied }
let pendingPlayTimer = null;
const MIN_USER_NOTE_MS = 250;
function midiNameToNumber(name){ const m = name.match(/^(\d{3})_/); return m? parseInt(m[1],10) : null; }
// Simple polyphonic piano-like synth with sustain support
const activeVoices = new Map(); // midiNum -> {osc, gain, stopTime, mesh}
function playUserNote(midiNum, mesh){
  if(midiNum==null) return;
  // Require a loaded sampled instrument; otherwise do nothing (no oscillator fallback)
  if(!instrumentPlayer){
    // still provide immediate visual feedback only
    if(mesh){ const base = (isBlackKey(mesh)? BLACK_MAX : WHITE_MAX) * KEY_PRESS_SIGN; mesh.rotation.x = base * 0.6; }
    return;
  }
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state !== 'running'){ safeRun(() => audioCtx.resume(), 'audioCtx resume'); }
  const now = audioCtx.currentTime;
  const existingNode = activeSampleNodes.get(midiNum);
  if(existingNode && existingNode.stop){ try{ existingNode.stop(); }catch(e){} }
  try{
    console.log('playing sample', currentInstrumentName, midiNum);
    const node = instrumentPlayer.play(midiNum, now, {gain:1});
    activeSampleNodes.set(midiNum, node);
    setTimeout(()=>{ activeSampleNodes.delete(midiNum); }, 6000);
  }catch(e){ console.warn('Instrument play failed', e); }
  // Update instrument picker status if present
  try{
    const status = document.querySelector('#instrumentPicker > div');
    if(status) status.textContent = 'Playing: ' + (currentInstrumentName || '') + ' ' + midiNum;
    setTimeout(()=>{ if(status) status.textContent = 'Loaded: ' + (currentInstrumentName || ''); }, 120);
  }catch(e){}
  if(mesh){ const base = (isBlackKey(mesh)? BLACK_MAX : WHITE_MAX) * KEY_PRESS_SIGN; mesh.rotation.x = base * 0.6; }
}

// Stop a user-triggered note quickly and remove glow
function stopUserNote(midiNum){
  // Audio: only stop sample nodes if an instrument is loaded; no oscillator fallback
  const nowSec = (audioCtx ? audioCtx.currentTime : 0);
  if(instrumentPlayer){
    const sampleNode = activeSampleNodes.get(midiNum);
    if(sampleNode){
      try{
        const fadeSec = 0.18;
        const when = nowSec + (MIN_USER_NOTE_MS/1000) + fadeSec;
        if(sampleNode.stop) sampleNode.stop(when);
      }catch(e){ console.warn('sample stop failed', e); }
      activeSampleNodes.delete(midiNum);
    }
  }
  // remove glow immediately
  const mesh = midiKeyMap.get(midiNum);
  if(mesh) applyKeyGlow(mesh, midiNum, false);
  // restore visual key rotation when safe (unless MIDI is controlling it)
  try{
    const st = keyAnimState.get(midiNum);
    if(!st || st.phase === 'idle'){
      const m = mesh || (v && v.mesh);
      if(m) m.rotation.x = 0;
    }
  }catch(e){ /* ignore */ }
}

function onGlobalPointerMove(e){
  if(!pointerDownInfo) return;
  const dx = e.clientX - pointerDownInfo.startX;
  const dy = e.clientY - pointerDownInfo.startY;
  const dist2 = dx*dx + dy*dy;
  if(!pointerDownInfo.moved && dist2 > (8*8)){
    pointerDownInfo.moved = true;
    // cancel any pending play
    if(pendingPlayTimer){ clearTimeout(pendingPlayTimer); pendingPlayTimer = null; }
    // if we already played a note because of timeout, stop it quickly (respect min duration)
    if(pointerDownInfo.played){ stopUserNote(pointerDownInfo.midiNum); pointerDownInfo.played = false; }
    // If we applied immediate visual glow but are now moving, remove it
    if(pointerDownInfo.glowApplied){ applyKeyGlow(pointerDownInfo.mesh, pointerDownInfo.midiNum, false); pointerDownInfo.glowApplied = false; }
    // If pointer started on a key, keep rotate disabled until release; do not enable rotate here
    // (dragging that started outside keys continues to rotate normally)
  }
  // If pointer is down on a key and moved, perform glissando: play notes under pointer as it crosses
  if(pointerDownInfo && pointerDownInfo.moved){
    // compute normalized pointer coords relative to canvas
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
    pointer.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
    raycaster.setFromCamera(pointer, cam);
    const intersects = root ? raycaster.intersectObject(root, true) : [];
    if(intersects.length){
      const hit = intersects[0].object;
      const res = findKeyFromObject(hit);
      if(res && res.midiNum !== pointerDownInfo.lastMidi){
        pointerDownInfo.lastMidi = res.midiNum;
        // play the note and apply glow
        playUserNote(res.midiNum, res.mesh);
        applyKeyGlow(res.mesh, res.midiNum, true);
        // schedule a stop after minimum duration to avoid long-held gliss notes
        setTimeout(()=>{ stopUserNote(res.midiNum); }, MIN_USER_NOTE_MS + 20);
      }
    }
  }
}

function onGlobalPointerUp(e){
  if(!pointerDownInfo) return;
  // If pointer up without significant move, ensure we played the note (if not yet)
  if(!pointerDownInfo.moved){
    if(!pointerDownInfo.played){
      // Play now if it wasn't played yet
      playUserNote(pointerDownInfo.midiNum, pointerDownInfo.mesh);
      pointerDownInfo.played = true;
    }
    // User released: stop note, but stopUserNote enforces minimum duration
    if(pointerDownInfo.played){
      stopUserNote(pointerDownInfo.midiNum);
    }
  }
  // cleanup
  if(pendingPlayTimer){ clearTimeout(pendingPlayTimer); pendingPlayTimer = null; }
  pointerDownInfo = null;
}
// Handle pedal release affecting sustained voices
function applySustainState(){
  const sustainActive = (sustainAnim.phase==='press' || sustainAnim.phase==='held');
  if(!sustainActive){
    // Begin release on all voices that were held
    const now = audioCtx ? audioCtx.currentTime : 0;
    activeVoices.forEach(v => {
      if(v.stopping) return;
      v.stopping=true;
      v.gain.gain.cancelScheduledValues(now);
      v.gain.gain.setValueAtTime(v.gain.gain.value, now);
      v.gain.gain.exponentialRampToValueAtTime(0.0001, now+0.9);
      setTimeout(()=>{ safeRun(() => { v.osc.stop(); v.oscB.stop(); v.oscC.stop(); }, 'sustain voice release'); }, 1000);
    });
    // After release, clear map gradually
    setTimeout(()=>{ activeVoices.clear(); }, 1100);
  }
}
function findKeyFromObject(obj){
  let cur = obj;
  while(cur){
    const n = cur.name || '';
    const num = midiNameToNumber(n);
    if(Number.isInteger(num)) return {mesh:cur, midiNum:num};
    // Compare against midiKeyMap values
    for(const [nn, m] of midiKeyMap.entries()){ if(m===cur) return {mesh:cur, midiNum:nn}; }
    cur = cur.parent;
  }
  return null;
}
let suppressRotate = false;
function onPointerDown(e){
  // Ignore right-clicks for note playing
  if(e.button === 2) return;
  const rect = canvas.getBoundingClientRect();
  pointer.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
  pointer.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
  raycaster.setFromCamera(pointer, cam);
  const intersects = root ? raycaster.intersectObject(root, true) : [];
  if(intersects.length){
    const hit = intersects[0].object;
    const res = findKeyFromObject(hit);
    if(res){
      // Start tracking to detect drag vs click. Apply immediate visual feedback so quick taps highlight.
      pointerDownInfo = { startX: e.clientX, startY: e.clientY, moved: false, midiNum: res.midiNum, mesh: res.mesh, played: false, playedAt: null, glowApplied: false };
      // Immediately apply visual glow so quick taps show highlight even before audio starts
      applyKeyGlow(res.mesh, res.midiNum, true);
      pointerDownInfo.glowApplied = true;
      // Disable rotation while pointer is down on a key to prevent accidental rotate
      controls.enableRotate = false; suppressRotate = true;
      // Start audio shortly after (small debounce helps avoid accidental touch-drag triggers)
      pendingPlayTimer = setTimeout(()=>{
        if(pointerDownInfo && !pointerDownInfo.moved){
          playUserNote(pointerDownInfo.midiNum, pointerDownInfo.mesh);
          pointerDownInfo.played = true;
          pointerDownInfo.playedAt = performance.now();
        }
        pendingPlayTimer = null;
      }, 40);
      e.preventDefault();
      return;
    }
  }
}

function onPointerUp(){
  // If we had a tracked press, handle play/stop logic
  onGlobalPointerUp();
  if(suppressRotate){ controls.enableRotate=true; suppressRotate=false; }
}
canvas.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointerup', onPointerUp);
// Global move listener for drag detection
window.addEventListener('pointermove', onGlobalPointerMove);
// Prevent context menu from right-clicking the canvas
canvas.addEventListener('contextmenu', (ev)=>{ ev.preventDefault(); });

===== END FILE: music-piano.js =====


===== START FILE: music-tablet.js =====

// Music page tablet: single video thumbnail + player.
// This is intentionally self-contained and ONLY touches the
// tablet screen mesh. It does NOT know about or modify the
// main page play button (`playPerformance`) or any music
// playback functions.

import * as THREE from 'three';

// Path to the HQ video and its thumbnail. Resolve via mediaUrl when MEDIA_BASE set.
const TABLET_VIDEO_SRC = (window && window.mediaUrl) ? window.mediaUrl('Videos/videos-page/music-videos-hq.webm') : 'Videos/videos-page/music-videos-hq.webm';
const TABLET_THUMB_SRC = (window && window.mediaUrl) ? window.mediaUrl('Videos/videos-page/music-videos.jpg') : 'Videos/videos-page/music-videos.jpg';

// Public entry point used by `music-piano.js` / `music-piano-debug.js`.
// It is safe if the tablet mesh is not found; it will just return null.
export function setupMusicTabletScreen(rootObject3D) {
  if (!rootObject3D) return null;

  let screenMesh = null;

  // First, try to find the exact tablet screen mesh by name.
  rootObject3D.traverse(obj => {
    if (screenMesh || !obj.isMesh) return;
    const name = obj.name || '';
    if (name === "pe'rPad_screen") {
      screenMesh = obj;
    }
  });

  // Fallback: loose match if that specific mesh is ever renamed.
  if (!screenMesh) {
    rootObject3D.traverse(obj => {
      if (screenMesh || !obj.isMesh) return;
      if (/screen|tablet/i.test(obj.name || '')) {
        screenMesh = obj;
      }
    });
  }

  if (!screenMesh || !screenMesh.material) return null;

  const CW = 2048;
  const CH = 1280; // ~16:10 canvas to better match tablet
  const canvas = document.createElement('canvas');
  canvas.width = CW;
  canvas.height = CH;
  const ctx = canvas.getContext('2d');
  if (!ctx) return null;

  const texture = new THREE.CanvasTexture(canvas);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = 8;
  texture.flipY = false;

  const material = Array.isArray(screenMesh.material)
    ? screenMesh.material[0]
    : screenMesh.material;
  material.map = texture;
  material.emissive = new THREE.Color(0xffffff);
  material.emissiveIntensity = 1.0;
  material.emissiveMap = texture;
  material.needsUpdate = true;

  // If the tablet only uses a subset of UVs, remap so our
  // full 0..1 canvas fills that region.
  const uvRemap = { repeatU: 1, repeatV: 1, offsetU: 0, offsetV: 0 };
  try {
    const geo = screenMesh.geometry;
    if (geo && geo.attributes && geo.attributes.uv) {
      const uv = geo.attributes.uv;
      let umin = 1, vmin = 1, umax = 0, vmax = 0;
      for (let i = 0; i < uv.count; i++) {
        const u = uv.getX(i);
        const v = uv.getY(i);
        if (u < umin) umin = u;
        if (u > umax) umax = u;
        if (v < vmin) vmin = v;
        if (v > vmax) vmax = v;
      }
      const ur = Math.max(1e-4, umax - umin);
      const vr = Math.max(1e-4, vmax - vmin);
      const repU = 1 / ur;
      const repV = 1 / vr;
      const offU = -umin / ur;
      const offV = -vmin / vr;
      uvRemap.repeatU = repU;
      uvRemap.repeatV = repV;
      uvRemap.offsetU = offU;
      uvRemap.offsetV = offV;
      texture.repeat.set(repU, repV);
      texture.offset.set(offU, offV);
      texture.needsUpdate = true;
    }
  } catch (e) {
    console.warn('music-tablet uv remap failed', e);
  }

  // Layout: full-bleed 16:9 video area, with a subtle
  // dark frame/background and a play button in the center.
  const BG_COLOR = '#041019';
  const FRAME_COLOR = '#0d2638';
  const FRAME_PAD = Math.round(CW * 0.015);

  // Use almost the full tablet height, then make the inner
  // video area strictly 16:9 by width so it "touches" the
  // left/right bezel edges visually.
  const videoRect = {
    x: FRAME_PAD,
    y: FRAME_PAD,
    w: CW - FRAME_PAD * 2,
    h: CH - FRAME_PAD * 2,
  };

  // Enforce 16:9 using width and adjust height.
  const targetW = videoRect.w;
  const targetH = Math.round(targetW * (9 / 16));
  const padY = Math.max(0, Math.round((videoRect.h - targetH) / 2));
  videoRect.y += padY;
  videoRect.h = targetH;

  // Simple state for this tablet only.
  const state = {
    mode: 'thumbnail', // 'thumbnail' | 'playing'
    hoverPlay: false,
  };

  const videoEl = document.createElement('video');
  videoEl.src = encodeURI(TABLET_VIDEO_SRC);
  videoEl.playsInline = true;
  videoEl.muted = false;
  videoEl.preload = 'metadata';
  videoEl.crossOrigin = 'anonymous';

  const thumbImg = new Image();
  thumbImg.src = encodeURI(TABLET_THUMB_SRC);
  thumbImg.crossOrigin = 'anonymous';

  function drawFrame() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, CW, CH);

    ctx.fillStyle = FRAME_COLOR;
    ctx.fillRect(
      videoRect.x - FRAME_PAD,
      videoRect.y - FRAME_PAD,
      videoRect.w + FRAME_PAD * 2,
      videoRect.h + FRAME_PAD * 2,
    );

    let source = null;
    if (state.mode === 'playing' && videoEl.readyState >= 2) {
      source = videoEl;
    } else if (thumbImg.complete) {
      source = thumbImg;
    }

    if (source) {
      drawFitted(source, videoRect);
    } else {
      ctx.fillStyle = '#000';
      ctx.fillRect(videoRect.x, videoRect.y, videoRect.w, videoRect.h);
    }

    // Centered tablet-only play button. Name is distinct from
    // the main page button to avoid any overlap.
    drawTabletPlayButton();

    texture.needsUpdate = true;
  }

  function drawFitted(source, rect) {
    const { x, y, w, h } = rect;
    const sw = source.videoWidth || source.width || 0;
    const sh = source.videoHeight || source.height || 0;
    if (!sw || !sh) {
      ctx.fillStyle = '#000';
      ctx.fillRect(x, y, w, h);
      return;
    }

    // Preserve source aspect ratio inside the target rect (no rotation).
    const ar = sw / sh;
    const tr = w / h;
    let dw = w;
    let dh = h;
    if (ar > tr) {
      dh = Math.round(w / ar);
    } else {
      dw = Math.round(h * ar);
    }
    const dx = x + Math.round((w - dw) / 2);
    const dy = y + Math.round((h - dh) / 2);
    ctx.drawImage(source, dx, dy, dw, dh);
  }

  function drawTabletPlayButton() {
    const cx = videoRect.x + Math.round(videoRect.w / 2);
    const cy = videoRect.y + Math.round(videoRect.h / 2);
    const r = Math.round(Math.min(videoRect.w, videoRect.h) * 0.12);

    const baseFill = state.mode === 'playing' ? 'rgba(0,0,0,0.55)' : 'rgba(0,0,0,0.75)';
    const hoverBoost = state.hoverPlay ? 1.15 : 1.0;

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.65)';
    ctx.shadowBlur = r * 0.8;
    ctx.beginPath();
    ctx.arc(cx, cy, r * hoverBoost, 0, Math.PI * 2);
    ctx.fillStyle = baseFill;
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.beginPath();
    if (state.mode === 'playing') {
      const bw = r * 0.35;
      const bh = r * 0.85;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(cx - bw - bw * 0.35, cy - bh / 2, bw, bh);
      ctx.fillRect(cx + bw * 0.35, cy - bh / 2, bw, bh);
    } else {
      ctx.moveTo(cx - r * 0.35, cy - r * 0.5);
      ctx.lineTo(cx + r * 0.55, cy);
      ctx.lineTo(cx - r * 0.35, cy + r * 0.5);
      ctx.closePath();
      ctx.fillStyle = '#ffffff';
      ctx.fill();
    }
    ctx.restore();
  }

  thumbImg.onload = () => drawFrame();
  videoEl.addEventListener('loadeddata', () => {
    if (state.mode === 'playing') drawFrame();
  });
  videoEl.addEventListener('timeupdate', () => {
    if (state.mode === 'playing') drawFrame();
  });
  videoEl.addEventListener('ended', () => {
    state.mode = 'thumbnail';
    state.hoverPlay = false;
    drawFrame();
  });

  // Initial paint
  drawFrame();

  // Pointer interaction: raycast against the tablet screen only.
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  const rendererCanvas = document.querySelector('canvas#pianoCanvas');

  if (!rendererCanvas) {
    return { canvas, videoEl };
  }

  function uvToCanvas(uv) {
    const u = uv.x * uvRemap.repeatU + uvRemap.offsetU;
    const v = uv.y * uvRemap.repeatV + uvRemap.offsetV;
    return {
      x: THREE.MathUtils.clamp(u, 0, 1) * CW,
      y: THREE.MathUtils.clamp(v, 0, 1) * CH,
    };
  }

  function hitPlayRegion(ev) {
    const rect = rendererCanvas.getBoundingClientRect();
    pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    const camera = findCameraForObject(rootObject3D);
    if (!camera) return { overPlay: false, clickPlay: false };
    raycaster.setFromCamera(pointer, camera);
    const hits = raycaster.intersectObject(screenMesh, true);
    if (!hits.length || !hits[0].uv) return { overPlay: false, clickPlay: false };
    const pt = uvToCanvas(hits[0].uv);
    const cx = videoRect.x + videoRect.w / 2;
    const cy = videoRect.y + videoRect.h / 2;
    const r = Math.min(videoRect.w, videoRect.h) * 0.14;
    const dx = pt.x - cx;
    const dy = pt.y - cy;
    const over = dx * dx + dy * dy <= r * r;
    return { overPlay: over, clickPlay: over };
  }

  function onPointerMove(ev) {
    const { overPlay } = hitPlayRegion(ev);
    const nextHover = !!overPlay;
    if (nextHover !== state.hoverPlay) {
      state.hoverPlay = nextHover;
      drawFrame();
    }
  }

  function onPointerDown(ev) {
    const { clickPlay } = hitPlayRegion(ev);
    if (!clickPlay) return;
    ev.preventDefault();
    if (state.mode === 'thumbnail') {
      state.mode = 'playing';
      try { videoEl.play(); } catch (e) { console.warn('tablet video play failed', e); }
      drawFrame();
    } else {
      // tablet play/pause toggle - distinct from main controls
      if (videoEl.paused) {
        try { videoEl.play(); } catch (e) { console.warn('tablet video resume failed', e); }
      } else {
        try { videoEl.pause(); } catch (e) { console.warn('tablet video pause failed', e); }
      }
      drawFrame();
    }
  }

  rendererCanvas.addEventListener('pointermove', onPointerMove);
  rendererCanvas.addEventListener('pointerdown', onPointerDown);

  return { canvas, videoEl };
}

function findCameraForObject(root) {
  if (!root) return null;
  let scene = root;
  while (scene.parent) scene = scene.parent;
  if (scene.isScene) {
    const cameras = [];
    scene.traverse(obj => {
      if (obj.isCamera) cameras.push(obj);
    });
    if (cameras.length) return cameras[0];
  }
  return null;
}

===== END FILE: music-tablet.js =====


===== START FILE: music-transcription.js =====

// Tablet screen overlay for the music page (piano tablet)
// Creates a canvas texture on the `pe'rPad_screen` mesh and
// draws a sheet-music style UI with a yellow frame and controls.

import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';

// Palette shared with piano scene: yellow frame + white-key glow green
const PALETTE = {
  bg: '#050913',          // tablet background
  frame: '#ffd54f',       // yellow frame
  staffLines: '#f5f5f5',  // light staff lines
  staffBars: '#e0e0e0',   // bar lines / beat ticks
  text: '#f5f5f5',
  panelBg: '#060a12',
  panelBorder: '#ffd54f',
  // Match GlowMaterials['keys_white_glow'].color (0x17FF1C)
  accentGreen: '#17ff1c'
};

// Layout helper: computes content rect, panel area, staff areas, bars and beats
function computeLayout(CW, CH, margin, opts = {}) {
  const bars = opts.bars || 4;
  const beatsPerBar = opts.beatsPerBar || 4;

  const contentRect = {
    x: margin,
    y: margin,
    w: CW - margin * 2,
    h: CH - margin * 2
  };

  const panelFrac = 0.16; // narrow control strip
  const gutterX = Math.round(contentRect.w * 0.02);
  const panelRect = {
    x: contentRect.x,
    y: contentRect.y,
    w: Math.round(contentRect.w * panelFrac),
    h: contentRect.h
  };

  const rightInset = Math.round(contentRect.w * 0.035); // extra breathing room on right
  const staffRect = {
    x: panelRect.x + panelRect.w + gutterX,
    y: contentRect.y,
    w: contentRect.w - panelRect.w - gutterX - rightInset,
    h: contentRect.h
  };

  // Vertical padding so staff blocks have similar margins top/bottom
  const topPad = Math.round(staffRect.h * 0.12);
  const bottomPad = topPad;
  const usableH = staffRect.h - topPad - bottomPad;
  const gap = Math.round(usableH * 0.10);
  const bandH = Math.floor((usableH - gap) / 2);

  const trebleRect = {
    x: staffRect.x,
    y: staffRect.y + topPad,
    w: staffRect.w,
    h: bandH
  };
  const bassRect = {
    x: staffRect.x,
    y: trebleRect.y + trebleRect.h + gap,
    w: staffRect.w,
    h: bandH
  };

  const barWidth = staffRect.w / bars;
  const barRects = [];
  const beatX = [];
  for (let b = 0; b < bars; b++) {
    const bx = staffRect.x + b * barWidth;
    const bw = barWidth;
    barRects.push({ x: bx, y: staffRect.y, w: bw, h: staffRect.h });
    const beats = [];
    for (let i = 0; i < beatsPerBar; i++) {
      const t = (i + 0.5) / beatsPerBar; // center of beat
      beats.push(bx + bw * t);
    }
    beatX.push(beats);
  }

  return {
    contentRect,
    panelRect,
    staffRect,
    trebleRect,
    bassRect,
    bars,
    beatsPerBar,
    barRects,
    beatX
  };
}

function drawTabletFrame(ctx, CW, CH, margin) {
  ctx.fillStyle = PALETTE.bg;
  ctx.fillRect(0, 0, CW, CH);
  ctx.strokeStyle = PALETTE.frame;
  ctx.lineWidth = 4;
  ctx.strokeRect(margin + 0.5, margin + 0.5, CW - margin * 2 - 1, CH - margin * 2 - 1);
}

function drawStaffBand(ctx, rect) {
  const lineGap = rect.h / 10; // 11-line system (0..10), middle implied
  ctx.strokeStyle = PALETTE.staffLines;
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  // Draw top 5 and bottom 5 lines; leave center gap where middle line will appear only for notes
  for (let i = 0; i < 5; i++) {
    const y = rect.y + i * lineGap;
    ctx.beginPath();
    ctx.moveTo(rect.x, Math.round(y) + 0.5);
    ctx.lineTo(rect.x + rect.w, Math.round(y) + 0.5);
    ctx.stroke();
  }
  for (let i = 6; i < 11; i++) {
    const y = rect.y + i * lineGap;
    ctx.beginPath();
    ctx.moveTo(rect.x, Math.round(y) + 0.5);
    ctx.lineTo(rect.x + rect.w, Math.round(y) + 0.5);
    ctx.stroke();
  }
}

function drawBarsAndBeats(ctx, layout) {
  const { trebleRect, bassRect, barRects, beatsPerBar } = layout;
  ctx.strokeStyle = PALETTE.staffBars;
  ctx.lineWidth = 3;
  const lineGapTop = trebleRect.h / 10;
  const lineGapBot = bassRect.h / 10;
  const topBandTop = trebleRect.y;
  const topBandBottom = trebleRect.y + lineGapTop * 10;   // full 11-line band (0..10)
  const bottomBandTop = bassRect.y;
  const bottomBandBottom = bassRect.y + lineGapBot * 10;  // full 11-line band

  // Bar lines: one at each bar start plus a final at the end
  const totalBars = barRects.length;
  for (let i = 0; i <= totalBars; i++) {
    const brIndex = (i === totalBars) ? totalBars - 1 : i;
    const br = barRects[brIndex];
    const x = Math.round(i === totalBars ? (br.x + br.w) : br.x);
    // top band (full 11-line range, middle line implied by gap only in staff renderer)
    ctx.beginPath();
    ctx.moveTo(x + 0.5, topBandTop);
    ctx.lineTo(x + 0.5, topBandBottom);
    ctx.stroke();
    // bottom band
    ctx.beginPath();
    ctx.moveTo(x + 0.5, bottomBandTop);
    ctx.lineTo(x + 0.5, bottomBandBottom);
    ctx.stroke();
  }

  // Note-entry guide lines (sky blue), 4 per bar per staff band
  ctx.save();
  ctx.strokeStyle = '#87ceeb'; // sky blue
  ctx.lineWidth = 1.5;
  barRects.forEach((br) => {
    const bx = br.x;
    const bw = br.w;
    for (let i = 0; i < beatsPerBar; i++) {
      const t = (i + 0.5) / beatsPerBar;
      const x = bx + bw * t;
      // From just below first line to just above last line in each 11-line band
      const bandSpanTop = (topBandBottom - topBandTop);
      const bandSpanBot = (bottomBandBottom - bottomBandTop);
      const topPadSeg = bandSpanTop * 0.06;
      const botPadSeg = bandSpanBot * 0.06;
      // top staff band
      ctx.beginPath();
      ctx.moveTo(x + 0.5, topBandTop + topPadSeg);
      ctx.lineTo(x + 0.5, topBandBottom - topPadSeg);
      ctx.stroke();
      // bottom staff band
      ctx.beginPath();
      ctx.moveTo(x + 0.5, bottomBandTop + botPadSeg);
      ctx.lineTo(x + 0.5, bottomBandBottom - botPadSeg);
      ctx.stroke();
    }
  });
  ctx.restore();
}

// Map a vertical canvas Y position within a staff band to a staff index 0..10
// Intentionally unused helper for mapping Y to staff index; keep for future use.
// eslint-disable-next-line no-unused-vars
function _yToStaffIndex(y, rect) {
  const lineGap = rect.h / 10;
  const rel = (y - rect.y) / lineGap;
  return Math.max(0, Math.min(10, Math.round(rel)));
}

// Simple note-head drawing for quarter notes
function drawQuarterNote(ctx, x, y, color) {
  const rx = 10;
  const ry = 9; // slightly taller than space between staff lines
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(-Math.PI / 8);
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// Draw all user-entered notes on top of grid
function drawNotes(ctx, layout, state) {
  if (!state || !state.notes || state.notes.length === 0) return;
  const { trebleRect, bassRect, beatsPerBar, barRects } = layout;
  const lineGapTop = trebleRect.h / 10;
  const lineGapBot = bassRect.h / 10;
  state.notes.forEach((note) => {
    const barRect = barRects[note.bar];
    if (!barRect) return;
    const bx = barRect.x;
    const bw = barRect.w;
    const beatCenter = bx + bw * ((note.beat + 0.5) / beatsPerBar);
    const isTop = note.staff === 'top';
    const bandRect = isTop ? trebleRect : bassRect;
    const lineGap = isTop ? lineGapTop : lineGapBot;
    const y = bandRect.y + note.position * lineGap;
    drawQuarterNote(ctx, beatCenter, y, PALETTE.accentGreen);
  });
}

function drawControlPanel(ctx, layout, state) {
  const { panelRect } = layout;
  const r = panelRect;

  ctx.fillStyle = PALETTE.panelBg;
  ctx.fillRect(r.x, r.y, r.w, r.h);
  ctx.strokeStyle = PALETTE.panelBorder;
  ctx.lineWidth = 3;
  ctx.strokeRect(r.x + 0.5, r.y + 0.5, r.w - 1, r.h - 1);

  const pad = Math.round(r.w * 0.16);
  const playH = Math.round(r.h * 0.10);
  const playRect = {
    x: r.x + pad,
    y: r.y + pad,
    w: r.w - pad * 2,
    h: playH
  };

  // Play/pause button
  const playing = !!(state && state.playback && state.playback.isPlaying);
  ctx.save();
  ctx.globalAlpha = 0.88; // let tablet texture show through
  ctx.fillStyle = playing ? PALETTE.accentGreen : '#111722';
  const radius = Math.round(playRect.h * 0.35);
  roundRect(ctx, playRect.x, playRect.y, playRect.w, playRect.h, radius);
  ctx.fill();
  ctx.restore();

  // Icon
  ctx.fillStyle = PALETTE.text;
  ctx.strokeStyle = PALETTE.text;
  const cx = playRect.x + playRect.w * 0.5;
  const cy = playRect.y + playRect.h * 0.5;
  const iconW = playRect.w * 0.14;
  const iconH = playRect.h * 0.46;
  ctx.beginPath();
  if (!playing) {
    // Play triangle
    ctx.moveTo(cx - iconW * 0.4, cy - iconH * 0.5);
    ctx.lineTo(cx - iconW * 0.4, cy + iconH * 0.5);
    ctx.lineTo(cx + iconW * 0.6, cy);
    ctx.closePath();
    ctx.fill();
  } else {
    // Pause bars
    const barW = iconW * 0.32;
    ctx.fillRect(cx - barW - barW * 0.3, cy - iconH * 0.5, barW, iconH);
    ctx.fillRect(cx + barW * 0.3, cy - iconH * 0.5, barW, iconH);
  }

  // Note/rest selector slots
  const selectorTop = playRect.y + playRect.h + pad * 1.3;
  const slotH = Math.round(r.h * 0.09);
  const gapY = Math.round(r.h * 0.03);
  const labels = ['Quarter Note', 'Quarter Rest'];
  const selectedIndex = state && typeof state.selectedToolIndex === 'number'
    ? state.selectedToolIndex
    : 0;

  ctx.font = `${Math.round(slotH * 0.40)}px system-ui, sans-serif`;
  ctx.textBaseline = 'middle';

  labels.forEach((label, i) => {
    const y = selectorTop + i * (slotH + gapY);
    const slotRect = { x: r.x + pad, y, w: r.w - pad * 2, h: slotH };
    const isSel = i === selectedIndex;
    ctx.save();
    ctx.globalAlpha = 0.88;
    ctx.fillStyle = isSel ? 'rgba(23,255,28,0.18)' : 'rgba(255,255,255,0.03)';
    roundRect(ctx, slotRect.x, slotRect.y, slotRect.w, slotRect.h, Math.round(slotH * 0.4));
    ctx.fill();
    ctx.restore();
    ctx.strokeStyle = isSel ? PALETTE.accentGreen : PALETTE.staffBars;
    ctx.lineWidth = 2;
    roundRect(ctx, slotRect.x, slotRect.y, slotRect.w, slotRect.h, Math.round(slotH * 0.4));
    ctx.stroke();

    ctx.fillStyle = PALETTE.text;
    ctx.textAlign = 'center';
    ctx.fillText(label, slotRect.x + slotRect.w / 2, slotRect.y + slotRect.h / 2);
    ctx.textAlign = 'start';
  });
}

function roundRect(ctx, x, y, w, h, r) {
  const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + w - radius, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
  ctx.lineTo(x + w, y + h - radius);
  ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
  ctx.lineTo(x + radius, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}

// Utility to attach a canvas texture and initial sheet UI to the tablet screen.
// Call this from the piano scene once the GLB is loaded and added to the scene.

export function setupMusicTabletScreen(rootObject3D) {
  if (!rootObject3D || !rootObject3D.isObject3D) return null;

  let screenMesh = rootObject3D.getObjectByName("pe'rPad_screen");
  if (!screenMesh) {
    rootObject3D.traverse(obj => {
      if (!screenMesh && obj.isMesh && /pe'rpad_screen/i.test(obj.name || '')) {
        screenMesh = obj;
      }
    });
  }
  if (!screenMesh || !screenMesh.material) return null;

  const CW = 2048;
  const CH = 2048;
  const canvas = document.createElement('canvas');
  canvas.width = CW;
  canvas.height = CH;
  const ctx = canvas.getContext('2d');
  if (!ctx) return null;

  const margin = 30;
  const layout = computeLayout(CW, CH, margin, { bars: 4, beatsPerBar: 4 });

  drawTabletFrame(ctx, CW, CH, margin);
  drawStaffBand(ctx, layout.trebleRect);
  drawStaffBand(ctx, layout.bassRect);
  drawBarsAndBeats(ctx, layout);
  const initialState = {
    playback: { isPlaying: false },
    selectedToolIndex: 0,
    // Single test note: first beat of first bar, roughly middle of top staff
    notes: [
      { staff: 'top', bar: 0, beat: 0, position: 5, midi: 72 }
    ]
  };
  drawControlPanel(ctx, layout, initialState);
  drawNotes(ctx, layout, initialState);

  const texture = new THREE.CanvasTexture(canvas);
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = 8;
  texture.flipY = false;

  // If UVs only occupy a sub-rect, remap so our canvas fills it
  try {
    const geo = screenMesh.geometry;
    if (geo && geo.attributes && geo.attributes.uv) {
      const uv = geo.attributes.uv;
      let umin = 1, vmin = 1, umax = 0, vmax = 0;
      for (let i = 0; i < uv.count; i++) {
        const u = uv.getX(i);
        const v = uv.getY(i);
        if (u < umin) umin = u;
        if (u > umax) umax = u;
        if (v < vmin) vmin = v;
        if (v > vmax) vmax = v;
      }
      const ur = Math.max(1e-4, umax - umin);
      const vr = Math.max(1e-4, vmax - vmin);
      const repU = 1 / ur;
      const repV = 1 / vr;
      const offU = -umin / ur;
      const offV = -vmin / vr;
      texture.repeat.set(repU, repV);
      texture.offset.set(offU, offV);
    }
  } catch {
    // Fallback: leave texture at default mapping
  }

  const mat = Array.isArray(screenMesh.material) ? screenMesh.material[0] : screenMesh.material;
  mat.map = texture;
  mat.emissive = new THREE.Color(0xffffff);
  mat.emissiveIntensity = 1.0;
  mat.emissiveMap = texture;
  mat.needsUpdate = true;

  return { canvas, ctx, texture, screenMesh, layout, state: initialState };
}

===== END FILE: music-transcription.js =====


===== START FILE: music.js =====

// === RESET-DEBUG: detect reload vs navigation vs HMR ===
(() => {
    const tag = (msg, extra={}) => console.log('[RESET-DEBUG] ' + msg, extra);
    try{
        window.addEventListener('beforeunload', () => tag('beforeunload (page is unloading)', {url: location.href}));
        window.addEventListener('unload', () => tag('unload', {url: location.href}));
        window.addEventListener('popstate', () => tag('popstate', {url: location.href}));
        window.addEventListener('hashchange', () => tag('hashchange', {url: location.href}));
        const _push = history.pushState.bind(history);
        const _replace = history.replaceState.bind(history);
        history.pushState = function(...args){ tag('history.pushState', {args, stack: (new Error()).stack}); return _push(...args); };
        history.replaceState = function(...args){ tag('history.replaceState', {args, stack: (new Error()).stack}); return _replace(...args); };
        window.addEventListener('error', (ev) => tag('window error', {message: ev.message, filename: ev.filename, lineno: ev.lineno, colno: ev.colno}));
        window.addEventListener('unhandledrejection', (ev) => tag('unhandledrejection', {reason: ev.reason}));
        const key = '__reset_debug_count__';
        const n = Number(sessionStorage.getItem(key) || 0) + 1;
        sessionStorage.setItem(key, String(n));
        tag('boot', {bootCountThisTab: n, url: location.href, navType: performance.getEntriesByType('navigation')?.[0]?.type});
    }catch(e){ console.warn('[RESET-DEBUG] instrumentation failed', e); }
})();

// Bubble system: PNG note-bubbles with gentle physics.
// Now spawns appear at the center, grow in, drift outward, collide softly, and exit on any side.

document.addEventListener('DOMContentLoaded', () => {
    const headCircle = document.getElementById('head-inner');
    if (!headCircle) return;

    const cx = parseFloat(headCircle.getAttribute('cx'));
    const cy = parseFloat(headCircle.getAttribute('cy'));
    const r  = parseFloat(headCircle.getAttribute('r'));

    // Use the clipped group under #Notes
    const notesRoot = document.querySelector('#Notes > g');
    if (!notesRoot) return;
    while (notesRoot.firstChild) notesRoot.removeChild(notesRoot.firstChild);

    // Build image sources (encode space in folder name)
    const sources = Array.from({ length: 48 }, (_, i) => {
        const n = (i + 1).toString().padStart(2, '0');
        return `assets/images/note-bubbles/Note-${n}.png`;
    });

    // Classification metadata for each source: { src, color, shapeId }
    const COLOR_KEYS = ['blue', 'purple', 'pink', 'amber'];
    const visibleColorCounts = new Map(COLOR_KEYS.map(k => [k, 0]));
    const visibleShapeCounts = new Map(); // shapeId -> count
    const visibleShapeColorCounts = new Map(); // `${shapeId}|${color}` -> count
    let metas = []; // filled after classification
    let metaReady = false;

    // Small canvas for analysis
    const can16 = document.createElement('canvas');
    can16.width = 16; can16.height = 16;
    const ctx16 = can16.getContext('2d');
    const can32 = document.createElement('canvas');
    can32.width = 32; can32.height = 32;
    const ctx32 = can32.getContext('2d');

    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) { h = s = 0; }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h *= 60;
        }
        return [h, s, l];
    }

    function classifyColor(h) {
        // Map hue to one of four buckets: blue, purple, pink, amber
        // Blue ~190-240, Purple ~260-320, Pink: h>330 or h<20, Amber ~20-70
        if (h >= 190 && h < 250) return 'blue';
        if (h >= 250 && h < 330) return 'purple';
        if (h >= 330 || h < 20) return 'pink';
        return 'amber';
    }

    function averageHash(img) {
        // Draw scaled to 16x16 grayscale and compute a 256-bit aHash (boolean array)
        ctx16.clearRect(0, 0, 16, 16);
        ctx16.drawImage(img, 0, 0, 16, 16);
        const data = ctx16.getImageData(0, 0, 16, 16).data;
        const gray = new Float32Array(256);
        let sum = 0;
        for (let i = 0, p = 0; i < data.length; i += 4, p++) {
            const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
            const v = a < 10 ? 0 : (0.2126 * r + 0.7152 * g + 0.0722 * b);
            gray[p] = v; sum += v;
        }
        const avg = sum / 256;
        const bits = new Uint8Array(256);
        for (let i = 0; i < 256; i++) bits[i] = gray[i] >= avg ? 1 : 0;
        return bits;
    }

    function hammingDistance(a, b) {
        let d = 0; for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) d++;
        return d;
    }

    function fallbackColorForIndex(i) {
        // Deterministic round-robin fallback
        const m = i % 4;
        return COLOR_KEYS[m];
    }

    async function loadAndClassify() {
        const clusterHashes = []; // representative hash per shape cluster
        const metasLocal = [];
        await Promise.all(sources.map((src, index) => new Promise(resolve => {
            const img = new Image();
            img.onload = () => {
                let color = fallbackColorForIndex(index);
                let hash = null;
                try {
                    // Color classification from 32x32 average hue of opaque pixels
                    ctx32.clearRect(0, 0, 32, 32);
                    ctx32.drawImage(img, 0, 0, 32, 32);
                    const data = ctx32.getImageData(0, 0, 32, 32).data;
                    let rSum = 0, gSum = 0, bSum = 0, count = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        const a = data[i + 3];
                        if (a > 10) { rSum += data[i]; gSum += data[i + 1]; bSum += data[i + 2]; count++; }
                    }
                    if (count > 0) {
                        const rA = rSum / count, gA = gSum / count, bA = bSum / count;
                        const [h] = rgbToHsl(rA, gA, bA);
                        color = classifyColor(h);
                    }
                    // Shape clustering using aHash and Hamming distance
                    hash = averageHash(img);
                } catch {
                    // Canvas read might fail (e.g., file://); keep fallback color and unique hash null
                }
                let shapeId = -1;
                if (hash) {
                    for (let c = 0; c < clusterHashes.length; c++) {
                        const hd = hammingDistance(hash, clusterHashes[c]);
                        if (hd <= 24) { shapeId = c; break; } // similar enough
                    }
                    if (shapeId === -1) { shapeId = clusterHashes.length; clusterHashes.push(hash); }
                } else {
                    // Fallback: treat each file as its own shape to honor max-2 rule
                    shapeId = index;
                }
                metasLocal.push({ src, color, shapeId });
                resolve();
            };
            img.onerror = () => { metasLocal.push({ src, color: fallbackColorForIndex(index), shapeId: index }); resolve(); };
            img.src = src;
        })));
        metas = metasLocal;
        metaReady = true;
    }

    // World in SVG user units (viewBox)
    const bubbles = [];
    const rand = (min, max) => min + Math.random() * (max - min);

    // Tunnel vertical bounds
    const yMin = cy - r;
    const yMax = cy + r;

    // Physics
        const TICK_MS = 30;
            const FRICTION = 0.985;
            const FRICTION_Y = 0.985;
            const MAX_BUBBLES = 24; // normal-size cap
    const COLLISION_IMPULSE = 0.012; // gentler bumps
        const SEP_BIAS = 1.08; // a bit more spacing to avoid repeat contacts
    const POST_COLLISION_SOFTEN = 0.9; // damp velocities slightly after a collision
        const MAX_VY = 0.25; // clamp vertical velocity to avoid jarring motion
    const OUTWARD_ACCEL = 0.002; // gentler radial push from center
    const GROW_MS = 600; // duration to scale from 0 -> 1 for new spawns
    const timeNow = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    const MIN_LIVE_MS = GROW_MS + 1000; // longer grace period before eligible to despawn
    const MAX_SPEED = 0.28; // absolute speed clamp to prevent ejection
    const INIT_SCALE = 0.01; // initial tiny scale for new spawns

                // Size range as a fraction of circle diameter (~35–40%), 1.5x previously; now 75% of that
            const circleD = (2 * r);
                const dMin = circleD * 0.35 * 1.5 * 0.75; // ~39.4%
                const dMax = circleD * 0.40 * 1.5 * 0.75; // ~45%

    // Size tiers
    const MAX_NORMAL = MAX_BUBBLES;
    const MAX_TINY = Math.round(MAX_NORMAL * 3); // allow many smalls
    const MAX_BIG = 0; // big bubbles disabled for center-flow
    const TINY_PER_NORMAL_MIN = 1;
    const TINY_PER_NORMAL_MAX = 2;
    const TINY_SIZE_FRAC_MIN = 0.35;
    const TINY_SIZE_FRAC_MAX = 0.55;

    let ageCounter = 0;

    function createImage(src, d) {
        const img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src);
        img.setAttribute('href', src);
        img.setAttribute('width', d.toFixed(3)); // will be updated if scaled
        img.setAttribute('height', d.toFixed(3));
        img.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        img.setAttribute('class', 'bubble');
        img.style.opacity = '0.9';
        img.style.imageRendering = 'auto';
        return img;
    }

        function pickMeta(preferColor = null) {
            if (!metaReady || metas.length === 0) {
                // Fallback to random source if classification not ready
                const src = sources[Math.floor(Math.random() * sources.length)];
                return { src, color: 'blue', shapeId: -1 };
            }
            // Determine colors present; if any color has zero visible, force that color
            const missingColors = COLOR_KEYS.filter(c => (visibleColorCounts.get(c) || 0) === 0);
            const forcedColor = preferColor || (missingColors.length ? missingColors[Math.floor(Math.random() * missingColors.length)] : null);

            const bannedShapes = new Set();
            visibleShapeCounts.forEach((count, sid) => { if (count >= 2) bannedShapes.add(sid); });
            const bannedPairs = new Set();
            visibleShapeColorCounts.forEach((count, key) => { if (count >= 1) bannedPairs.add(key); });

            const candidates = metas.filter(m => (forcedColor ? m.color === forcedColor : true)
                && !bannedShapes.has(m.shapeId)
                && !bannedPairs.has(`${m.shapeId}|${m.color}`));
            if (candidates.length) return candidates[Math.floor(Math.random() * candidates.length)];

            // Relax shape rule slightly if empty
            const relaxed = metas.filter(m => (forcedColor ? m.color === forcedColor : true)
                && (visibleShapeCounts.get(m.shapeId) || 0) < 2
                && !bannedPairs.has(`${m.shapeId}|${m.color}`)); // never violate shape-color uniqueness
            if (relaxed.length) return relaxed[Math.floor(Math.random() * relaxed.length)];

            // Fallback to any
            // Still keep shape and shape-color constraints in fallback
            const any = metas.filter(m => !bannedPairs.has(`${m.shapeId}|${m.color}`) && (visibleShapeCounts.get(m.shapeId) || 0) < 2);
            return any.length ? any[Math.floor(Math.random() * any.length)] : metas[Math.floor(Math.random() * metas.length)];
        }

        function registerVisible(meta) {
            if (!meta) return;
            visibleColorCounts.set(meta.color, (visibleColorCounts.get(meta.color) || 0) + 1);
            if (meta.shapeId !== -1) visibleShapeCounts.set(meta.shapeId, (visibleShapeCounts.get(meta.shapeId) || 0) + 1);
            if (meta.shapeId !== -1) {
                const key = `${meta.shapeId}|${meta.color}`;
                visibleShapeColorCounts.set(key, (visibleShapeColorCounts.get(key) || 0) + 1);
            }
        }

        function unregisterVisible(meta) {
            if (!meta) return;
            visibleColorCounts.set(meta.color, Math.max(0, (visibleColorCounts.get(meta.color) || 0) - 1));
            if (meta.shapeId !== -1) visibleShapeCounts.set(meta.shapeId, Math.max(0, (visibleShapeCounts.get(meta.shapeId) || 0) - 1));
            if (meta.shapeId !== -1) {
                const key = `${meta.shapeId}|${meta.color}`;
                visibleShapeColorCounts.set(key, Math.max(0, (visibleShapeColorCounts.get(key) || 0) - 1));
            }
        }

    // Seed the head with bubbles so it's already full on load (normals only)
        function seedInitialBubbles() {
            const leftEdge = cx - r;
            const rightEdge = cx + r;
            const tryCount = MAX_BUBBLES * 12; // cap attempts to avoid long loops
            let attempts = 0;
            // Ensure at least one of each color first if possible
            const ensureColors = [...COLOR_KEYS];
            while (ensureColors.length && attempts < tryCount && bubbles.length < MAX_BUBBLES) {
                attempts++;
                const prefer = ensureColors.shift();
                const meta = pickMeta(prefer);
                const d = rand(dMin, dMax);
                const rB = d / 2;
                let x = 0, y = 0;
                // sample until inside circle
                for (let k = 0; k < 20; k++) {
                    x = rand(leftEdge + rB, rightEdge - rB);
                    y = rand(yMin + rB, yMax - rB);
                    const dxC = x - cx, dyC = y - cy;
                    if (dxC*dxC + dyC*dyC <= (r - rB) * (r - rB)) break;
                }
                let ok = true;
                for (const b of bubbles) {
                    if (!b.alive) continue;
                    const dx = x - b.x, dy = y - b.y;
                    const minD = (rB + b.r) * 0.95;
                    if (dx*dx + dy*dy < minD*minD) { ok = false; break; }
                }
                if (!ok) { ensureColors.unshift(prefer); continue; }
                const img = createImage(meta.src, d);
                img.setAttribute('x', (x - rB).toFixed(3));
                img.setAttribute('y', (y - rB).toFixed(3));
                notesRoot.appendChild(img);
                const vx0 = rand(-0.05, 0.05);
                const vy0 = rand(-0.05, 0.05);
                const bubble = { el: img, x, y, r: rB, vx: vx0, vy:vy0, alive: true, age: ageCounter++, meta, kind: 'normal', scale: 1, baseD: d };
                bubbles.push(bubble);
                registerVisible(meta);
            }
            while (bubbles.length < MAX_BUBBLES && attempts < tryCount) {
                attempts++;
                const meta = pickMeta();
                const d = rand(dMin, dMax);
                const rB = d / 2;
                let x = 0, y = 0;
                for (let k = 0; k < 20; k++) {
                    x = rand(leftEdge + rB, rightEdge - rB);
                    y = rand(yMin + rB, yMax - rB);
                    const dxC = x - cx, dyC = y - cy;
                    if (dxC*dxC + dyC*dyC <= (r - rB) * (r - rB)) break;
                }
                // avoid heavy overlaps on seed (allow a little)
                let ok = true;
                for (const b of bubbles) {
                    if (!b.alive) continue;
                    const dx = x - b.x, dy = y - b.y;
                    const minD = (rB + b.r) * 0.95;
                    if (dx*dx + dy*dy < minD*minD) { ok = false; break; }
                }
                if (!ok) continue;
                const img = createImage(meta.src, d);
                img.setAttribute('x', (x - rB).toFixed(3));
                img.setAttribute('y', (y - rB).toFixed(3));
                notesRoot.appendChild(img);
                const vx0 = rand(-0.05, 0.05);
                const vy0 = rand(-0.05, 0.05);
                const bubble = { el: img, x, y, r: rB, vx: vx0, vy: vy0, alive: true, age: ageCounter++, meta, kind: 'normal', scale: 1, baseD: d };
                bubbles.push(bubble);
                registerVisible(meta);
            }
        }

        // Seed tiny bubbles proportional to current normal count
        function seedInitialTinyBubbles() {
            const leftEdge = cx - r;
            const rightEdge = cx + r;
            const tryCount = MAX_TINY * 16;
            let attempts = 0;
            const normalCount = bubbles.filter(b => b.alive && b.kind === 'normal').length;
            const desired = Math.min(MAX_TINY, normalCount * 3); // ~3 tinies per normal
            const avgNormal = (dMin + dMax) * 0.5;
            while (bubbles.filter(b => b.alive && b.kind === 'tiny').length < desired && attempts < tryCount) {
                attempts++;
                const meta = pickMeta();
                const d = avgNormal * rand(TINY_SIZE_FRAC_MIN, TINY_SIZE_FRAC_MAX);
                const rB = d / 2;
                let x = 0, y = 0;
                for (let k = 0; k < 20; k++) {
                    x = rand(leftEdge + rB, rightEdge - rB);
                    y = rand(yMin + rB, yMax - rB);
                    const dxC = x - cx, dyC = y - cy;
                    if (dxC*dxC + dyC*dyC <= (r - rB) * (r - rB)) break;
                }
                // avoid heavy overlaps (allow closer since tiny)
                let ok = true;
                for (const b of bubbles) {
                    if (!b.alive) continue;
                    const dx = x - b.x, dy = y - b.y;
                    const minD = (rB + b.r) * 0.9;
                    if (dx*dx + dy*dy < minD*minD) { ok = false; break; }
                }
                if (!ok) continue;
                const img = createImage(meta.src, d);
                img.setAttribute('x', (x - rB).toFixed(3));
                img.setAttribute('y', (y - rB).toFixed(3));
                notesRoot.appendChild(img);
                const vx0 = rand(-0.05, 0.05);
                const vy0 = rand(-0.05, 0.05);
                const bubble = { el: img, x, y, r: rB, vx: vx0, vy: vy0, alive: true, age: ageCounter++, meta, kind: 'tiny', scale: 1, baseD: d };
                bubbles.push(bubble);
                registerVisible(meta);
            }
        }

    function spawnBubble() {
            // Helpers
            function cullOldestOfKind(kind) {
                let cap = MAX_NORMAL; if (kind === 'tiny') cap = MAX_TINY; else if (kind === 'big') cap = MAX_BIG;
                let count = 0; for (const b of bubbles) if (b.alive && b.kind === kind) count++;
                if (count < cap) return;
                let oldestIdx = -1; let oldestAge = Infinity;
                for (let i = 0; i < bubbles.length; i++) {
                    const b = bubbles[i];
                    if (!b.alive || b.kind !== kind) continue;
                    if (b.age < oldestAge) { oldestAge = b.age; oldestIdx = i; }
                }
                if (oldestIdx >= 0) {
                    const rem = bubbles[oldestIdx];
                    rem.alive = false;
                    if (rem.el && rem.el.parentNode) rem.el.parentNode.removeChild(rem.el);
                    unregisterVisible(rem.meta);
                    bubbles.splice(oldestIdx, 1);
                }
            }

            function spawnFromCenter(meta, d, kind) {
                const rB = d / 2;
                const startX = cx;
                const startY = cy;
                const img = createImage(meta.src, d);
                // pre-position off-circle (optional safety; will be overridden below)
                const outsideR = r + dMax + 2;
                const oDir = Math.random() * Math.PI * 2;
                const ox = cx + Math.cos(oDir) * outsideR;
                const oy = cy + Math.sin(oDir) * outsideR;
                img.setAttribute('x', (ox - rB).toFixed(3));
                img.setAttribute('y', (oy - rB).toFixed(3));
                // immediately set to tiny at center so first paint is correct
                const dInit = d * INIT_SCALE;
                img.setAttribute('width', dInit.toFixed(3));
                img.setAttribute('height', dInit.toFixed(3));
                img.setAttribute('x', (startX - rB * INIT_SCALE).toFixed(3));
                img.setAttribute('y', (startY - rB * INIT_SCALE).toFixed(3));
                notesRoot.appendChild(img);
                const dir = Math.random() * Math.PI * 2;
                const vmag = rand(0.03, 0.08);
                const vx0 = Math.cos(dir) * vmag;
                const vy0 = Math.sin(dir) * vmag;
                const bubble = { el: img, x: startX, y: startY, r: rB, vx: vx0, vy: vy0, alive: true, age: ageCounter++, meta, kind, scale: INIT_SCALE, baseD: d, createdAt: timeNow() };
                bubbles.push(bubble);
                registerVisible(meta);
            }

            // 1) Normal
            cullOldestOfKind('normal');
            const metaN = pickMeta();
            const dN = rand(dMin, dMax);
            spawnFromCenter(metaN, dN, 'normal');

            // 2) Tinies: 2-4 per normal
            const tinyCount = Math.floor(rand(TINY_PER_NORMAL_MIN, TINY_PER_NORMAL_MAX + 1));
            for (let i = 0; i < tinyCount; i++) {
                cullOldestOfKind('tiny');
                const metaT = pickMeta();
                const dT = dN * rand(TINY_SIZE_FRAC_MIN, TINY_SIZE_FRAC_MAX);
                spawnFromCenter(metaT, dT, 'tiny');
            }

            // Big bubbles disabled in center-flow
    }

        function scheduleNextSpawn() {
            const delay = rand(900, 1600); // slower spawning cadence
        setTimeout(() => {
            try {
                spawnBubble();
            } catch (e) {
                // Swallow to keep the scheduler alive
                console.error('spawnBubble error:', e);
            } finally {
                scheduleNextSpawn();
            }
        }, delay);
    }

        // Occasional extra tiny spawns to keep a lively field
        function scheduleTinyDrizzle() {
            const delay = rand(1400, 2600);
            setTimeout(() => {
                try {
                    // spawn 1-2 tinies if under cap
                    const countTiny = bubbles.filter(b => b.alive && b.kind === 'tiny').length;
                    if (countTiny < MAX_TINY) {
                        const n = Math.floor(rand(1, 3));
                        for (let i = 0; i < n; i++) {
                            const metaT = pickMeta();
                            const dBase = (dMin + dMax) * 0.5;
                            const dT = dBase * rand(TINY_SIZE_FRAC_MIN, TINY_SIZE_FRAC_MAX);
                            // spawn from center
                            const rB = dT / 2;
                            const startX = cx;
                            const startY = cy;
                            const img = createImage(metaT.src, dT);
                            // pre-position off-circle, then first-paint at tiny center
                            const outsideR = r + dMax + 2;
                            const oDir = Math.random() * Math.PI * 2;
                            const ox = cx + Math.cos(oDir) * outsideR;
                            const oy = cy + Math.sin(oDir) * outsideR;
                            img.setAttribute('x', (ox - rB).toFixed(3));
                            img.setAttribute('y', (oy - rB).toFixed(3));
                            const dInit = dT * INIT_SCALE;
                            img.setAttribute('width', dInit.toFixed(3));
                            img.setAttribute('height', dInit.toFixed(3));
                            img.setAttribute('x', (startX - rB * INIT_SCALE).toFixed(3));
                            img.setAttribute('y', (startY - rB * INIT_SCALE).toFixed(3));
                            notesRoot.appendChild(img);
                            const dir = Math.random() * Math.PI * 2;
                            const vmag = rand(0.03, 0.08);
                            const vx0 = Math.cos(dir) * vmag;
                            const vy0 = Math.sin(dir) * vmag;
                            const bubble = { el: img, x: startX, y: startY, r: rB, vx: vx0, vy: vy0, alive: true, age: ageCounter++, meta: metaT, kind: 'tiny', scale: 0.01, baseD: dT, createdAt: timeNow() };
                            bubbles.push(bubble);
                            registerVisible(metaT);
                        }
                    }
                } catch (e) {
                    console.error('tiny drizzle error:', e);
                } finally {
                    scheduleTinyDrizzle();
                }
            }, delay);
        }

    function integrateAndCollide() {
        if (!bubbles.length) return;

        // Integrate
        for (const b of bubbles) {
            if (!b.alive) continue;
            // growth for newly spawned
            if (b.scale === undefined) b.scale = 1;
            if (b.baseD === undefined) b.baseD = b.r * 2;
            if (b.createdAt !== undefined && b.scale < 1) {
                const t = Math.max(0, timeNow() - b.createdAt);
                b.scale = Math.min(1, t / GROW_MS);
            }
            // outward radial push
            const dxC = b.x - cx, dyC = b.y - cy;
            const distC = Math.sqrt(dxC*dxC + dyC*dyC) || 1e-6;
            const nxC = dxC / distC, nyC = dyC / distC;
            b.vx += nxC * OUTWARD_ACCEL;
            b.vy += nyC * OUTWARD_ACCEL;
            b.vx = b.vx * FRICTION;
            b.vy = b.vy * FRICTION_Y;
            // clamp overall speed
            {
                const sp2 = b.vx*b.vx + b.vy*b.vy;
                const max2 = MAX_SPEED*MAX_SPEED;
                if (sp2 > max2) {
                    const s = Math.sqrt(sp2) || 1e-6;
                    const k = MAX_SPEED / s;
                    b.vx *= k; b.vy *= k;
                }
            }
            // integrate
            b.x += b.vx;
            b.y += b.vy;
            // Safety: during initial growth phase, prevent slipping out immediately near the boundary
            if (b.createdAt !== undefined && (timeNow() - b.createdAt) < (GROW_MS + 250)) {
                const sc = (b.scale !== undefined ? b.scale : 1);
                const effR = b.r * sc;
                const dx = b.x - cx, dy = b.y - cy;
                const dist = Math.sqrt(dx*dx + dy*dy) || 1e-6;
                if (dist + effR > r * 0.97) {
                    const nx = dx / dist, ny = dy / dist;
                    // damp outward radial velocity strongly
                    const vOut = b.vx * nx + b.vy * ny;
                    if (vOut > 0) {
                        b.vx -= nx * vOut * 0.9;
                        b.vy -= ny * vOut * 0.9;
                    }
                    // small inward nudge
                    b.x -= nx * 0.4;
                    b.y -= ny * 0.4;
                }
            }
        }

        // Collisions
        for (let i = 0; i < bubbles.length; i++) {
            const a = bubbles[i];
            if (!a.alive) continue;
            for (let j = i + 1; j < bubbles.length; j++) {
                const b = bubbles[j];
                if (!b.alive) continue;
                const dx = b.x - a.x, dy = b.y - a.y;
                const ra = (a.r) * (a.scale !== undefined ? a.scale : 1);
                const rb = (b.r) * (b.scale !== undefined ? b.scale : 1);
                const minD = (ra + rb) * SEP_BIAS;
                const dist2 = dx*dx + dy*dy;
                        if (dist2 < minD*minD) {
                    const dist = Math.sqrt(Math.max(1e-6, dist2));
                    const nx = dx / (dist || 1), ny = dy / (dist || 1);
                    const impulse = COLLISION_IMPULSE;
                    a.vx -= nx * impulse * 0.5; a.vy -= ny * impulse * 0.5;
                    b.vx += nx * impulse;       b.vy += ny * impulse;
                    // no directional floor
                            // Softer positional correction
                            const overlap = minD - dist, corr = overlap * 0.22;
                    a.x -= nx * corr; a.y -= ny * corr;
                    b.x += nx * corr; b.y += ny * corr;
                            // Mild damping to reduce jarring after contact
                            a.vx *= POST_COLLISION_SOFTEN; a.vy *= POST_COLLISION_SOFTEN;
                            b.vx *= POST_COLLISION_SOFTEN; b.vy *= POST_COLLISION_SOFTEN;
                            // Clamp vertical velocity
                            // Clamp vertical velocity
                            a.vy = Math.max(-MAX_VY, Math.min(MAX_VY, a.vy));
                            b.vy = Math.max(-MAX_VY, Math.min(MAX_VY, b.vy));
                            // Clamp overall speed post-collision
                            {
                                const spa2 = a.vx*a.vx + a.vy*a.vy;
                                const spb2 = b.vx*b.vx + b.vy*b.vy;
                                const max2 = MAX_SPEED*MAX_SPEED;
                                if (spa2 > max2) {
                                    const s = Math.sqrt(spa2) || 1e-6; const k = MAX_SPEED / s; a.vx *= k; a.vy *= k;
                                }
                                if (spb2 > max2) {
                                    const s = Math.sqrt(spb2) || 1e-6; const k = MAX_SPEED / s; b.vx *= k; b.vy *= k;
                                }
                            }
                }
            }
        }

    // Big eligibility disabled

        // Despawn after fully clearing outside the circle on any side (with margin),
        // but never before a short grace period so new bubbles don't vanish instantly.
    for (const b of bubbles) {
            if (!b.alive) continue;
            const effR = b.r * (b.scale !== undefined ? b.scale : 1);
            const dx = b.x - cx, dy = b.y - cy;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const ageMs = (b.createdAt !== undefined) ? (timeNow() - b.createdAt) : Infinity;
            const grownEnough = (b.scale === undefined) || (b.scale >= 0.98);
            if (grownEnough && ageMs >= MIN_LIVE_MS && dist > r + effR * 2.2) { // margin scaled a bit higher
                b.alive = false;
                if (b.el && b.el.parentNode) b.el.parentNode.removeChild(b.el);
        unregisterVisible(b.meta);
            }
        }

        // Write
        for (const b of bubbles) {
            if (!b.alive) continue;
            const sc = (b.scale !== undefined ? b.scale : 1);
            const dNow = (b.baseD !== undefined ? b.baseD : (b.r * 2)) * sc;
            b.el.setAttribute('width', dNow.toFixed(3));
            b.el.setAttribute('height', dNow.toFixed(3));
            b.el.setAttribute('x', (b.x - (b.r * sc)).toFixed(3));
            b.el.setAttribute('y', (b.y - (b.r * sc)).toFixed(3));
        }
    }

    // Load and classify sources, then seed and start animation
    (async () => {
        try {
            await loadAndClassify();
        } catch (err) {
            console.warn('loadAndClassify failed:', err);
        }
        // Seed normals, then tinies (tinies depend on normal count)
        seedInitialBubbles();
        // Big seeding disabled for center-flow
        // Run tiny seeding on next frame so DOM nodes exist and sizes are set
        await new Promise(requestAnimationFrame);
        seedInitialTinyBubbles();
        scheduleNextSpawn();
        scheduleTinyDrizzle();
        let timer = setInterval(integrateAndCollide, TICK_MS);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (timer) { clearInterval(timer); timer = null; }
            } else {
                // Resume integration loop when tab becomes visible again
                if (!timer) timer = setInterval(integrateAndCollide, TICK_MS);
            }
        });
    })();
});






===== END FILE: music.js =====

