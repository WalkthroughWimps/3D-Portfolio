// videos.js — minimal orchestrator for the Videos page (clean, minimal debug panel)
/* eslint-disable no-unused-vars */
import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
import VideoPlayer from './video-player-controls.js?v=tablet-ui-1';
import { loadTabletGlb, initTabletFromGltf, applyBlenderAlignment } from './videos-tablet.js';

const videosPageConfig = {
  intro: { enabled: false, video: 'Renders/tablet-animation.webm', maxWaitMs: 6000 },
  tabletAlignment: { enabled: true, autoFlip: false, screenMeshName: 'tablet_screen003' }
};

// Load saved tablet pose if present
try {
  const saved = localStorage.getItem('videosPage_tabletPose');
  if (saved) {
    try { videosPageConfig.tabletAlignment.tabletWorld = JSON.parse(saved); console.log('[videos] Loaded saved tablet pose'); } catch (e) { console.warn('Failed parse saved pose', e); }
  }
} catch (e) { /* ignore */ }

function onReady(fn) {
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once: true });
  else fn();
}

onReady(() => {
  // ensure canvas
  let canvas = document.getElementById('glCanvas');
  if (!canvas) {
    try {
      const container = document.querySelector('.viewer-wrap') || document.querySelector('.tablet-stage') || document.body;
      canvas = document.createElement('canvas'); canvas.id = 'glCanvas'; canvas.style.width = '100%'; canvas.style.height = '100%'; canvas.style.display = 'block'; canvas.setAttribute('aria-hidden','true');
      container.appendChild(canvas);
      console.warn('[videos] Created fallback #glCanvas');
    } catch (e) { console.warn('[videos] Failed create canvas', e); }
  }
  if (!canvas) return;

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  try { renderer.outputColorSpace = THREE.SRGBColorSpace; } catch (e) { /* ignore */ }

  const scene = new THREE.Scene();
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.85); scene.add(hemi);
  const keyLight = new THREE.DirectionalLight(0xffffff, 1.0); keyLight.position.set(4,6,8); scene.add(keyLight);
  const ambient = new THREE.AmbientLight(0xffffff, 0.15); scene.add(ambient);

  let camera = null; let controls = null; let animId = null;

  function resizeRenderer() {
    try {
      const w = window.innerWidth;
      const headerEl = document.querySelector('.header') || document.getElementById('patterned-background');
      const headerRect = headerEl && headerEl.getBoundingClientRect ? headerEl.getBoundingClientRect() : { bottom: 0 };
      const availH = Math.max(1, window.innerHeight - Math.max(0, Math.round(headerRect.bottom || 0)));
      try { const stage = document.querySelector('.tablet-stage'); if (stage && stage.style) { stage.style.top = (headerRect.bottom||0)+'px'; stage.style.height = availH+'px'; } } catch (e) {}
      renderer.setSize(w, availH, false);
      if (camera && camera.isPerspectiveCamera) { camera.aspect = w / availH; camera.updateProjectionMatrix(); }
    } catch (e) { /* ignore */ }
  }
  window.addEventListener('resize', resizeRenderer);
  resizeRenderer();

  function animate() {
    try { if (controls && typeof controls.update === 'function') controls.update(); if (camera) renderer.render(scene, camera); }
    catch (e) { /* ignore */ }
    // update debug UI
    try {
      const camEl = document.getElementById('tp_camera');
      const tabEl = document.getElementById('tp_tablet');
      if (camEl && camera) {
        const x = (Math.abs(camera.position.x) < 0.5) ? 0 : Number(camera.position.x.toFixed(1));
        camEl.textContent = `cam: ${x}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
      }
      try {
        const refs = window.__videos_debug && window.__videos_debug._refs ? window.__videos_debug._refs : null;
        if (tabEl && refs && refs.tabletGroup) {
          const p = refs.tabletGroup.position; const ry = (refs.tabletGroup.rotation && refs.tabletGroup.rotation.y) ? (refs.tabletGroup.rotation.y * 180 / Math.PI) : 0;
          tabEl.textContent = `tablet: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}  rotY:${ry.toFixed(1)}°`;
        }
      } catch (e) { /* ignore */ }
    } catch (e) { /* ignore */ }

    animId = requestAnimationFrame(animate);
  }

  const primaryPath = 'glb/video-tablet.glb';
  const allowSound = (new URLSearchParams(location.search)).get('sound') === '1' || localStorage.getItem('allowSound') === 'true';

  // load GLB and init
  const doLoadGlb = () => {
    loadTabletGlb(primaryPath, (gltf) => {
      try {
        const refs = initTabletFromGltf(gltf, { scene, renderer, canvas, underLight: null, videosPageConfig });
        window.__videos_debug = window.__videos_debug || {};
        window.__videos_debug._refs = refs;

        try { camera = refs.camera || camera; } catch (e) {}
        try { controls = refs.controls || controls; } catch (e) {}
        resizeRenderer(); if (!animId) animate();

        // apply saved pose if present
        try {
          const cfgPose = videosPageConfig && videosPageConfig.tabletAlignment && videosPageConfig.tabletAlignment.tabletWorld;
          if (cfgPose && refs && refs.tabletGroup) {
            try {
              if (cfgPose.pos) refs.tabletGroup.position.set(cfgPose.pos.x||0,cfgPose.pos.y||0,cfgPose.pos.z||0);
              if (cfgPose.rotXYZ) refs.tabletGroup.rotation.set(cfgPose.rotXYZ.x||0,cfgPose.rotXYZ.y||0,cfgPose.rotXYZ.z||0);
              if (cfgPose.scale) refs.tabletGroup.scale.set(cfgPose.scale.x||1,cfgPose.scale.y||1,cfgPose.scale.z||1);
              refs.tabletGroup.updateMatrixWorld(true);
            } catch (e) { console.warn('Failed to apply saved pose', e); }
          }
        } catch (e) {}

        // create grid / UI on screen mesh
        try {
          if (refs && refs.screenMesh && refs.camera) {
            // Ensure the screen mesh is oriented toward the camera. If the
            // mesh's surface normal points away from the camera, rotate it
            // 180deg around Y so the front face faces the camera. This
            // matches previous behavior where `tablet_screen003` faced camera.
            try {
              const sm = refs.screenMesh;
              const cam = refs.camera;
              const worldPos = sm.getWorldPosition(new THREE.Vector3());
              const toCam = new THREE.Vector3().subVectors(cam.position, worldPos).normalize();
              const worldQuat = sm.getWorldQuaternion(new THREE.Quaternion());
              const normal = new THREE.Vector3(0, 0, 1).applyQuaternion(worldQuat).normalize();
              if (normal.dot(toCam) < 0) {
                console.log('[videos] screenMesh appears back-facing to camera — rotating to face camera');
                try { sm.rotateY(Math.PI); sm.updateMatrixWorld(true); } catch (ee) { /* ignore */ }
              }
            } catch (e) { /* ignore orientation check errors */ }

            if (VideoPlayer && typeof VideoPlayer.createGrid === 'function') {
              VideoPlayer.createGrid(refs.screenMesh, renderer, refs.camera, refs.tabletGroup, videosPageConfig, { allowSound, replaceScreenMaterial: true });
            }
          }
        } catch (e) { console.warn('createGrid failed', e); }

        // minimal debug panel: camera + tablet + enable-pan (tablet pan)
        try {
          if (!document.getElementById('tablet-debug-panel')) {
            const dp = document.createElement('div');
            dp.id = 'tablet-debug-panel';
            dp.style.cssText = 'position:fixed;right:12px;top:84px;z-index:80;background:rgba(0,0,0,0.6);color:#fff;padding:8px;border-radius:8px;font:12px/1.2 monospace;max-width:260px;';
            dp.innerHTML = `
              <div id="tp_camera">cam:</div>
              <div id="tp_tablet" style="margin-top:6px">tablet:</div>
              <div style="margin-top:8px"><button id="tp_toggle_pan">Enable Pan</button></div>`;
            document.body.appendChild(dp);

            // tablet-pan implementation: raycast to plane and move tabletGroup
            const toggle = document.getElementById('tp_toggle_pan');
            const state = { enabled:false, dragging:false, startPoint:new THREE.Vector3(), startPos:new THREE.Vector3(), plane:null };
            const domEl = renderer.domElement || document;

            toggle.addEventListener('click', () => {
              state.enabled = !state.enabled;
              toggle.textContent = state.enabled ? 'Disable Pan' : 'Enable Pan';
            });

            const pointerDown = (ev) => {
              try {
                if (!state.enabled || !refs || !refs.tabletGroup || !refs.camera) return;
                const rect = domEl.getBoundingClientRect();
                const ndc = new THREE.Vector2(((ev.clientX-rect.left)/rect.width)*2-1, -((ev.clientY-rect.top)/rect.height)*2+1);
                const ray = new THREE.Raycaster(); ray.setFromCamera(ndc, refs.camera);
                const worldPos = new THREE.Vector3(); refs.tabletGroup.getWorldPosition(worldPos);
                const camDir = new THREE.Vector3(); refs.camera.getWorldDirection(camDir);
                state.plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, worldPos);
                const inter = new THREE.Vector3();
                if (ray.ray.intersectPlane(state.plane, inter)) {
                  state.dragging = true; state.startPoint.copy(inter); state.startPos.copy(refs.tabletGroup.position);
                  ev.preventDefault();
                }
              } catch (e) { /* ignore */ }
            };
            const pointerMove = (ev) => {
              try {
                if (!state.dragging || !refs || !refs.tabletGroup || !refs.camera) return;
                const rect = domEl.getBoundingClientRect();
                const ndc = new THREE.Vector2(((ev.clientX-rect.left)/rect.width)*2-1, -((ev.clientY-rect.top)/rect.height)*2+1);
                const ray = new THREE.Raycaster(); ray.setFromCamera(ndc, refs.camera);
                const inter = new THREE.Vector3();
                if (ray.ray.intersectPlane(state.plane, inter)) {
                  const delta = new THREE.Vector3().subVectors(inter, state.startPoint);
                  const newPos = new THREE.Vector3().addVectors(state.startPos, delta);
                  refs.tabletGroup.position.copy(newPos); refs.tabletGroup.updateMatrixWorld(true);
                  ev.preventDefault();
                }
              } catch (e) { /* ignore */ }
            };
            const pointerUp = () => { state.dragging = false; };

            domEl.addEventListener('pointerdown', pointerDown);
            domEl.addEventListener('pointermove', pointerMove);
            domEl.addEventListener('pointerup', pointerUp);
            domEl.addEventListener('pointercancel', pointerUp);
          }
        } catch (e) { /* ignore debug panel errors */ }

        try { applyBlenderAlignment({ tabletGroupRef: refs.tabletGroup, camera: refs.camera, controls, renderer, videosPageConfig }); } catch (e) { /* ignore */ }

      } catch (e) { console.warn('loadTabletGlb init failed', e); }
    }, undefined, (err) => { console.warn('Failed to load GLB', err); });
  };

  // start
  doLoadGlb();

  // reset helper
  window.resetGridInteraction = function resetGridInteraction() {
    try { const api = window.__tabletPlayerApi; if (api && typeof api.reset === 'function') return api.reset(); } catch (e) { /* ignore */ }
    console.log('resetGridInteraction: no player API available');
  };

});
